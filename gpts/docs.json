{
  "docs": [
    {
      "title": "TypeScriptのあらまし",
      "content": "---\nslug: /overview\n---\n\n# TypeScriptのあらまし\n\n本章では、TypeScriptの概要について触れます。同時に、TypeScriptの良さや、TypeScriptがJavaScriptエコシステムでどういった立ち位置にあるのかを示すことで、全体像を知っていただきます。\n\nTypeScriptとは何なのか詳しく知ってもらったり、読者が同僚や属するチームにTypeScriptをPRできるような情報を提供します。TypeScriptの歴史、思想、哲学を知ってもらうことで、どのようなところでTypeScriptがその本領を発揮するのかを学びます。TypeScriptをなぜ使うべきなのか？TypeScriptのアドバンテージは何なのか？逆に、TypeScriptが向かないところはどこなのか？TypeScriptとJavaScriptはどのような関係なのか？といった疑問に答えていきます。\n",
      "url": "https://typescriptbook.jp/overview/README"
    },
    {
      "title": "ECMAScript",
      "content": "# ECMAScript\n\nECMAScriptはJavaScriptの仕様です。TypeScriptもECMAScriptに準拠しています。ECMAScriptとは何なのか、仕様改定のプロセス、ECMAScriptとブラウザの関係がどのようになっているかについて解説します。\n\n## JavaScriptとECMAScriptの関係\n\nECMAScriptはJavaScriptの仕様を定義したものです。仕様とは決まりごとのことで、ブラウザなどがJavaScriptを読み込んだときに、どのような文法を解釈しなければならないか、処理がどのように動くべきかといったことを決めたものです。ECMAScriptという異なる名前がついていますが、JavaScriptと別の言語があるわけではありません。\n\n歴史的には、JavaScriptを標準化するべく、ECMAScriptが策定されました。JavaScriptはNetscape社が開発した言語です。Netscape社が発表してすぐに、Microsoft社もJScriptという名前で実装しました。Netscape社は、JavaScriptを標準化するために、国際規格策定団体Ecmaインターナショナルに依頼します。Ecmaによって標準化されたJavaScriptは「ECMAScript」と呼ばれることになりました。\n\n現在のECMAScriptは、JavaScriptの仕様という立場です。ブラウザなどのJavaScript実装が、従うべき仕様という位置づけです。この関係性から、ECMAScriptの実装のこと指してJavaScriptと呼ぶことがあります。ECMAScriptは仕様なので、ECMAScriptというプログラムがあるわけではありません。ダウンロードしたりインストールするものではないということです。\n\nJavaScriptの仕様が「ECMAScript」と名付けられた理由は諸説あります。当時、競争関係だったNetscape社とMicrosoft社で、ECMAScriptが合意できる妥協案だった説があります。Netscape社はJavaScriptという名前で開発し、Microsoft社はJScriptという名前で開発していました。JavaScriptが商標というのも一因だと考えられています。JavaScriptは当時Sunが所有する商標でした。その後、権利はOracleに引き継がれます。\n\nECMAScriptはEcmaインターナショナルが策定しています。この団体では、情報通信技術のさまざまな国際規格を策定しています。各規格には番号が割り振られています。ECMAScriptの規格番号はECMA-262です。他にもJSON(ECMA-404)やC#(ECMA-334)などがあります。Ecmaインターナショナルにはさまざまな専門委員会があり、ECMAScriptを策定する委員会の名称はTC39です。\n\n## ECMAScriptの仕様改定\n\nECMAScriptは毎年1回、仕様改定されます。改定されるごとにバージョンが上がります。ECMAScriptのバージョンはリリースされた西暦になってます。たとえば、2021年に改定されたECMAScriptはES2021となります。TypeScriptもECMAScriptの仕様改定に合わせて、アップデートされていきます。\n\nECMAScriptの改定は、募集された提案から始まります。応募のあった改定案は[TC39のGitHub](https://github.com/tc39/proposals)で一覧できます。\n\n進捗に応じて、各提案にはステージ0からステージ4までのランクがつきます。条件を満たすとそのステージに進めます。\n\n| ステージ      | 条件                                                                                                                               |\n| ------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| 0 Strawperson | なし                                                                                                                               |\n| 1 Proposal    | チャンピオン(委員会の改定推進パートナー)が決まっていること。課題と解決策を説明したリポジトリが公開されていること。デモがあるとよい |\n| 2 Draft       | ECMAScriptの仕様記述言語で主要な部分の仕様が書かれていること                                                                       |\n| 3 Candidate   | 完全な仕様書があること。レビュアとECMAScript編集者の署名があること                                                                 |\n| 4 Finished    | 2つ以上のJSエンジンに実装が存在していること。ECMAScriptへプルリクエストが送信されており、ECMAScript編集者に承認されていること      |\n\nステージ2以下の提案は仕様が大きく変わる可能性が高いです。提案が取り下げられる可能性も高いです。\n\nステージ3になると、改定が確実視されます。TypeScriptはステージ3に達した提案に対応します。この頃にはブラウザでもステージ3の提案が実装されます。中には実装が遅れるケースもあります。\n\nステージ4になると、ほぼ間違いなくECMAScriptの仕様になります。ステージ4の提案は、例年6月のECMAScriptの改定に加えられます。改定までのおおよその年間スケジュールは次の流れです。\n\n- 2月: 候補ドラフトが作成される\n- 3月: ステージ4の提案が組み込まれ、最終的な仕様が承認される\n- 4月〜6月: ECMA CCおよびECMA GAのレビュー期間\n- 6月: ECMAの総会による承認を経て、改定仕様の確定\n\n## ECMAScriptとブラウザの仕様\n\nECMAScriptが決めるクライアントサイドJavaScriptの仕様は部分的です。ECMAScriptが定める範囲は、言語の文法、構文の解釈方法、コアのAPIなど言語の中核部分です。たとえば、次のようなことを定めています。\n\n- 関数宣言の書き方はこういう文法になる\n- 変数が宣言されたとき、JavaScriptエンジンはこういう動作になる\n- `String`や`Array`オブジェクトにはこういうメソッドがある\n\nJavaScriptのうちブラウザ仕様に関する部分は、HTML Living Standardが決めています。ブラウザでJavaScriptを使うと、触れることになるのが`window`オブジェクトや`HTMLDivElement`、ローカルストレージなどのAPIです。これらは[HTML Living Standard](https://html.spec.whatwg.org/)と呼ばれる規格が定めています。この規格はEcmaインターナショナルとは異なる標準化団体WHATWGが策定しています。\n\nJavaScriptの機能の中でも、ECMAScriptとHTML Living Standardで役割分担があるものもあります。たとえばモジュールです。ECMAScriptはモジュールの仕様を定めます。`import`や`export`の構文や、モジュール内部の仕様などは、ECMAScriptが定めます。一方、モジュールの具体的なロード方法はHTML Living Standardが定めています。たとえば、`import \"指定子\";`の指定子の部分にどんな文字列を書いていいか、モジュールはどの順番でロードするかなどはHTML Living Standardが定めます。\n\n[モジュール](../reference/modules.md)\n\n「JavaScript」と一言で言っても、複数の規格で構成されているわけです。\n\n## ECMAScriptとブラウザの関係性\n\n主要なブラウザの内部を分解すると、レンダリングエンジンやJavaScriptエンジンと呼ばれる部品の単位があります。\n\nJavaScriptエンジンは、ECMAScriptを実装したモジュールです。JavaScriptエンジンには、主要なものでV8、SpiderMonkey、JavaScriptCoreがあります。\n\nレンダリングエンジンは、JavaScriptエンジンを組み込んだブラウザの表示機能を担うモジュールです。有名なレンダリングエンジンは、Blink、Gecko、WebKitがあります。たとえば、BlinkはV8をJavaScriptエンジンに採用しています。レンダリングエンジンはJavaScriptだけでなく、HTMLやCSSを解釈し、画面描画を総合的に行います。\n\nブラウザは、レンダリングエンジンを組み込み、その他にブックマーク機能などの付属機能をつけてアプリケーションというかたちでユーザーに提供されます。たとえば、Google ChromeはBlinkを、SafariはWebKitを組み込んでいます。ブラウザはレンダリングエンジンを変更することもあります。Microsoft Edgeはかつて、EdgeHTMLを採用していましたが、のちにGoogle Chromeと同じBlinkに移行しました。OperaのレンダリングエンジンもPrestoでしたが、Blinkに変更した経緯があります。\n\n同じブラウザブランドでも、iOS版のブラウザのレンダリングエンジンはWebKitです。たとえば、Google ChromeはBlinkを採用していますが、iOS版のGoogle ChromeのレンダリングエンジンはWebKitです。これは、iOSのレンダリングエンジンにWebKitだけが独占的に利用を許されているためです。\n\n<figure>\n<figcaption>ブラウザ、レンダリングエンジン、JavaScriptエンジン、ECMAScriptの関係図</figcaption>\n<a href=\"/img/overview/ecmascript/browser-rendering-engine-javascript-engine-ecmascript-relations.svg\" target=\"_blank\"><img src=\"/img/overview/ecmascript/browser-rendering-engine-javascript-engine-ecmascript-relations.svg\" width=\"800\"/></a>\n</figure>\n\nTypeScriptプログラマーがブラウザとエンジンの対応を理解しておくことは重要です。エンジンを知ることは、開発したプログラムが実行される環境を把握することと同義です。エンジンは仕様にできるだけ準拠しますが、エンジンによって実装が異なることがあります。エンジンによっては実装がされていない仕様がある場合もあります。また、ブラウザによっては古いエンジンを使っている場合もあります。\n\nプログラムをテストするときも、ブラウザとエンジンの組み合わせが理解できていると、同じエンジンを採用しているブラウザはテストを省略できる場合もあります。iOSのWebKit独占の例のように、同じブランド名のブラウザでもエンジンが異なる場合があります。この場合、テストで網羅するブラウザを増やすといった意思決定が行えるようになります。\n\n<PostILearned>\n\n・ECMAScript(ES)はJavaScriptの仕様\n・ESはEcmaインターナショナルのTC39委員会が定める\n・ESは毎年6月に改定される\n・ESの改定提案は公募され、ステージ4で採用される\n・ブラウザはレンダリングエンジンとJSエンジンを持つ\n・JSエンジンはESを実装する\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/overview/ecmascript"
    },
    {
      "title": "TypeScriptは何ではないか？",
      "content": "# TypeScriptは何ではないか？\n\n多くの開発者がTypeScriptを高く評価しています。そのような中、誤解の上にTypeScriptを過度に高評価する人もいます。TypeScriptも魔法の杖ではありません。本稿では、TypeScriptが何を解決してくれないのかを見ていきます。TypeScriptでできないことを無理にやらせようとしても、その努力は無駄になりますから、これを理解することは重要です。\n\n## 実行時の高速化・省メモリ化に影響しない\n\nしばしば、TypeScriptとJavaScriptを比較する話の中で、次のような言説が見られます。\n\n- TypeScriptはJavaScriptより高速に実行できる\n- TypeScriptはJavaScriptよりメモリ消費量が少ない\n\nまた逆に次のように心配されることもあります。\n\n- TypeScriptはJavaScriptで書くより低速になるのでは？\n- TypeScriptはJavaScriptよりメモリ消費量が大きいのでは？\n\n結論を言うと、TypeScriptの実行時パフォーマンスはJavaScriptと同じです。これを理解するには、次の2つの前提をおさえておく必要がります。\n\n1. TypeScriptのランタイムはない。\n1. TypeScriptコンパイラは最適化しない。\n\n### TypeScriptランタイムはない\n\nTypeScriptにはランタイムがありません。どういうことかというと、TypeScriptを直接実行するエンジンがないということです。TypeScriptを開発しているMicrosoftのブラウザMicrosoft Edgeであっても、TypeScriptは実行できません。サーバーのNode.jsもそうです[^1]。TypeScriptで書いたコードを実行するには、一度JavaScriptコードに変換する必要があります。そのため、TypeScriptのパフォーマンスは、コンパイル後のJavaScriptがどうなっているかで決まるわけです。\n\n[^1]: TypeScriptのランタイムを謳うDenoというサーバー環境があります。このDenoであっても、内部的にTypeScriptをJavaScriptにコンパイルし、それをJavaScriptエンジン上で実行しています。\n\n### TypeScriptコンパイラは最適化しない\n\n一般的に「コンパイラ」には、次の3つの仕事があると言われます。\n\n1. ソースコードを解析し、問題点をチェックする\n1. ソースコードを別の言語に変換する\n1. 最適化する\n   - 実行速度が速くなるようにする\n   - 少ないメモリで動くようにする\n   - 少ない電力で済むようにする\n   - 実行ファイルのサイズを小さくする\n\nこのうち、TypeScriptコンパイラがするのは上の2つです。3つ目の最適化はしません。TypeScriptコンパイラは、基本的に型に関する部分を消すだけで、それ以外の部分はほぼそのままJavaScriptに変換します。\n\nたとえば、次のようなTypeScriptコードをコンパイルすると、\n\n```ts twoslash title=\"TypeScriptコード\"\nconst oneDay: number = 60 * 60 * 24;\n```\n\n次のJavaScriptコードが生成されます。型注釈の`number`が消されただけです。\n\n```js twoslash title=\"コンパイル後のJavaScriptコード\"\nconst oneDay = 60 * 60 * 24;\n```\n\nこの`60 * 60 * 24`の式は静的に計算できるものです。コンパイル時に計算して、次のようなJavaScriptを生成しておけば、実行時の余計な計算が不要になります。高速化に寄与します。\n\n```js twoslash title=\"予め計算したJavaScriptコード\"\nconst oneDay = 86400;\n```\n\n上のような最適化は技術的には可能なはずです。しかし、TypeScriptはこうした最適化は原則的に行いません。TypeScriptコンパイラがするのは基本的に型を外すだけです。\n\n### 両者のパフォーマンスは基本的に同等\n\nTypeScriptには次の特徴があることを見てきました。\n\n1. TypeScriptのランタイムはない。\n1. TypeScriptコンパイラは最適化しない。\n\nこの2つの特徴から、まったく同じロジックのコードをTypeScriptとJavaScriptで書いて比較したとき、その間には注意が必要なほどのパフォーマンスの違いはないと考えて差し支えありません[^2]。\n\n[^2]: 厳密に言うと、コンパイラオプション`target`を`es3`(古いJavaScript)に指定するなどで、「単に型を消すだけ」のコンパイルではなくなる場合もあるので常に同等が保証されているわけではありません。\n\n## JavaScriptの仕様バグは修正しない\n\nJavaScriptには元々バグだったものが仕様に変わった例があります。たとえば、値の型を調べる[typeof演算子]は、`null`を渡すと`\"object\"`が返ります。これはバグと考えられていましたが、後方互換性のため修正されることなく仕様になりました。\n\n[typeof演算子]: ../reference/values-types-variables/typeof-operator.md\n\n```js twoslash\ntypeof null;\n// @log: \"object\"\n```\n\nTypeScriptでも、こうした仕様バグは修正されていません。なぜかというと、TypeScriptはあくまでJavaScriptに型をプラスした言語というスタンスだからです。\n\n<PostILearned>\n\nTypeScriptが解決しないこと\n\n・JavaScriptの実行時パフォーマンス改善\n・JSの仕様バグの解決\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/overview/typescript-is-not-that"
    },
    {
      "title": "TypeScript誕生の背景",
      "content": "# TypeScript誕生の背景\n\nTypeScriptは、JavaScriptでも大規模なアプリケーションを開発しやすくすることを目的に開発されたプログラミング言語です。\n\n確かにJavaScriptは元々、大規模な開発を想定した設計ではありませんでした。それでも、JavaScript自体が進化して、大規模開発に対応してゆけば良かったはずです。しかし、実際はそううまくは行きませんでした。代わりに、大規模開発の一部はTypeScriptが引き受けることになったのです。\n\nなぜ、そうなったのでしょうか？その答えはJavaScriptの歴史にあります。TypeScriptが必要な発明で、そして、今もなお必要とされている理由が見えてきます。それでは、TypeScript誕生以前の歴史をひも解いていきましょう。\n\n## 1990年代\n\n### JavaScriptの誕生\n\nJavaScript誕生以前は、簡単なフォームのバリデーションをするのも、サーバーサイドのプログラムで行う必要がありました。Netscape Navigatorというブラウザを開発していたNetscape社は、クライアントサイドで動くプログラムの必要性に気づきました。そこで、1995年、Netscape社はNetscape Navigatorで動くスクリプト言語として、JavaScriptを実装しました。\n\n### 補助的な道具\n\n当時のJavaScriptは、HTMLの補助的な言語と考えられていて、その用途は簡単なアニメーションを実装したり、フォームのバリデーションに使う程度でした。ましてや、JavaScriptが大規模なアプリケーションを作るための言語とは見なされていませんでした。\n\n今となっては事実か不明ですが、当時JavaScriptにはセキュリティ上の問題があるという主張があり、ブラウザの設定でJavaScriptをオフにした上でネットサーフィンをするのが、“ITリテラシーが高い人”という印象すらありました。そのため、サイトによっては「当サイトを閲覧するにはJavaScriptをオンにしてください」といった注意書きもしばしば見かけました。\n\n1990年代のJavaScriptは、現代のように必須のものでは決してなく、あくまで補助的・随意的な立ち位置の言語だったのです。\n\n## 2000年代初頭\n\n### くすぶりはじめる大規模開発のニーズ\n\n他のプラットフォームに目を移すと、この時期にはすでにブラウザアプリケーションを実現する技術として、[Javaアプレット](https://ja.wikipedia.org/wiki/Java%E3%82%A2%E3%83%97%E3%83%AC%E3%83%83%E3%83%88)や[Adobe Flash](https://ja.wikipedia.org/wiki/Adobe_Flash)がありました。特にFlashはJavaアプレットよりも動作が軽く、ウェブサイト全体をFlashで実装するサイトが登場したり、この時代を省みて「[Flash黄金時代](https://dic.nicovideo.jp/a/flash%E9%BB%84%E9%87%91%E6%99%82%E4%BB%A3)」という言葉が後に生まれたりしました。一方のJavaScriptは依然として「補助的な道具」のイメージが支配的でした。\n\n一般的に対話型のユーザーインターフェースを備えたウェブサイト、今で言うウェブアプリケーションは、当時は「リッチインターネットアプリケーション」と呼ばれ、その多くはJavaアプレットやFlashが担っていましたが、プログラマの中にはJavaScriptを使ったウェブアプリケーションの開発を試みる人たちもいました。\n\n1997年に、Microsoftが企業向けウェブメーラーとして、Outlook Web Access 2000を市場投入しましたが、これはJavaScript製のウェブアプリケーションでした。現代の我々からすると意外かもしれませんが、この時代のJavaScriptはまだサーバーと通信することができませんでした。そこで、Microsoftはこのアプリのために、後のXMLHttpRequest(XHR)となるXMLHTTPという機能をInternet Explorerに追加したりもしました。XHRは革新的なアップデートでしたが、多くのプログラマから注目を得るのはもっと歴史が流れてからになります。\n\n2000年代初頭には、対話型のUIを備えた大規模なウェブアプリケーションがJavaScriptで開発できるようになることが望まれだしてきました。\n\n### 失われた10年\n\nこの頃には、JavaScriptはNetscape社が所有する言語から、ウェブ業界を上げて取り組む言語になっていました。そのため、JavaScriptの言語仕様はECMAScriptという名で策定され、各ベンダーがその仕様に基づいてそれぞれJavaScriptを実装するという流れになっていました。このECMAScriptを策定する会合がTC39であり、JavaScriptに関わるNetscape社やMicrosoft社を始めとしたベンダーが参加していました。\n\nTC39では、大規模開発にも耐えうるJavaScriptの必要性を鑑みて、新たな言語仕様である「ECMAScript 4」の策定についての議論を1999年頃から始めていました。このECMAScript 4(ES4)では、主に次のような野心的な言語仕様が議論されていました:\n\n- モジュール\n- Javaのようなクラス\n- 静的型付け\n- Nullable型\n- ユニオン型\n- ジェネリクス\n\nおや、どれもTypeScriptが持っているものではありませんか？そうなのです。「大規模なアプリケーション開発をしやすく」という点は、2つの言語が共有する問題意識であり、そのため、今から20年前のJavaScriptにおいても、TypeScriptと同じような解決策が検討されていたのです。\n\nここでひとつ疑問が出てきます。「ES4のアイディアがJavaScriptにもたらされていたら、そもそもTypeScriptなんて必要なかったのでは？」という疑問です。\n\n実は、残念ながら、ES4は正式な仕様として採用されることにはならなかったのです。ES4の仕様策定は、2003年に2年間の中断を経て、2005年に再開され、2007年に仕様書のドラフトが公開されました。ES4はこれまでのJavaScriptと互換性がありませんでした。保守的な立場を取るMicrosoft社と、革新的な変更を加えたいNetscape社で対立が起こり、政治的な背景からも折り合いをつけられなかったES4の草案は、2008年についに破棄されることとなります。\n\nこのような出来事があり、一度は大規模化を目指したJavaScriptでしたが、その目標を達成できないまま、約10年の年月が流れることとなります。\n\n## 2000年代中盤\n\n### Google Mapの衝撃\n\nJavaScriptの進化は足踏み状態、「本格的なアプリケーションを開発する言語ではない」というJavaScriptのイメージが依然として支配的な中、ウェブ業界に衝撃的な出来事が起こります。2005年のGoogle Mapの登場です。\n\n当時の地図サイトの多くは、地図を移動したり拡大縮小するとウェブページがリロードされるものばかりだったので、画面遷移なしにスムーズに地図を操作できるGoogle Mapは、当時の感覚で言えば、ネイティブアプリの操作感をウェブページで実現した画期的な発明でした。\n\nGoogle Mapの操作性を裏で支えたのが、AJAXです。AJAXは“**A**synchronous **Ja**vaScript and **X**ML”の略で、XMLHttpRequestオブジェクトによる非同期のHTTP通信を利用し、ページをリロードなしにサーバーからXMLでデータを取得し、HTMLの一部を書き換える技術です。今となってはAJAXは常識を通りすぎて、古めの技術のイメージがありますが、当時としては最先端の技術でした。\n\nGoogle Mapは多くのプログラマに衝撃を与えました。AJAXに脚光を浴びせただけでなく、JavaScriptでも立派なアプリケーションが作れることを証明して見せたのです。\n\n## 2000年代後半\n\n### 大規模化のニーズの強まり\n\nGoogle Mapの成功を目にした開発者は、ブラウザさえあれば他に何もインストールする必要がないアプリケーションをユーザーに提供できるウェブアプリケーションにより一層の魅力を感じるようになり、JavaScriptによる大規模開発のニーズも日に日に増してきました。\n\n2005年には、JavaScriptアプリケーションフレームワークの先駆けであるPrototype.jsがリリースされました。翌年にはjQueryがリリースされ、その後しばらくして、2009年にAngularJS、2010年にBackbone.jsが発表され、フロントエンドWebアプリケーション開発のツールが続々と発明される流れになっていきます。\n\n### 進化なきJS、一世風靡のAltJS\n\nJavaScriptの開発スタイルは一変し、大規模化が進む中、JavaScript自体には動きが見られません。期待が寄せられたES4も、2008年にご破算となってしまいました。\n\n開発者たちは進化なきJavaScriptに甘んじていたわけではありませんでした。「JavaScript本体が良くならないなら、JavaScriptにコンパイルできる言語を作ればいいのではないだろうか？」開発者の中にはこう考える人々が現れました。\n\nこうした発想のもと、JavaScriptアプリケーションの開発言語として一世を風靡するのが、2009年に発表されたCoffeeScriptです。CoffeeScriptはRubyのような簡潔な文法でコーディングできることが魅力の言語で、サーバーサイドフレームワークのRuby on Railsにもフロントエンド開発用言語として正式採用されました。CoffeeScriptにはclass構文があり、クラス指向のオブジェクト指向プログラミングに慣れ親しんだプログラマには好評でした。\n\nコーディングは別の言語で行い、それをJavaScriptにコンパイルするという奇抜に思えた手法は成功を収め、このアプローチを採用する言語が数多く開発され、それらの言語は総称してAltJSと呼ばれるようになりました。言語から言語にコンパイルすることを「トランスパイル」と言いますが、この言葉が定着したのもこの頃です。AltJSが一般化すると、JavaScriptは「現代のアセンブラ」と揶揄されることもありました。\n\n### ECMAScript 2015始動\n\n2008年になると、ECMAScriptに新たな動きが生まれます。JavaScriptを改善しようという議論が再開したのです。ES4は革新的すぎたため、保守派から大きな反対にあいました。そこで、ES4ほど革新的ではなく、既存のJSとの互換性を保ちながらES4の成果を取り込むための折衷案として、Harmonyという新しい言語仕様が検討されることになりました。Harmonyにはclass構文や、module構文、import/exportなど大規模開発を想定した言語仕様が提案されました。そのうちのいくつかは、のちのECMAScript 2015に採用されることになります。\n\nこのようにして、JavaScriptの言語仕様を話し合うTC39が生産的な会合になってきたこともあり、JavaScriptの将来に期待も集まるようになってきました。\n\n## 2010年代\n\n### TypeScriptの誕生\n\nECMAScript 2015の策定に向け、TC39で大規模開発の議論が活発になる中、2012年に発表されたのがTypeScriptです。\n\nTypeScriptは誕生当初より、ますます困難になるJavaScriptの大規模開発に焦点を当てていました。特に強調された特徴が、JavaScriptのスーパーセット、モジュール性、そして型です。\n\n当時、人気を博していたCoffeeScriptがJavaScriptの文法とはドラスティックに異なる独自路線を打ち出したのに対し、TypeScriptはJavaScriptの文法を拡張するに留める「JavaScriptのスーパーセット言語」としての戦略を採用しました。そのため、TypeScriptを導入したとしても、既存のJavaScript資産はそのまま活用でき、チームの学習にも突発的なコストがかからず、徐々にTypeScriptの恩恵を増やしていけるようになっていたので、大規模開発でもすぐに導入できるようになっていました。\n\nモジュール性は大規模開発ではとても重要になります。コードを適切な粒度に分割し整理できたり、実装の詳細をカプセル化できたり、変数名や関数名が衝突しないような言語仕様がなければ、大規模開発はかなり難しいものになります。\n\n当時のJavaScriptには、モジュールシステムや名前空間といったものが無かったため、大規模開発を難しいものにしていました。TypeScriptは、この問題を解決するためにES2015の提案に上がっていたクラスやモジュールの構文を先取りし、モジュール性を実現しました。\n\n型はTypeScriptの最大の特徴でした。型の恩恵として、コーディング中にコードジャンプやコード補完ができ、型情報がドキュメントにもなり、プログラムを動かす前にソースコードのチェックを行えるようになりました。このように型は大規模開発の生産性を大きく向上させました。\n\n### 薄れないTypeScriptの強み\n\nTypeScriptが発表された後、TypeScriptが手本としたECMAScript 2015は正式に発表され、その後、ECMAScriptは毎年アップデートされるようになりました。一時期停滞したJavaScriptも、大規模開発のハードルを下げるべく年々進化を遂げてきています。\n\nそうした中で、TypeScriptが誕生当初に掲げていた3大特徴のうち、モジュール性はJavaScriptの仕様にも盛り込まれ、その部分ではTypeScriptは優位性を失いました。しかし、TypeScriptの目玉である「型」は、今日でもJavaScriptの仕様には盛り込まれていません。\n\n大規模開発をするにあたって、型は非常に重要な言語仕様であり、JavaScriptが進化を続ける中においても、TypeScriptの「型」というのは今でも確固たる強みであることは間違いないでしょう。\n\n## まとめ\n\n1995年に生まれたJavaScriptは当初、大規模な開発に用いられることが想定されていませんでした。10年もすると、大規模開発のニーズが顕在化しはじめ、JavaScriptは対応に迫られました。しかし、ベンダー同士の合意をとりつけられず、JavaScriptの進化は停滞します。\n\nJavaScriptが硬直状態だった間も、ウェブアプリケーションは大規模化が進み、開発の難易度が日に日に増してきました。それに対して、さまざまな解決策がコミュニティからなされるようになります。\n\nその流れの中で発明されたのがTypeScriptです。TypeScriptは大規模開発の困難さに立ち向かう言語として、JavaScriptのスーパーセット・モジュール性・型の3つの特徴を携えて2012年に発表されました。\n\nTypeScriptの発表後、JavaScriptも再び進歩を始め、6年ぶりのメジャーアップデートとしてECMAScript 2015を発表し、そこから毎年新仕様を発表しつづけています。それでも、TypeScriptの最大の特徴である「型」は、依然としてJavaScriptにはありません。今日においてもTypeScriptが大規模開発で好まれるのは、JavaScriptでは得られない開発体験があるためです。\n\n## 参考資料\n\n- [Chapter 4. How JavaScript Was Created](http://speakingjs.com/es5/ch04.html)\n- [Microsoft augments JavaScript for large-scale development | InfoWorld](https://www.infoworld.com/article/2614863/microsoft-augments-javascript-for-large-scale-development.html)\n- [The Real Story Behind ECMAScript](https://auth0.com/blog/the-real-story-behind-es4/)\n- [JavaScript 2.0](https://web.archive.org/web/20000816194528/http://mozilla.org/js/language/js20-1999-02-18/index.html)\n- [JavaScript 2.0 Motivation](https://web.archive.org/web/20000823225602/http://mozilla.org/js/language/js20-1999-02-18/motivation.html)\n- [ActionScript - Wikipedia](https://en.wikipedia.org/wiki/ActionScript)\n- [JavaScript - Wikipedia](https://ja.wikipedia.org/wiki/JavaScript)\n- [ECMAScript - Wikipedia](https://en.wikipedia.org/wiki/ECMAScript)\n- [A Brief History of JavaScript](https://auth0.com/blog/a-brief-history-of-javascript/)\n- [The ECMAScript 6 schedule change](https://2ality.com/2014/06/es6-schedule.html#fn2)\n- [見えてきた「ECMAScript 6」。JavaScriptの生みの親が書く「Harmony of Dreams Come True」 － Publickey](https://www.publickey1.jp/blog/12/javascriptecmascript_6harmony_of_dreams_come_true.html)\n- [JavaScript: The First 20 Years | Zenod](https://zenodo.org/record/3707008#.XrVIhBMzZTY)\n- [Anders Hejlsberg: Introducing TypeScript | Channel 9](https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript)\n",
      "url": "https://typescriptbook.jp/overview/before-typescript"
    },
    {
      "title": "TypeScriptの射程",
      "content": "---\nimage: /img/range-of-typescript.png\n---\n\n# TypeScriptの射程\n\nTypeScriptを覚えるとさまざまなものを作れるようになります。TypeScriptはJavaScriptにコンパイルして使う言語です。そのため、JavaScriptで作れるものは何でも作れます。ここでは、TypeScriptを学んだらどのようなソフトウェアを作れるのか、「TypeScriptの射程」について説明します。\n\n## フロントエンド\n\nTypeScriptがもっとも人気な分野は、フロントエンドアプリケーション開発です。ブラウザで動くアプリです。ブラウザではJavaScriptが圧倒的な地位を確立しています。TypeScriptはJavaScriptのエコシステムに乗っかっているため、フロントエンドアプリケーション開発で大きな力を発揮します。\n\n## バックエンド\n\nバックエンドアプリケーションもTypeScriptを使って開発ができます。技術的にはNode.jsというサーバーサイドJavaScriptのエコシステムに乗ることができます。バックエンド言語はJava、Ruby、PHPなどの多数の競合があるものの、TypeScriptもサーバーサイドプログラミングのひとつの選択肢になります。\n\n## フロントエンドとバックエンドの両方でTypeScriptを採用するメリット\n\nフロントエンドとバックエンドの両方でTypeScriptを採用するとメリットがあります。プロジェクトで扱う言語が1つでよいという点です。言語が1つであると、次のような利点が生まれます。\n\n### モジュールを共有できる\n\n両方で言語が異なる場合、同じロジックであっても各言語で実装しなければなりません。テストも倍になります。一方、両方でTypeScriptを採用すると、一方で作ったTypeScriptのモジュールをもう一方で再利用できます。\n\n### プロジェクト内でのノウハウが共有できる\n\n言語の壁はノウハウ共有を難しくします。フロントエンドとバックエンドで言語が異なる場合、ノウハウ共有はフロントエンドとバックエンドの垣根を超えにくいものになります。たとえば、バックエンドで便利な日付操作ライブラリを見つけていたとしても、フロントエンドではそれが使えないので、そのノウハウはバックエンドだけで終わってしまいます。\n\nもしも、両方でTypeScriptを使っているなら、フロントエンドのノウハウをバックエンドに還元したり、その逆が成立しやすくなります。\n\n### 学習のコストパフォーマンスが最大化する\n\n新しい言語を覚えることは思いの外、時間のかかるものです。チュートリアルやリファレンスで座学するだけなら、短期間で学習できます。しかし、その言語のエコシステムや実務上のベストプラクティス、言語の細かい癖や陥りがちな罠などまで、しっかり理解した実践レベルに到達しようとなると、多くの学習時間を要します。\n\nフロントエンドとバックエンドの両方を担当する場合にそれぞれが別言語であれば、安心して実務的なコードを書けるようになるまで、個人であれ、組織であれ、言語習得にかなりの時間を投資することになるでしょう。\n\n逆にどこでもTypeScriptが使えるようになっていれば、言語やエコシステムの学習オーバーヘッドが最小限で済みます。\n\n## デスクトップアプリケーション\n\nWindowsやmacOS、Linux向けにデスクトップアプリケーションを作る場合もTypeScriptが使えます。デスクトップアプリケーションをJavaScript、HTML、CSSの技術スタックで開発できる[Electron](https://www.electronjs.org/)を用います。Electron + TypeScript製の著名なアプリとしては、SlackやMicrosoft社のVS Codeがあります。\n\n## CLIアプリケーション\n\nコマンドラインツールの開発もTypeScriptで行えます。サーバーサイドJavaScript実行環境のNode.jsとTypeScriptを組み合わせて開発します。CLIアプリケーションフレームワークには、Heroku製の[oclif](https://github.com/oclif/oclif)などがあります。Google製の[zx](https://github.com/google/zx)を用いると、シェルスクリプトの代わりにTypeScriptを使うのもしやすくなります。\n\n## サーバーレス (FaaS)\n\nサーバーレスとは、サーバーの構築や保守なしに、サーバーサイドのプログラムを実行できる仕組みです。通常、バックエンドアプリケーションを動かそうとすると、Linuxなどのサーバーを立てたり、メンテナンスする必要が出てきます。サーバーレスでは、AWSなどのクラウドベンダーがJavaScriptなどのマネージド実行環境を提供することで、アプリケーション開発者はサーバーを保守する必要がなくなります。開発者はJavaScriptの関数を書いたファイルをアップロードするだけで、バックエンドなどのウェブサービスを公開できます。このような関数を実行するクラウドサービスのことをFaaS(Function as a Service)と言います。\n\nJavaScriptをサポートしているFaaSは多数あります。もっとも有名なのがAWSの[Lambda](https://aws.amazon.com/lambda/)です。この他に、[Google Cloud Functions](https://cloud.google.com/functions)やMicrosoftの[Azure Functions](https://azure.microsoft.com/ja-jp/products/functions/)、Next.jsと親和性の高いVercelの[Serverless Functions](https://vercel.com/docs/functions/introduction)、静的サイトホスティングで有名なNetlifyの[Netlify Functions](https://www.netlify.com/products/functions/)、世界90カ国194の都市にエッジを持つCDN Cloudflareの[Cloudflare Workers](https://workers.cloudflare.com/)などがあります。これらのサービスを用いると、TypeScriptでサーバーレスなウェブアプリケーションを提供できます。\n\n## インフラ構成管理 (IaC)\n\nインフラが物理的なものから仮想的なものになり、自社サーバーからクラウド化が進んだ結果、サーバーをいくつどのように配置するか、ネットワークはどう繋ぎこむかといったインフラ構成管理も、ソフトウェアで自動化されることが増えてきました。インフラ構成をコードで定義し、プログラマブルにすることをIaC(Infrastructure as Code)と呼びます。\n\nTypeScriptでもIaCを行えます。AWSのインフラ構成を自動化するツールに[AWS CDK(Cloud Development Kit)](https://aws.amazon.com/cdk/#:~:text=The%20AWS%20Cloud%20Development%20Kit,resources%20using%20familiar%20programming%20languages.&text=AWS%20CDK%20uses%20the%20familiarity,languages%20for%20modeling%20your%20applications.)があります。これはTypeScriptをサポートしています。\n\nAWSやGoogle Platformなど複数のクラウドベンダーに対応したインフラ構成ツールとして、[Pulumi](https://www.pulumi.com/)もあります。PulumiはTypeScriptで各ベンダーのインフラ構成を記述できます。インフラ構成ツールでもっとも有名なのは[Terraform](https://www.terraform.io/)ですが、TerraformはHCLと呼ばれる独自言語で記述するのに対し、PulumiはTypeScriptなので、TypeScriptプログラマーにとって手が届きやすいツールです。\n\n## Google Apps Script\n\nGoogleはSpreadsheetやDocsなどのオフィススイートを提供していて、多くの企業で導入されています。Google Spreadsheetなどには、JavaScriptで機能を拡張する仕組みが備わっています。それをGoogle Apps Scriptと呼びます。Google Apps Scriptを使うと、スプレッドシートに独自の関数を作ったり、操作を自動化したりでき、業務の効率化に役立ちます。TypeScriptで書いたコードはJavaScriptにコンパイルすれば、Google Apps Scriptで利用できます。\n\n## ブラウザ拡張\n\nGoogle ChromeやFirefoxなどのブラウザには、ブラウザの機能を拡張する仕組みがあります。ブラウザ拡張はJavaScriptで書くことができます。TypeScriptで書いたコードもJavaScriptにコンパイルすることで、ブラウザ拡張として動かせます。\n\n## 機械学習\n\n機械学習やニューラルネットワーク、ディープラーニングなどの分野はPythonが一強であることは異論がないでしょう。しかし、JavaScriptでも機械学習などのツールが多数作られてきており、TypeScriptプログラマーも手が届きやすくなってきています。[TensorFlow.js](https://www.tensorflow.org/js/)はGoogleが開発した機械学習ライブラリです。[Brain.js](https://brain.js.org/)はニューラルネットワークのライブラリです。\n\n## 組み込み系\n\nMicrosoftはTypeScriptのサブセット言語として、リソースの少ない組み込みデバイスを対象としたStatic TypeScript(STS)を開発し、実際にそれで組み込み系のソフトウェアを作る[研究成果を発表](https://www.infoq.com/jp/news/2019/11/static-typescript-msft-paper/)しました。STSはTypeScriptと同じではありませんし、まだ研究段階ですが、こうした動きが活発になってくれば、組み込み系プログラミングもTypeScriptプログラマーの射程圏内に入ってくることでしょう。\n\n## WebAssembly\n\nWebAssembly(WASM)はブラウザで動くアセンブリー言語です。WASMはJavaScriptよりも高速な処理が必要とされるところで用いられます。WASMのプログラムはC言語やC++、Rustといったシステム言語で開発されることが多いですが、TypeScriptでWASMを開発できるようにする試みも出てきています。その筆頭が[AssemblyScript](https://www.assemblyscript.org/)です。AssemblyScriptを使うと、TypeScript風のコードをWASMに変換できます。\n",
      "url": "https://typescriptbook.jp/overview/range-of-typescript"
    },
    {
      "title": "静的型付け",
      "content": "# 静的型付け\n\nプログラミング言語は大きく2つに分類されます。静的型付け言語と動的型付け言語です。静的型付け言語の中には、C言語やJavaがあり、今学んでいるTypeScriptもその仲間です。一方の動的型付け言語には、RubyやPython、PHP、そしてJavaScriptがあります。\n\nもし、読者のあなたが動的型付け言語をずっとやってきて、TypeScriptが初めての静的型付け言語になるなら、きっとこのような疑問を持つはずです。\n\n- 「動的型付け言語」と「静的型付け言語」にはどんな違いがあるか？\n- 「静的型付け言語」にはどんな利点があるのか？\n\nここでは、そんな静的型付け言語に初めて挑戦する読者の疑問を解消していきます。\n\n## 動的型付け言語は「実行時」に型が定まる\n\n静的型付け言語とは何かを考える前に、慣れ親しんだ動的型付け言語とは何だったのか振り返ってみましょう。\n\nたとえばPythonで、与えられた引数から1を引き算して返す関数を例に考えてみます。\n\n```python\ndef minus(x):\n  return x - 1\n\nprint(minus(2))\n```\n\nこの`minus()`関数には変数`x`があり、ここに整数型の`2`が代入されると問題なく計算され、整数型の`1`が返ります。当たり前ですね。\n\nでは、今度は`minus()`関数に`string`型の`\"two\"`を渡すとどうなるでしょうか。\n\n```python\ndef minus(x):\n  return x - 1\n\nprint(minus(\"two\"))\n```\n\nこのコードを実行してみると、「TypeError: unsupported operand type(s) for -: 'str' and 'int'」というエラーが発生します。これは「文字列から整数はマイナスできないよ」という意味です。\n\n文字列から数値を引き算するというのは、人間からすると明らかに変です。実行するまでもなく型のおかしさに気づくと思います。\n\nしかし、動的型付け言語ではプログラムを実行するまで型の問題は見過ごされます。プログラムを実行していくと、変数の型が定まっていきます。その過程で問題が発覚して、エラーになるのです。\n\nここからわかるように、**動的型付け言語の最大の特徴は、変数の型はプログラムを実行するまで定まらない**という点です。この特徴はプログラミングの自由度を高めるという利点でもあります。\n\n## 静的型付け言語は「コンパイル時」に型が定まる\n\nでは、静的型付け言語にはどのような特徴があるのでしょうか？先ほどPythonで示した`minus()`関数を静的型付け言語であるTypeScriptで書いてみましょう。\n\n```ts twoslash\nfunction minus(x: number) {\n  return x - 1;\n}\n```\n\n注目すべきは、変数`x`の隣に`number`と書かれている点です。これは、型注釈と呼ばれるもので、変数`x`が`number`型であることを表しています。\n\nこの変数`x`に`string`型の`\"two\"`を代入してコンパイルしてみるとどうなるでしょうか？\n\n```ts\nminus(\"two\");\n```\n\nコンパイル結果はエラーになり、「Argument of type 'string' is not assignable to parameter of type 'number'.」という警告が表示されます。この警告の内容は「`number`型のパラメータに`string`型は代入できません」というものです。\n\nPythonの例でも似たようなエラーが確認できましたが、それは実行時に発生していました。一方、このTypeScriptの例のエラーは、コンパイル時に発生しています。ここが動的型付け言語と静的型付け言語の大きな特徴の違いです。コンパイル時というのは、プログラムを実行するよりも前の工程です。つまり、**型が実行時よりも前のコンパイル時で定まるというのが、静的型付け言語の特徴なのです**。そのおかげで、明らかにおかしな代入を早期発見できるというのが、TypeScriptを始めとした静的型付け言語の大きな利点になるわけです。\n\n## 型注釈をコストと考えるか、投資と考えるか\n\n動的型付け言語では書く必要がなかった型注釈を、TypeScriptでは基本的には変数ごとに書いていくことになります。そのため、動的型の言語からTypeScriptに入ってきた人の中には、コードの記述量が増えて面倒に感じる人がいるかもしれません。型注釈の記述は「コスト」と考えることもできます。(それを省力化する「型推論」という仕組みもありますが、ここではその説明は割愛します。)\n\nそもそも型注釈の目的は何なんでしょうか？それは、プログラマがコンパイラに「この変数の型は何であるか」を教えることです。型注釈があると、たとえば、コンパイラが`minus()`関数を処理するときに、「`x`変数は`number`型でなければならないのか。じゃあ、`string`型を代入するようなコードは間違いだな。エラーにしてプログラマに教えてあげよう」といったような働きをしてくれるのです。\n\nコンパイラは、細かく問題を指摘してくるので、鬱陶しく思うかもしれません。ここは見方を変える必要があります。コンパイラは「あなた専属のコードレビュア」なのだと。バグに気づかずリリースしてしまい、大問題となって発覚するといった経験はないでしょうか？コンパイラはそういったことに至るずっと前の段階で、問題点を教えてくれる頼りになる存在です。\n\nコンパイラも決して全知全能ではありません。ちゃんと型を教えてあげなければ、いいコンパイラに成長しません。逆に型注釈をちゃんとしていけば、多くの問題に気がつく賢いコンパイラに育っていきます。この観点に立つと、型注釈はコストではなく、コンパイラを正しく育て、バグを未然に防ぐための「投資」と考えることができるのではないでしょうか。\n\n## まとめ\n\n- 動的型付け言語: 実行時に変数の型が定まる言語。型にまつわる問題はプログラムを実行してみないと発覚しない。\n- 静的型付け言語: コンパイル時に変数の型が定まる言語。型にまつわる問題はプログラムを実行しなくても発見できる。\n- 型注釈は、あなた専属のコードレビュアであるコンパイラを育てるための投資。\n",
      "url": "https://typescriptbook.jp/overview/static-type"
    },
    {
      "title": "JavaScriptはTypeScriptの一部",
      "content": "# JavaScriptはTypeScriptの一部\n\nTypeScriptの文法はJavaScriptの文法を拡張したものです。TypeScriptで拡張された文法は、主に型に関する部分です。それ以外のほとんどの文法はJavaScriptに由来するものです。そのため、素のJavaScriptもTypeScriptとして扱うことができます。たとえば、次のコードは100%JavaScriptのものですが、これをTypeScriptコンパイラーは解析でき、静的な検査が行なえます。\n\n```js twoslash\nconst hello = \"Hello\";\nconst world = \"World\";\nconsole.log(hello + \" \" + world);\n// @log: \"Hello World\"\n```\n\nTypeScriptから見ると、JavaScriptはTypeScriptの一部と言えます。そのため、TypeScriptを十分に理解するには、JavaScriptの理解が欠かせません。まだJavaScriptをよく分かっていない場合は、TypeScriptの学習と平行してJavaScriptも学ぶ必要があります。本書はTypeScript入門者向けですが、TypeScriptの理解に欠かせないJavaScriptの文法や仕様についても同時に学べるようになっています。\n",
      "url": "https://typescriptbook.jp/overview/javascript-is-typescript"
    },
    {
      "title": "TypeScriptとエコシステム",
      "content": "---\nimage: /overview/ecosystem/typescript-ecosystem-map.png\n---\n\n# TypeScriptとエコシステム\n\n[![](/overview/ecosystem/typescript-ecosystem-map.svg)](/overview/ecosystem/typescript-ecosystem-map.svg)\n\nTypeScriptを学習するとき、TypeScriptそのものを理解することは不可欠です。しかし、それだけでは実務上不十分なことが多いです。実際の現場では、TypeScriptに数多くの技術スタックを組み合わせて、開発を行うからです。そのため、TypeScriptを知ると同時に、TypeScriptをとりまくエコシステムを知ることが重要になってきます。\n\n前項の[TypeScript誕生の背景](./before-typescript.md)が歴史学だとすると、本項は地理学です。フロントエンドの技術スタックを中心に、TypeScriptとの関わりや、各技術の役割について俯瞰的に学びます。\n\n## 言語\n\nJavaScriptの仕様を定義したのがECMAScriptです。ECMAScriptはJavaScriptのコア部分の仕様を扱います。ブラウザ関連のJavaScript仕様を定めるのがWHATWGです。また、XMLの構文をJavaScriptに書けるJSXという言語もあります。TypeScriptは、JavaScriptを拡張した言語です。JSXも取り込んでいます。したがって、TypeScriptの仕様には、ECMAScript由来のもの、WHATWG由来のもの、JSX、そして、TypeScript固有仕様が含まれることになります。\n\n[ECMASCript](./ecmascript.md)\n\n## ライブラリ\n\n### UIライブラリ\n\nHTML、CSS、JavaScriptを使えば、UIを持ったウェブアプリケーションを作ることができます。しかし、複雑なUIは素のJavaScriptだけで作るのは工数が大きくなりがちです。JavaScriptには、UIを作りやすくするライブラリが多くあります。その中でも特に人気なのが、React、Vue、Angular、Svelteです。UIライブラリを使うと、素のJavaScriptで書くよりも、少ないコード量で実装できたり、保守性の高いコードで書けたりとメリットがあります。\n\n[React](../tutorials/react-like-button-tutorial.md)\n\n### フロントエンドフレームワーク\n\nウェブアプリケーション開発には多種多様な要件があるものの、どんなアプリケーションでも共通した要件、ファイル構成などある程度型にはめられるパターンがあります。フロントエンドフレームワークは、ウェブアプリケーション開発で、よくありがちな機能を車輪の再発明をすることなく開発に臨めるよう、ウェブアプリケーションの土台となるものです。\n\nフロントエンドフレームワークには、よく使われるものとして、Next.js、Nuxt、Gatsbyなどがあります。これらを使うと、シングルページアプリケーション(SPA)や静的サイト生成、サーバーサイドレンダリングなど、フロントエンドで必要とされる機能基盤を自分で実装しなくてもよくなります。\n\n[Next.js](../tutorials/nextjs.md)\n\n### 型定義ファイル\n\nTypeScriptは型をチェックすることで、プログラムの不具合がチェックできます。しかし、JavaScriptだけで作られたライブラリには、TypeScriptコンパイラーがチェックの材料にする型情報がついていません。\n\nJavaScript純正のライブラリに型情報を持たせる機能として、TypeScriptには型定義ファイルというものがあります。型定義ファイルは、ライブラリの型情報を記したファイルです。\n\nJavaScript純正のライブラリを使いたいときは、ライブラリとは別途、型定義ファイルを入手すると、JavaScriptのライブラリであっても、TypeScriptで型チェックができるようになります。型定義ファイルの多くは、DefinitelyTypedというプロジェクトが公開しています。\n\n## 実行環境\n\nJavaScriptの実行環境は大きく分けて、ブラウザとサーバーの2種類があります。ブラウザは画面描画を行うコンポーネントとして、レンダリングエンジンを持ちます。レンダリングエンジンには、BlinkやWebkit、Geckoなどがあります。\n\nさらに、レンダリングエンジンの内部にJavaScriptエンジンがあります。JavaScriptコードはこのエンジンで評価され実行されます。JavaScriptエンジンには、V8、SpiderMonkey、JavaScriptCoreがあります。\n\nサーバーの実行環境にはNodeやDenoがあります。Nodeは、もっとも有名なJavaScript実行環境です。Denoは、TypeScriptがそのまま実行できることで近年注目を集める実行環境です。サーバー実行環境にはブラウザと異なりレンダリングエンジンがありませんが、JavaScriptエンジンはブラウザと共通のものを持ちます。\n\n[ECMASCript](./ecmascript.md)\n\n## 開発ツール\n\n### パッケージマネージャー\n\nパッケージマネージャーは、JavaScriptのライブラリを管理するツールです。パッケージマネージャーを使うことで、JavaScriptのライブラリをインストールしたり、アップデートしたりできます。また、ライブラリ同士の依存関係の管理も行ってくれます。パッケージマネージャのうち、npmとYarnが広く使われています。npmは、Node package managerの略ですが、サーバーサイドJavaScriptのライブラリだけでなく、フロントエンド向けのライブラリも数多く取り扱います。\n\nnpmやYarnでインストールされるライブラリは、npmjs.comにホスティングされています。npmjs.comは中央集権型のレジストリです。\n\n### モジュールバンドラー\n\nモジュールバンドラー(module bundler)は、複数のJavaScriptファイルをひとつのファイルに結合するためのツールです。複数のJavaScriptファイルに依存関係がある場合、それをそのままブラウザに読み込ませるには、慎重に読み込み順を指定しないと、アプリケーションが壊れてしまいます。このようなトラブルは、モジュールバンドラーを使うと回避できます。\n\nまた、フロントエンドでは、JavaScriptアプリケーションをブラウザにダウンロードさせる必要があります。数多くのファイルからなるアプリケーションは、モジュールバンドラーで1ファイルのほうが効率的にダウンロードできます。\n\nモジュールバンドラーを使うと、CommonJSを採用しているサーバーサイド向けに作られたライブラリをブラウザで使えるといったメリットもあります。\n\n### タスクランナー\n\nタスクランナー(task runner)は、ビルドなどの開発上の手続きを自動化するツールです。複数のビルドタスクを束ねたり、実行の順番を調整することができます。タスクランナーを使うと、複雑なビルドワークフローをコマンドひとつで実行できるようになります。\n\n### トランスパイラー\n\nトランスパイラー(transpiler)は、あるプログラミング言語でかかれたコードを、別の言語に変換するツールです。トランスパイラーはコンパイラーの一種です。JavaScriptでは、新しいバージョンのJavaScriptから古いバージョンのJavaScriptに変換するトランスパイラーがあります。Babelやswcがこれにあたります。TypeScriptのtsc(TypeScript compiler)もトランスパイラーです。tscはTypeScriptからJavaScriptへの変換を行います。\n\n### コードフォーマッター\n\nコードフォーマッター(code formatter)は、ソースコードのインデントや字下げスタイルを自動で整えてくれるツールです。コードフォーマッターを使うと、誰が書いても同じ見た目のコードに整形できます。よく使われるのが、Prettier(プリティア)です。\n\n[Prettier](./../tutorials/prettier.md)\n\n### リンター\n\nリンター(linter)は、コードがコーディング規約に準拠しているかをチェックするツールです。コーディング規約に沿ったコードを書くことは、保守性を高めることに繋がります。しかし、コードがコーディング規約に準拠しているかを手動でチェックするのは、大変な作業です。リンターを使うと、チェックを自動的に行えるので、開発者の生産性の向上が期待できます。リンターでよく使われるツールはESLint(イーエスリント)です。\n\n[ESLint](./../tutorials/eslint.md)\n\n### Gitフック\n\nGitフックは、Gitにコミットするタイミングや、プッシュするタイミングに、何らかのプログラムを実行する機能です。JavaScriptの開発現場では、Gitコミット時にTypeScriptのコンパイルで型チェックをしたり、リンターのチェックを起動したり、コードフォーマッターでコード整形をかけることがよくあります。Gitフックを手軽に利用できるようにするツールとして、huskyやlint-stagedがあります。\n\n[husky](../tutorials/husky.md)\n",
      "url": "https://typescriptbook.jp/overview/ecosystem"
    },
    {
      "title": "なぜTypeScriptを使うべきか",
      "content": "---\nimage: /img/why-you-should-use-typescript.png\n---\n\n# なぜTypeScriptを使うべきか\n\nウェブアプリケーションのフロントエンドを開発するのに、最低限の必要となる言語はHTMLやCSSを除けばJavaScriptだけです。JavaScriptさえ使えれば、かなり自由にフロントエンドを実装できます。それなのに、なぜJavaScriptではなくTypeScriptを使ったほうがいいのでしょうか？ここでは、TypeScriptを使うべき理由を大きく分けて4つ見ていきます。\n\n## TypeScriptは大規模開発に最適な言語\n\nTypeScriptが発明されるに至った歴史的背景を「TypeScript誕生の背景」で見ましたが、JavaScriptではまかないきれなくなった大規模アプリケーション開発を克服するために生まれたのがTypeScriptです。\n\n[TypeScript誕生の背景](before-typescript.md)\n\nそのため、大規模なアプリケーション開発の現場が求める三大特徴をTypeScriptは備えています。\n\n1. 型による静的チェック\n2. モジュール性\n3. 緩やかな学習コスト\n\nこのうち特に型による静的チェックは、TypeScriptに「Type」という名が冠されているように、TypeScriptの目玉機能です。型チェックはプログラムを実行せずとも、プログラムの欠陥に気づくことができます。バグは発見が遅れるほど修正コストが高くつきますが、TypeScriptではコーディング中に頻繁にチェックすることができ、バグ早期発見によって修正コストも抑えることができます。Airbnbによると、[TypeScriptを使っていたらAirbnbの38%ものバグを未然に防げたと見る分析](https://www.reddit.com/r/typescript/comments/aofcik/38_of_bugs_at_airbnb_could_have_been_prevented_by/)を発表しています。\n\nまた、型があることで、プログラムの可読性や理解しやすさが上がったり、エディターの補完機能を活かすことができ、コーディングの効率も良くなります。\n\nTypeScriptは公式に「大規模なアプリケーション」が具体的にどれほどの規模なのかは明言していませんが、筆者の感覚からいうと、数百行規模のコードでもTypeScriptの恩恵は十分に享受できると考えています。\n\nただし、静的チェックは品質保証の銀の弾丸ではないことは、公平に申しておかなければなりません。静的チェックは、誰が読んでも絶対におかしいと客観的に判断できるような欠陥をあぶり出すものです。たとえば、未定義の変数へのアクセスや、正しくないデータ型の取り扱いなどです。仕様バグや、実行時エラーを検出することはできません。品質保証においては、テストなど他の手法も組み合わせる必要があります。それでも、静的チェックがあるおかげで、TypeScriptで検出できる類のバグはテスト工程から省略できるのは確かです。\n\n## JavaScriptの知識があれば使い始められる\n\nTypeScriptはJavaScriptのスーパーセットです。スーパーセットというのは、JavaScriptの仕様はそのままに、それにTypeScriptならではの新しい機能や利点を追加したものという意味です。つまり、JavaScriptのコードはそのままTypeScriptのコンパイラが理解できるのです。\n\nこの特徴により、開発陣が得られるメリットのひとつが、JavaScriptの知識があればTypeScriptを使い始められるということです。これは新しい言語の学習コストをとても緩やかなものにしてくれます。新言語の導入となると、難しい言語だと学習に数ヶ月要し、そこからやっと書きはじめるということもありえますが、TypeScriptの場合はひとまずJavaScriptとして書き始め、少しずつTypeScriptを学んでいき、徐々にTypeScriptの恩恵を最大化するようにコードを手直ししていくといったアプローチが可能です。TypeScriptにはJavaScriptにはない数多くの機能がありますが、どれも選択的に導入していくことができます。\n\nJavaScriptのスーパーセットであるということは、裏を返せばJavaScriptを知らないといけないということでもあります。なので、TypeScriptをJavaやC#のようなものだと期待していたり、JavaScriptを学ぶつもりがまったくないとすると、TypeScriptでの開発はフラストレーションになるかもしれません。JavaScriptでいわゆる「罠」と言われるような注意すべき言語仕様は、TypeScriptでもそのままというものもあります。JavaScriptにまったく触れたくないならTypeScriptは適していませんが、JavaScriptを使うつもりでいたのならTypeScriptは有力な選択肢になるでしょう。\n\n## 古いJS環境を対象とした開発シーンでも最新の構文が使える\n\nプロジェクトの要件によっては、ES5といった古いJavaScriptしかサポートされていないブラウザでも動作するように実装しないといけない場合があります。TypeScriptは、そのような古いJS環境をターゲットとしたプロジェクトにも導入可能です。\n\nTypeScriptはコンパイル時にどのバージョンのJavaScriptにコンパイルするかを選べます。TypeScriptが対応しているもっとも古いJavaScriptのバージョンはES3で、これはモダンブラウザ以前の古いブラウザにも対応できます。次に古いES5へのコンパイルでは、Internet Explore 9などの2012年当時のモダンブラウザにも対応できます。\n\nTypeScriptの魅力は古いバージョンのJavaScriptにコンパイルできるだけではありません。JavaScriptの仕様であるECMAScriptは毎年1回のペースでメジャーバージョンアップされ、その度に便利な新機能が導入されてきています。TypeScriptはECMAScriptへの準拠を原則としており、ECMAScriptで採択された新機能はいち早く取り入れられます。\n\nさらに、TypeScriptはESNextと言われる次のECMAScriptに導入される言語仕様、別の言い方をすれば、未来のJavaScriptで使用可能になることがほぼ確定している言語仕様も先取りして取り入れています。\n\nECMAScriptへの追従に加え、ESNextの先取りによりプログラマは最新のJavaScript構文を使いながら、古い環境のコードにも対応できるようになります。\n\n注意が必要なのは、新しいAPIの利用です。たとえば、ECMAScript 2015(ES6)で導入された`Map`クラスや`Set`クラスを使ったコードをTypeScriptで書き、それをES5にコンパイルすると、構文エラーは起きないものの、`Map`クラスや`Set`クラスを使う部分は実行時エラーになります。これは、TypeScriptはあくまで新しい構文を古いJSコードに変換する仕事だけを担っているためです。もし、古い環境で新しいAPIを使う必要がある場合は、[core-js](https://github.com/zloirock/core-js)などのポリフィルを併用することで解決することができます。\n\n## TypeScriptはもっともポピュラーでもっとも愛されるAltJSである\n\nJavaScriptにコンパイルして使う言語を総じて「AltJS」と呼びます。TypeScriptはAltJSの一種で、AltJSには他にもさまざまな言語があります。その中でもTypeScriptはもっともポピュラーな言語です。\n\nStack Overflowが約65,000名の開発者をターゲットに行った調査から、[ポピュラーなプログラミング言語ランキング](https://insights.stackoverflow.com/survey/2020#most-popular-technologies)を発表しています。このランキングはAltJSだけでなく、JavaScriptやJava、C#などすべてのプログラミング言語を含んでいます。このランキングで、TypeScriptはC言語やRubyを抑えて、9位にランクインしています。\n\n別の調査に、世界中のJavaScriptユーザー約2万人を対象に行ったアンケート調査「[The State of JavaScript 2020](https://2020.stateofjs.com/)」があります。これによると、TypeScriptは2017年から2020年の4年間で連続して満足度ナンバーワンに輝いています。そして、93%ものユーザーが「満足し、もう一度使いたい」と回答しています。\n\n利用者人口が多く満足度の高いプログラミング言語を選択することは、さまざまな利点があります。まず、情報が豊富に出回っている点です。新しい言語を学ぶ際にも、トラブルシューティングの際にも情報の絶対量が開発のしやすさを大きく左右することは言うまでもないでしょう。\n\n次に、エコシステムが充実していることです。VSCodeやJetBrains IntelliJ IDEAといったTypeScriptをサポートするIDEがあり、数多くのフレームワークやパッケージもTypeScriptに対応しています。言語単体の仕様がいくら優れていたとしても、開発を取り巻く環境が整っていなければ、他の言語にすでにあるようなツールやパッケージを自ら再発明しないといけなくなってしまいます。TypeScriptはエコシステムが充実しているので、そういった心配は不要です。\n\n最後に、採用や就職の面でもTypeScriptは有利です。使用人口が多いということは企業側にとってプログラマが探しやすいということであり、求職者にとってはプロジェクトを探しやすいということです。TypeScriptは先の調査結果で示されたとおり高い満足度があり、そうした言語を採用しているプロジェクトは、プログラマからも人気が出やすく、モチベーションの高いプログラマが集まりやすいです。\n",
      "url": "https://typescriptbook.jp/overview/why-you-should-use-typescript"
    },
    {
      "title": "TypeScriptの特徴",
      "content": "# TypeScriptの特徴\n\nTypeScriptは、Microsoftにより2012年10月1日に初めて発表された、スケーラブルなJavaScriptの上位互換言語です。スケーラブルな言語は、プロジェクトの規模や開発チームの人数が増えても、うまく機能し続けることができる言語のことで、TypeScriptはその特性から大規模プロジェクトにも適しています。\n\nTypeScriptはJavaScriptの上位互換であり、JavaScriptに静的な型付けが追加されています。TypeScriptで書かれたコードは純粋なJavaScriptにコンパイルされ、ブラウザ、サーバーなどJavaScriptが実行できるすべての実行環境で動作します。さらに、オープンソースプロジェクトであり、Apache License 2.0で提供されています。\n\n## JavaScriptの上位互換\n\nTypeScriptはJavaScriptに型が追加され、それ以外の部分は基本的に互換性があります。これまでJavaScriptに慣れ親しんできた方であれば時間をかけずに習得できます。\n\n## トランスパイル\n\nTypeScriptコードは、さまざまなJavaScriptのバージョン（例: ES5, ES6）へトランスパイルすることができます。これにより、ブラウザや実行環境の互換性問題を回避できます。\n\n## 静的型付け\n\nTypeScriptは[静的型付け](./static-type.md)を持つ言語で、変数や関数の引数に型を指定することで、コードの安全性が向上し、バグが発見しやすくなります。\n\n```typescript\nfunction sum(a: number, b: number): number {\n  return a + b;\n}\n```\n\n## 型推論\n\nTypeScriptは、型注釈がついていない変数でもコンテキストに基づいて自動的に型を推測します。これにより、開発者は型を明示しなくても安全性が向上します。\n\n## 構造的部分型システム\n\nTypeScriptは[構造的部分型](../reference/values-types-variables/structural-subtyping.md)システムを採用しており、オブジェクトの形状（つまり、オブジェクトがどのようなプロパティとメソッドを有しているか）に基づいて型を判断します。したがって、公称型ではなく、構造的部分型に基づいて動作します。\n\n## ジェネリクス\n\nTypeScriptは[ジェネリクス](../reference/generics/README.md)をサポートしており、汎用的で再利用可能なコードを書くことができます。\n\n```typescript twoslash\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\n## 高度な型表現\n\nTypeScriptでは、高度な型システムを用いて複雑な型を表現できます。これにより、アプリケーションのロジックをより堅牢で表現豊かな形で開発できます。以下は、TypeScriptで利用可能な高度な型表現のいくつかの例です。\n\n1. **ユニオン型**: 複数の型のどれかを表すことができます。たとえば、初期値が`null`の変数を処理する場合、ユニオン型を使うことができます。\n\n   ```typescript\n   type NullableString = string | null;\n   ```\n\n2. **タプル型**: 配列の各要素に異なる型を指定できる型です。これにより、異なる型の組み合わせを簡潔に表現できます。\n\n   ```typescript\n   type Point2D = [number, number];\n   ```\n\n## 複数の言語パラダイムのサポート\n\nTypeScriptは、オブジェクト指向プログラミング (OOP) と関数型プログラミング (FP) の両方をサポートしています。これにより、開発者は柔軟で強力なプログラムを構築することができます。\n\n## クラスとインターフェース\n\nTypeScriptはクラスベースのオブジェクト指向プログラミングとインターフェースをサポートします。これにより、コードの再利用や継承が容易になり、大規模なプロジェクトを管理する際に役立ちます。\n\n```typescript twoslash\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n\nclass Employee implements Person {\n  firstName: string;\n  lastName: string;\n  constructor(firstName: string, lastName: string) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n```\n\n## メモリ管理\n\nTypeScriptは、基本的にJavaScriptと同様のメモリ管理を行います。JavaScriptエンジンがガベージコレクションを用いて、自動的にメモリを解放します。\n\n## 非同期処理\n\nTypeScriptは、JavaScriptと同様にイベント駆動型の非同期プログラミングをサポートしています。Promiseやasync/awaitを用いて、非同期処理を簡潔かつ効率的に実装できます。\n\n```typescript twoslash\nasync function fetchData(): Promise<void> {\n  try {\n    const response = await fetch(\"https://api.example.com/data\");\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error(\"Error fetching data:\", error);\n  }\n}\n```\n\n## シングルスレッドモデル\n\nTypeScript (およびJavaScript) はシングルスレッドモデルを採用しています。シングルスレッドモデルは、シンプルで分かりやすいコードを実現し、イベントループと非同期処理で効率的なタスク処理をサポートします。一方で、Web Workersを利用してバックグラウンドで実行されるスレッドを作成し、マルチタスクを実現することもできます。\n\n## 強力な開発環境\n\nTypeScriptは強力な開発環境を提供しています。開発者が良質な開発体験を享受できるよう、インテリセンスとリアルタイムエラー表示の機能をエディターに提供しています。これにより、自動補完や型情報が手に入るため、開発がスムーズに進み、型の誤りや不整合が早い段階で検出され、確かなコードを書きやくなっています。\n\n## オープンソース\n\nTypeScriptは、オープンソースで開発されており、[TypeScript GitHubリポジトリ](https://github.com/microsoft/TypeScript)でソースコードやドキュメントが公開されています。開発者は、GitHubリポジトリを介してTypeScriptプロジェクトに寄与することができます。\n\n## まとめ\n\nこれらの特徴により、TypeScriptは現代のWeb開発において非常に魅力的な選択肢となっています。静的型付けと高度な型システムを導入したことで、大規模プロジェクトや、オブジェクト指向プログラミングおよび関数型プログラミングなど、多様な開発スタイルに対応しており、堅牢で柔軟なコードが実現できます。そして、オープンソースでありながら、Microsoftの強力なバックアップがあることも魅力のひとつです。\n",
      "url": "https://typescriptbook.jp/overview/features"
    },
    {
      "title": "TypeScript",
      "content": "---\nslug: /\nimage: /img/ogp.png\nsidebar_label: トップ\n---\n\n# TypeScript\n\n<head>\n  <title>TypeScript入門『サバイバルTypeScript』〜実務で使うなら最低限ここだけはおさえておきたいこと〜</title>\n</head>\n\n<!-- markdownlint-disable MD033 -->\n\n<iframe src=\"https://ghbtns.com/github-btn.html?user=yytypescript&repo=book&type=star&count=true&size=large\" frameBorder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\" style={{marginBottom: \"1rem\"}}></iframe>\n\n<!-- markdownlint-restore -->\n\n:::note\n本書『サバイバルTypeScript』は実務でTypeScriptを使う開発者のための入門書です。そして、このページはTypeScriptの特徴を最速で把握できるよう、数百ページからなる本書のコンテンツをつまみ食いした要約です。\n\n» [本書ついて詳しく知る](./about.md)\n» [とにかく今すぐTypeScriptを書いてみたい](./tutorials/README.md)\n:::\n\n## TypeScriptとは\n\n- JavaScriptの**スーパーセット**となるプログラミング言語。\n- **静的型付け言語**であり、プログラムの正しさが**静的に検査**できる。\n- ライブラリやIDEなどの開発環境が充実しており、**大きなエコシステム**を持っている。\n- **Microsoft**が2012年に開発し、**オープンソース**で公開した。\n\n» [TypeScriptの特徴について詳しく知る](./overview/features.md)\n» [TypeScript誕生の背景について詳しく知る](./overview/before-typescript.md)\n\n## TypeScriptはJavaScriptのスーパーセット\n\n- **スーパーセット**とは、元の言語との**互換性**を保ちつつ、元の言語を**拡張**して作った言語のこと。\n- TypeScriptは、JavaScriptとの互換性を保ちつつ、JavaScriptを拡張して作った言語である。\n- よって、JavaScriptのコードはすべてTypeScriptとしてあつかえる。\n- TypeScriptは、型注釈やインターフェース、ジェネリクスなど独自の機能を追加している。\n\n<figure><figcaption>TypeScriptの機能とJavaScriptの機能</figcaption>\n<img src=\"/top/typescript-as-superset-of-javascript.svg\" width=\"480\" />\n</figure>\n\n### スーパーセットのメリット\n\n- **学習のしやすさ**: JavaScriptの知識を活かしてTypeScriptを学べる。\n- **資産が活かせる**: 既存のJavaScriptコード資産を活かして開発できる。\n- **移行のしやすさ**: 既存のJavaScriptプロジェクトはTypeScriptへ移行がしやすい。\n\n» [TypeScriptとJavaScriptの関係について詳しく知る](./overview/javascript-is-typescript.md)\n\n## 静的な検査\n\n- TypeScriptはプログラムの正しさを静的に検査できる。\n- JavaScriptは実行しないとバグがあるかを確かめられない。\n- TypeScriptは実行せずにチェックが行える。\n\n» [静的な検査について詳しく知る](./overview/static-type.md)\n\n### 開発効率と品質を向上し、安心感を高める\n\n- 問題を早期に発見し、開発を効率化できる。\n- コーディング時に問題を発見し、修正できるため、バグを予防できる。\n- エディターとTypeScriptを連携させると、リアルタイムのチェックやコード補完が可能。\n\n<figure><figcaption>エディター上でのフィードバック</figcaption>\n<img src=\"/top/compile-error-feedback-on-editor.svg\" width=\"480\" />\n</figure>\n\n- 問題を早期に修正できることで、製品の信頼感や安心感が高まる。\n- 見通しの悪い大規模なプログラムや、重要なシステムの開発では静的な検査が安心材料になる。\n\n## 検査の仕組み\n\n- TypeScriptの検査は**型システム**に基づく。\n- 型システムに基づき、**コンパイル**のタイミングでプログラムを検査する。\n\n### 型システム\n\n- 型システムは、データの種別ごとに型を与え、データに対して行える操作に制約を設ける。\n- これにより、変数には決められた値のみが代入され、決められた操作のみが行われることが保証され、プログラムが正確で安全になる。\n- 型システムは、数学の「型理論」を背景に構築され、数学的証明によりプログラムの欠陥をあぶり出せる。\n\n### 型注釈\n\n- 変数にどのような値が代入できるのかを制約するものを「**型**」と言う。\n- 開発者は、変数がどのような型なのかを**型注釈**で指定する。\n- TypeScriptでは、型注釈を手がかりに検査が行われる。\n\n<figure><figcaption>型注釈</figcaption>\n<img src=\"/top/type-annotation.svg\" width=\"480\" />\n</figure>\n\n### 型推論\n\n- 値の型が文脈で明白な場合、型が自動で判断される。この仕組みを**型推論**という。\n- 型推論のおかげで、開発者は型注釈を割愛でき、記述量を減らせる。\n\n<figure><figcaption>型推論</figcaption>\n<img src=\"/top/type-inference.svg\" width=\"480\" />\n</figure>\n\n### コンパイル\n\n- TypeScriptを実行するために、JavaScriptへ変換する。この変換のことを**コンパイル**という。\n- 変換後のJavaScriptコードはブラウザやサーバーで実行できる。\n- TypeScriptの検査はコンパイルのタイミングで行われる。\n\n<figure><figcaption>コンパイル</figcaption>\n<img src=\"/top/compile-from-typescript-to-javascript.svg\" width=\"480\" />\n</figure>\n\n## 型はドキュメント、リファクタリング、ツールの充実にも寄与\n\n- **ドキュメントになる**: 型情報はドキュメントの役割を果たし、コードの理解を助ける。\n- **リファクタリングが安全に**: 変数の型や関数のシグネチャを変更したとき、修正が必要な箇所がコンパイル時にすべて分かり、不注意による誤修正を減らせる。\n- **ツールサポートが充実**: IDEやエディターでのリアルタイムのエラーチェック、自動補完、リファクタリングツール、ナビゲーションなど、開発ツールのサポートが充実している。\n\n» [TypeScriptを使う動機について詳しく知る](./overview/why-you-should-use-typescript.md)\n\n## 多くのエディターがTypeScriptをサポート\n\n- Visual Studio Code\n- JetBrains IDE (IntelliJ, WebStorm, PhpStorm, RubyMine, PyCharm, GoLandなど)\n- Vim\n- NeoVim\n- Emacs (Tide)\n- Atom\n- Sublime Text\n\n» [TypeScriptとエコシステムについて詳しく知る](./overview/ecosystem.md)\n\n## 多様なソフトウェアが作れる\n\n作れるものの範囲が広いことは、TypeScriptの魅力のひとつ。\n\n- **Webアプリケーション**: TypeScriptの主戦場。フロントエンドの開発に広く使用される。\n- **サーバーサイドアプリケーション**: Node.jsと組み合わせて、バックエンドやAPIサーバーを開発することが可能。\n- **モバイルアプリケーション**: React Nativeなどのフレームワークを利用して、モバイルアプリケーションを開発できる。\n- **デスクトップアプリケーション**: Electronを使用して、クロスプラットフォームのデスクトップアプリを開発できる。\n- **クラウド関連の機能**: AWS LambdaやAzure Functionsなどのクラウドプラットフォームで、サーバーレス関数が作成できる。\n- **ユーティリティーやCLIツール**: コマンドラインツールや各種ユーティリティの開発ができる。\n- **インフラ構成管理(IaC)**: PulumiやAWS CDKを使用して、インフラの構成を管理することができる。\n- **アプリケーションの拡張機能**: Google ChromeやVisual Studio Codeなどデスクトップアプリケーションの拡張をTypeScriptで開発できる。\n\n» [TypeScriptの射程圏について詳しく知る](./overview/range-of-typescript.md)\n\n## TypeScriptを導入した企業の感想\n\n- **[Slack][]**: コードベースが大規模になっても、型システムが安全性と信頼性を保証してくれる。\n- **[Airbnb][]**: TypeScriptを使っていたらAirbnbの38%ものバグを未然に防げた。\n- **[ヤフー株式会社][]**: 静的型付けによりコードの品質とメンテナンス性が向上し、IDEとの連携により開発者の生産性が向上した。\n- **[LINE株式会社][]**: ちょっとした修正でもかかるQAのコストを、TypeScript化によって抑制。\n- **[Sansan株式会社][]**: 型がドキュメントとしての役割を果たし、コードリーディングや他チームのコード変更に役立った。採用の文脈でアピールポイントにもなった。\n- **[ラクスル株式会社][]**:型システムの恩恵が得られる、エディターの入力補完を受けられる、コード=ドキュメントという状況を作りやすい。\n\n[Slack]: https://slack.engineering/typescript-at-slack/\n[Airbnb]: https://www.reddit.com/r/typescript/comments/aofcik/38_of_bugs_at_airbnb_could_have_been_prevented_by/\n[ヤフー株式会社]: https://codezine.jp/article/detail/16905\n[Sansan株式会社]: https://buildersbox.corp-sansan.com/entry/2021/06/24/110000\n[ラクスル株式会社]: https://techblog.raksul.com/entry/2020/10/07/after-introducing-typescript-to-existing-product/\n[LINE株式会社]: https://logmi.jp/tech/articles/322702\n\n## 基本的な型\n\n### プリミティブ型\n\n<!--TODO: ここから続きやる-->\n\n- [`boolean`](./reference/values-types-variables/boolean.md): 真偽値。\n- [`number`](./reference/values-types-variables/number/README.md): 数値。\n- [`string`](./reference/values-types-variables/string.md): 文字列。\n- [`bigint`](./reference/values-types-variables/bigint.md): 大きな整数。\n- [`symbol`](./reference/values-types-variables/symbol.md): 一意の値を示す。\n- [`undefined`](./reference/values-types-variables/undefined.md): 値が定義されていない状態を示す。\n- [`null`](./reference/values-types-variables/null.md): 値が存在しない状態を示す。\n\n```typescript twoslash\nconst isReady: boolean = false;\nconst age: number = 25;\nconst fullName: string = \"John Doe\";\nconst bigNumber: bigint = 100n;\nconst uniqueSymbol: symbol = Symbol(\"unique\");\nconst notDefined: undefined = undefined;\nconst empty: null = null;\n```\n\n### 特殊な型\n\n- [`any`](./reference/values-types-variables/any.md): 何でも代入できる型。型が不明な場合に使用する。その値に対する操作の制限がなく、型の安全性は弱まる。\n- [`unknown`](./reference/statements/unknown.md): any型と似て、何でも代入できる型。その値に対する操作は制限され、型の安全性が保たれる。\n- [`void`](./reference/functions/void-type.md): 値が存在しないことを示す。関数が何も返さない場合に使用する。\n- [`never`](./reference/statements/never.md): 決して何も返さないことを示す。エラーを投げる関数や無限ループの関数の戻り値として使用する。\n\n```typescript twoslash\nconst a: any = 100; // 代入できる\nconsole.log(a * 3); // 操作もできる\n// @log: 300\n\n// @errors: 18046\nconst x: unknown = 100; // 代入はできる\nconsole.log(x * 3); // 操作はできない\n\n// 戻り値のない関数\nfunction doSomething(): void {}\n\n// 戻り値を返すことがありえない関数\nfunction throwError(): never {\n  throw new Error();\n}\n```\n\n## 型エイリアス\n\n- [型エイリアス](./reference/values-types-variables/type-alias.md)は既存の型を新たな名前で定義する機能。\n- より複雑な型を簡素に表現したり、コードの可読性を向上するのに役立つ。\n\n```typescript twoslash\ntype StringOrNumber = string | number;\nlet value: StringOrNumber;\nvalue = \"hello\"; // string型が代入可能\nvalue = 123; // number型も代入可能\n```\n\n## 構造的部分型\n\n- TypeScriptは[構造的部分型](./reference/values-types-variables/structural-subtyping.md)を採用している。\n- 構造的部分型では、変数の代入可否を、構造が互換しているかに着目して判定する。\n\n```typescript twoslash\n// @errors: 2741\ntype Summary = { name: string };\ntype Detail = { name: string; age: number };\n\nconst johnDetail: Detail = { name: \"John\", age: 28 };\nconst summary: Summary = johnDetail; // 代入できる。構造的部分型として互換があるため\n\nconst johnSummary: Summary = { name: \"John\" };\nconst detail: Detail = johnSummary; // 代入できない。構造的部分型として互換がない（ageを含まないため）\n```\n\n## 配列\n\n### 配列リテラル\n\n- 配列の値を作るには[配列リテラル](reference/values-types-variables/array/array-literal.md)(`[]`)を使う。\n- `[要素1, 要素2, ...]`の形で配列の初期値を設定できる。\n\n```typescript twoslash\nconst numbers = [1, 2, 3];\n```\n\n### 配列の型注釈\n\n- [配列の型注釈](reference/values-types-variables/array/type-annotation-of-array.md)には`型名[]`または`Array<型名>`を使う。\n\n```typescript twoslash\nlet numbers: number[];\nlet strings: Array<string>;\n```\n\n### 配列要素へのアクセス\n\n- [配列要素にアクセスする](reference/values-types-variables/array/how-to-access-elements-in-an-array.md)にはインデックス（インデックス）を使う。\n- 0から始まる整数を指定して配列の値を取得し、代入も可能。\n\n```typescript twoslash\nconst colors = [\"red\", \"green\", \"blue\"];\nconsole.log(colors[0]);\n// @log: 'red'\ncolors[1] = \"yellow\";\nconsole.log(colors);\n// @log: ['red', 'yellow', 'blue']\n```\n\n### 読み取り専用配列\n\n- [読み取り専用配列](reference/values-types-variables/array/readonly-array.md)は値の変更ができない配列を表す。\n- 配列の型注釈に`readonly`をつけると読み取り専用配列となる。\n- `ReadonlyArray<型名>`でも読み取り専用配列が宣言でき、`readonly 型名[]`と機能は同じ。\n\n```typescript twoslash\n// @errors: 2542 2339\nconst numbers: readonly number[] = [1, 2, 3];\nconst strings: ReadonlyArray<string> = [\"hello\", \"world\"];\n\nnumbers[0] = 4; // 値を変更できない\nstrings.push(\"!\"); // 要素を追加できない\n```\n\n### 配列のループ\n\n- [配列をループする](reference/values-types-variables/array/how-to-loop-an-array.md)ための`for...of`構文もある。\n\n```typescript twoslash\nconst numbers = [1, 2, 3];\n\nfor (const num of numbers) {\n  console.log(num); // 1, 2, 3と出力される\n}\n```\n\n## タプル型\n\n- [タプル型](reference/values-types-variables/tuple.md)を使うと、配列の要素数と要素の型が固定される。\n- それぞれの要素のインデックスごとに型が決まる。\n\n```typescript twoslash\n// @errors: 2322\nlet tuple: [string, number];\ntuple = [\"hello\", 10]; // 代入できる\ntuple = [10, \"hello\"]; // 順序が正しくないため、代入できない\ntuple = [\"hello\", 10, \"world\"]; // 要素が多すぎるため代入できない\n```\n\n### タプルの要素へのアクセス\n\n- タプルの要素にアクセスする場合も配列同様にインデックス（インデックス）を使用する。\n\n```typescript twoslash\nconst tuple: [string, number] = [\"hello\", 10];\nconsole.log(tuple[0]);\n// @log: 'hello'\n```\n\n## オブジェクト\n\n### オブジェクトリテラル\n\n- オブジェクトの作り方は[オブジェクトリテラル](reference/values-types-variables/object/object-literal.md)(`{}`)を使う。\n- `{ プロパティキー: 値, ... }` の形でオブジェクトの初期値を設定できる。\n\n```typescript twoslash\nconst john = { name: \"John\", age: 20 };\n```\n\n### プロパティアクセス\n\n- ドット`.`を使ってオブジェクトのプロパティにアクセスできる。\n\n```typescript twoslash\ndeclare const john: { name: string; age: number };\n// ---cut---\nconsole.log(john.name);\n// @log: 'John'\n```\n\n### オブジェクトの型注釈\n\n- [オブジェクトの型注釈](reference/values-types-variables/object/type-annotation-of-objects.md)は`{プロパティ1: 型1, プロパティ2: 型2, ...}`の形で記述する。\n\n```typescript twoslash\nlet obj: { name: string; age: number };\n```\n\n### readonlyプロパティ\n\n- [`readonly`](reference/values-types-variables/object/readonly-property.md)をつけたプロパティは代入できない。\n\n```typescript twoslash\n// @errors: 2540\nlet obj: { readonly name: string; age: number };\nobj = { name: \"John\", age: 20 };\nobj.name = \"Tom\";\n```\n\n### オプションプロパティー\n\n- [オプショナルプロパティー](reference/values-types-variables/object/optional-property.md)`?`をつけたプロパティは省略可能。\n\n```typescript twoslash\nlet obj: { name: string; age?: number };\nobj = { name: \"John\" }; // `age`プロパティがなくてもエラーにならない\n```\n\n### オブジェクトメソッド\n\n- 関数をプロパティに持つオブジェクトを定義できる。\n\n```typescript twoslash\nconst obj = {\n  a: 1,\n  b: 2,\n  sum(): number {\n    return this.a + this.b;\n  },\n};\nconsole.log(obj.sum());\n// @log: 3\n```\n\n### インデックス型\n\n- オブジェクトは[インデックス型](reference/values-types-variables/object/index-signature.md)を利用して任意のキーの値を取得することができる。\n- インデックス型プロパティの型注釈は`[キー名: プロパティキーの型]: プロパティ値の型` の形で記述する。\n\n```typescript twoslash\nlet obj: { [key: string]: number };\nobj = { key1: 1, key2: 2 };\nconsole.log(obj[\"key1\"]);\n// @log: 1\nconsole.log(obj[\"key2\"]);\n// @log: 2\n```\n\n### Shorthand property names\n\n- プロパティの値がすでに定義されている変数である場合、そのプロパティ名を省略して記述できる([shorthand property names](reference/values-types-variables/object/shorthand-property-names.md))。\n\n```typescript twoslash\nexport default \"変数nameを使いたいのでモジュール化する必要がありました。\";\n// ---cut---\nconst name = \"John\";\nconst age = 20;\nconst obj = { name, age };\nconsole.log(obj);\n// @log: { name: 'John', age: 20 }\n```\n\n### オプショナルチェーン\n\n- プロパティが存在するかどうか不確定である場合、`?.`演算子（[オプショナルチェーン](reference/values-types-variables/object/optional-chaining.md)）で安全にアクセスできる。\n\n```typescript twoslash\nfunction printLength(obj: { a?: string }) {\n  console.log(obj.a?.length);\n}\nprintLength({ a: \"hello\" });\n// @log: 5\nprintLength({});\n// @log: undefined\n```\n\n## Map\n\n### Mapオブジェクト\n\n- [Mapオブジェクト](reference/builtin-api/map.md)はキーとそれに対応する値を対にしたコレクション。\n- キーはオブジェクトも含め任意の値が可能。\n\n```typescript twoslash\nconst map = new Map();\nmap.set(\"name\", \"John\");\nmap.set(\"age\", \"20\");\n\nconsole.log(map.get(\"name\"));\n// @log: 'John'\n```\n\n### Mapの型注釈\n\n- Mapの型注釈は`Map<キーの型, 値の型>`の形で記述する。\n\n```typescript twoslash\nlet people: Map<string, number>;\n```\n\n### Mapのループ\n\n- Mapオブジェクトは`for...of`でループすると、各エントリーがキーと値の配列として順に取得できる。\n- 要素の順序は、要素を追加した順が保証されている。\n\n```typescript twoslash\nconst map = new Map<string, number>();\n// ---cut---\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n```\n\n## Set\n\n### Set オブジェクト\n\n- [Setオブジェクト](reference/builtin-api/set.md)は同じ値が存在しないコレクション。\n- Setの要素は何でも可能である。\n\n```typescript twoslash\nconst set = new Set();\nset.add(1);\nset.add(2);\nset.add(2); // 同じ値は追加されない。\n\nconsole.log(set);\n// @log: Set {1, 2}\n```\n\n### Setの型注釈\n\n- Setの型注釈は`Set<要素の型>`の形で記述する。\n\n```typescript twoslash\nlet numSet: Set<number>;\n```\n\n### Setのループ\n\n- SetもMap同様に`for...of`でループすることが可能。\n- 順序は`add`した順。\n\n```typescript twoslash\nconst set = new Set<number>();\n// ---cut---\nfor (const value of set) {\n  console.log(value);\n}\n```\n\n## 列挙型 (Enum)\n\n### 列挙型の基本\n\n- [列挙型](reference/values-types-variables/enum/README.md)(enum)は、関連する一連の数値または文字列値の集まりを定義する。\n- 列挙型は`enum`キーワードを使用して定義する。\n\n```typescript twoslash\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\n```\n\n### 列挙型に値を設定\n\n- 列挙体の値は文字列リテラルまたは数値リテラルで指定できる。\n\n```typescript twoslash\nenum Color {\n  Red = \"red\",\n  Green = \"green\",\n  Blue = \"blue\",\n}\n```\n\n### 列挙型の利用\n\n- 列挙型の各値にアクセスするにはドット演算子を使用する。\n\n```typescript twoslash\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\n// ---cut---\nconst myColor: Color = Color.Red;\n```\n\n## ユニオン型\n\n- [ユニオン型](reference/values-types-variables/union.md)は複数の型のうちのいずれかをとる値を表現できる。\n- `型1 | 型2 | ...`の形式で使う。\n- ひとつ以上の異なる型の値を同じ変数で扱う場合に使用する。\n\n```typescript twoslash\nlet value: boolean | number;\nvalue = true; // 代入できる\nvalue = 100; // 代入できる\n```\n\n### 判別可能なユニオン型\n\n- [判別可能なユニオン型](reference/values-types-variables/discriminated-union.md)は、共通のリテラル型のプロパティを持つ特別なユニオン型。\n- 共通のプロパティを利用して、型を判別できる。\n\n```typescript twoslash\ntype Triangle = { kind: \"triangle\"; base: number; height: number };\ntype Rectangle = { kind: \"rectangle\"; width: number; height: number };\ntype Shape = Triangle | Rectangle;\n\nfunction getArea(shape: Shape): number {\n  // 共通のプロパティkindを利用して型を判定する\n  switch (shape.kind) {\n    case \"triangle\":\n      // この節ではshapeがTriangle型に絞り込まれる\n      return (shape.base * shape.height) / 2;\n    case \"rectangle\":\n      //  この節ではshapeがRectangle型に絞り込まれる\n      return shape.width * shape.height;\n  }\n}\n```\n\n## インターセクション型\n\n- [インターセクション型](reference/values-types-variables/intersection.md)は複数の型を1つに結合した新しい型を定義する。\n- `型1 & 型2 & ...`の形式で使う。\n- その結果として生じた型は、それぞれの型が持つすべてのプロパティとメソッドを備えている。\n\n```typescript twoslash\ntype Octopus = { swims: boolean };\ntype Cat = { nightVision: boolean };\ntype Octocat = Octopus & Cat;\n\nconst octocat: Octocat = { swims: true, nightVision: true };\nconsole.log(octocat);\n// @log: { swims: true, nightVision: true }\n```\n\n## 分割代入\n\n- 分割代入を使うと、配列の各要素を一度に変数に代入できる([配列の分割代入](reference/values-types-variables/array/destructuring-assignment-from-array.md))。\n\n```typescript twoslash\nconst [a, b] = [1, 2];\nconsole.log(a);\n// @log: 1\nconsole.log(b);\n// @log: 2\n```\n\n- 分割代入により、オブジェクトのプロパティを個別の変数へ代入できる([オブジェクトの分割代入](reference/values-types-variables/object/destructuring-assignment-from-objects.md))。\n\n```typescript twoslash\nexport default \"変数nameを使いたいのでモジュール化する必要がありました。\";\n// ---cut---\nconst obj = {\n  name: \"John\",\n  age: 20,\n};\n\nconst { name, age } = obj;\nconsole.log(name);\n// @log: 'John'\nconsole.log(age);\n// @log: 20\n```\n\n## 条件分岐\n\n- TypeScriptではJavaScriptと同様に、条件分岐には`if`構文や`switch`構文が利用できる。\n\n### [if-else文](reference/statements/if-else.md)\n\n```typescript twoslash\nconst age: number = 20;\n\nif (age >= 20) {\n  console.log(\"You are an adult.\");\n} else {\n  console.log(\"You are a minor.\");\n}\n// @log: 'You are an adult.'\n```\n\n### [switch文](reference/statements/switch.md)\n\n```typescript twoslash\nconst color: string = \"blue\";\n\nswitch (color) {\n  case \"red\":\n    console.log(\"Color is red.\");\n    break;\n  case \"blue\":\n    console.log(\"Color is blue.\");\n    break;\n  default:\n    console.log(\"Color is neither red nor blue.\");\n}\n// @log: 'Color is blue.'\n```\n\n### 型の絞り込み\n\n- 条件分岐を利用すると、その節内では型が自動的に絞り込まれる([制御フロー分析と型ガードによる型の絞り込み](reference/statements/control-flow-analysis-and-type-guard))。\n\n```typescript twoslash\nlet value: string | number;\n// 50%の確率でstring型またはnumber型の値を代入する\nvalue = Math.random() < 0.5 ? \"Hello\" : 100;\n\nif (typeof value === \"string\") {\n  // この節ではvalueはstring型として扱われる\n  console.log(value.toUpperCase());\n} else {\n  // この節ではvalueはnumber型として扱われる\n  console.log(value * 3);\n}\n```\n\n## 関数\n\n- TypeScriptではアロー関数や関数宣言に型注釈をつけることができる。\n\n### [アロー関数](reference/functions/arrow-functions.md)\n\n```typescript twoslash\nconst greet = (name: string): string => {\n  return `Hello ${name}`;\n};\n\nconsole.log(greet(\"John\"));\n// @log: 'Hello John'\n```\n\n### [関数宣言](reference/functions/function-declaration.md)\n\n```typescript twoslash\nfunction greet(name: string): string {\n  return `Hello ${name}`;\n}\n\nconsole.log(greet(\"John\"));\n// @log: 'Hello John'\n```\n\n### 分割代入引数\n\n- 関数の引数に配列またはオブジェクトリテラルを展開することができる([分割代入引数](reference/functions/destructuring-assignment-parameters.md))。\n\n```typescript twoslash\nconst printCoord = ({ x, y }: { x: number; y: number }) => {\n  console.log(`Coordinate is (${x}, ${y})`);\n};\n\nprintCoord({ x: 10, y: 20 });\n// @log: 'Coordinate is (10, 20)'\n```\n\n### 型ガード関数\n\n- 特定の型であることを判定する関数([型ガード関数](reference/functions/type-guard-functions.md))を利用することで、型が絞り込まれる。\n\n```typescript twoslash\nfunction isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nfunction printLength(value: any) {\n  if (isString(value)) {\n    // この節ではvalueはstring型として扱われる\n    console.log(value.length);\n  }\n}\n\nprintLength(\"hello\");\n// @log: 5\n```\n\n### オプション引数\n\n- 関数の引数には`?`をつけることで任意とすることができる([オプション引数](reference/functions/optional-parameters.md))。\n\n```typescript twoslash\nfunction greet(name?: string) {\n  if (name === undefined) {\n    return \"Hello!\";\n  } else {\n    return `Hello ${name}!`;\n  }\n}\n\nconsole.log(greet(\"John\"));\n// @log: 'Hello John!'\nconsole.log(greet());\n// @log: 'Hello!'\n```\n\n### デフォルト引数\n\n- 関数の引数には`=`を使ってデフォルトの値を設定することができる([デフォルト引数](reference/functions/default-parameters.md))。\n\n```typescript twoslash\nfunction greet(name: string = \"Mystery\") {\n  return `Hello ${name}!`;\n}\n\nconsole.log(greet(\"John\"));\n// @log: 'Hello John!'\nconsole.log(greet());\n// @log: 'Hello Mystery!'\n```\n\n### 残余引数\n\n- `...`を使って[残余引数](reference/functions/rest-parameters.md)(任意の数の引数)を設定することができる。\n\n```typescript twoslash\nfunction sum(...numbers: number[]) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5));\n// @log: 15\n```\n\n## クラス\n\n### クラス構文\n\n- JavaScriptの[クラス](reference/object-oriented/class/README.md)構文はそのまま利用できる。\n- [フィールド](reference/object-oriented/class/fields.md)宣言に型注釈をつけることができる。\n\n```typescript twoslash\nclass Person {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  introduce(): void {\n    console.log(`My name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\nconst john = new Person(\"John\", 20);\njohn.introduce();\n// @log: 'My name is John and I am 20 years old.'\n```\n\n### アクセス修飾子\n\n- `public`(デフォルト)、`protected`、`private`の3つの[アクセス修飾子](reference/object-oriented/class/access-modifiers.md)が利用できる。\n\n```typescript twoslash\n// @errors: 2341\nclass Person {\n  public name: string;\n  private age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  introduce(): void {\n    console.log(`My name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\nconst john = new Person(\"John\", 20);\nconsole.log(john.name); // 'John'が出力される\nconsole.log(john.age); // エラー（privateなのでアクセスできない）\n```\n\n### クラスのreadonly修飾子\n\n- [`readonly`修飾子](reference/object-oriented/class/readonly-modifier-in-classes.md)をつけたプロパティは、読み取り専用となる。\n- `readonly`修飾子はアクセス修飾子と併用可能。\n\n```typescript twoslash\n// @errors: 2540\nclass Person {\n  readonly name: string;\n  private readonly age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  introduce(): void {\n    console.log(`My name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\nconst john = new Person(\"John\", 20);\njohn.name = \"Tom\"; // エラー（readonlyのため変更不可）\n```\n\n### Constructor shorthand\n\n- TypeScriptでは、コンストラクタパラメータにアクセス修飾子をつけることで、自動的にそのフィールドが定義される([constructor shorthand](reference/object-oriented/class/constructor-shorthand.md))。\n- これによりコードの簡略化が図れる。\n\n```typescript twoslash\nclass Person {\n  constructor(public name: string, private age: number) {}\n\n  introduce(): void {\n    console.log(`My name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\nconst john = new Person(\"John\", 20);\njohn.introduce();\n// @log: 'My name is John and I am 20 years old.'\n```\n\n### フィールドの初期化子\n\n- フィールド宣言の際に直接初期値を設定できる([フィールドの初期化子](reference/object-oriented/class/field-initializers.md))。\n\n```typescript twoslash\nclass Counter {\n  count = 0; // 初期値を0に設定\n  //    ^^^初期化子\n\n  increment(): void {\n    this.count++;\n  }\n}\n\nconst counter = new Counter();\nconsole.log(counter.count);\n// @log: 0\ncounter.increment();\nconsole.log(counter.count);\n// @log: 1\n```\n\n### 静的フィールドと静的メソッド\n\n- `static`キーワードを使うことで、インスタンスではなくクラス自体に関連するフィールドやメソッドを定義できる([静的フィールド](reference/object-oriented/class/static-fields.md)、[静的メソッド](reference/object-oriented/class/static-methods.md))。\n\n```typescript twoslash\nclass MyClass {\n  static x = 0;\n\n  static printX(): void {\n    console.log(MyClass.x);\n  }\n}\n\nMyClass.printX();\n// @log: 0\n```\n\n### this型\n\n- メソッド内で`this`を返すことで、メソッドの呼び出しを直列につなげるメソッドチェーンを可能にする([メソッドチェーン](reference/object-oriented/class/return-this-type.md))。\n\n```typescript twoslash\nclass MyClass {\n  value = 1;\n\n  increment(): this {\n    this.value++;\n    return this;\n  }\n\n  add(v: number): this {\n    this.value += v;\n    return this;\n  }\n\n  print(): this {\n    console.log(this.value);\n    return this;\n  }\n}\n\nnew MyClass().increment().add(3).print();\n// @log: 5\n```\n\n### クラスの継承\n\n- `extends`キーワードにより、[クラスの継承](reference/object-oriented/class/class-inheritance.md)が可能。\n- スーパークラスのプロパティ・メソッドの値は、サブクラスからアクセス可能。\n\n```typescript twoslash\nclass Animal {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  greet(): string {\n    return `Hello, my name is ${this.name}`;\n  }\n}\n\nclass Dog extends Animal {\n  bark(): string {\n    return \"Woof!\";\n  }\n}\n\nconst dog = new Dog(\"Max\");\nconsole.log(dog.greet());\n// @log: 'Hello, my name is Max'\nconsole.log(dog.bark());\n// @log: 'Woof!'\n```\n\n### `instanceof`演算子\n\n- [`instanceof`演算子](reference/object-oriented/class/instanceof-operator.md)は、オブジェクトが特定のクラスのインスタンスであるかを判定できる。\n\n```typescript twoslash\nclass Animal {}\nclass Dog extends Animal {}\n\nconst dog = new Dog();\n\nconsole.log(dog instanceof Dog);\n// @log: true\nconsole.log(dog instanceof Animal);\n// @log: true\n```\n\n### 抽象クラス\n\n- `abstract`キーワードにより、[抽象クラス](reference/object-oriented/class/abstract-class.md)を定義できる。\n- 抽象クラスはインスタンス化できず、他のクラスが継承するための基底クラスに使用される。\n\n```typescript twoslash\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log(\"roaming the earth...\");\n  }\n}\n\nclass Dog extends Animal {\n  makeSound(): void {\n    console.log(\"Woof Woof\");\n  }\n}\n\nconst dog = new Dog();\ndog.move();\n// @log: 'roaming the earth...'\ndog.makeSound();\n// @log: 'Woof Woof'\n```\n\n### ゲッターとセッター\n\n- ゲッターやセッターは、オブジェクトのプロパティを取得・設定するためのメソッド。\n- ゲッターは`get`キーワードで、セッターは`set`キーワードで定義する。\n\n```typescript twoslash\nclass Circle {\n  private _radius: number;\n\n  constructor(radius: number) {\n    this._radius = radius;\n  }\n\n  // ゲッター\n  get radius(): number {\n    return this._radius;\n  }\n\n  // セッター\n  set radius(radius: number) {\n    if (radius <= 0) {\n      throw new Error(\"Invalid radius value\");\n    }\n    this._radius = radius;\n  }\n}\n\nconst circle = new Circle(5);\nconsole.log(circle.radius);\n// @log: 5\ncircle.radius = 3;\nconsole.log(circle.radius);\n// @log: 3\ncircle.radius = -2;\n// 例外: 'Invalid radius value'\n```\n\n### インターフェース\n\n- TypeScriptのインターフェースは、プロパティ、メソッド、クラスなどの形状を定義する能力を持つ。\n- インターフェースを使用する主な目的は、特定のクラスまたはオブジェクトが特定のプロパティまたはメソッドを保持することを強制する。\n\n```typescript twoslash\ninterface Printable {\n  print(): void;\n}\n\nclass MyClass implements Printable {\n  print(): void {\n    console.log(\"Hello, world!\");\n  }\n}\n```\n\n### インターフェース構文\n\n- TypeScriptの[インターフェース](reference/object-oriented/interface/README.md)はオブジェクトの形状を定義することが可能。\n- インターフェースはプロパティやメソッドのシグネチャを記述できる。\n\n```typescript twoslash\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n  sum(): number;\n}\n\nconst point: Point = {\n  x: 10,\n  y: 20,\n  sum: function () {\n    return this.x + this.y;\n  },\n};\n```\n\n### インターフェースのreadonly修飾子\n\n- インターフェース内でreadonly修飾子を使用して、プロパティを読み取り専用に設定できる。\n- これにより、プロパティの値が一旦設定されると後から変更できなくなる。\n\n```typescript twoslash\n// @errors: 2540\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\n\nconst p1: Point = { x: 10, y: 20 };\np1.x = 5;\n```\n\n## 例外処理\n\n- TypeScriptでは[例外処理](reference/statements/exception.md)のためにtry / catch / finally ブロックを使用できる。\n- 例外が発生した場合（つまり、エラーオブジェクトをスローした場合）catchブロックが実行される。\n\n```typescript twoslash\ntry {\n  throw new Error(\"An error occurred!\");\n} catch (error) {\n  console.log(error);\n}\n```\n\n### try-catch-finally構文\n\n- tryブロック内のコードは、エラーを検出し、catchブロックはエラーをハンドリングする。\n- finallyブロックはエラーの有無に関係なく実行される。\n\n```typescript twoslash\ntry {\n  throw new Error(\"Oops, something went wrong.\");\n} catch (error) {\n  console.log(error);\n} finally {\n  console.log(\"This is the finally block. It always gets executed.\");\n}\n```\n\n### 例外クラス\n\n- TypeScriptでは、カスタムエラークラスを作成することも可能。\n- Errorクラスを継承したカスタムクラスで、具体的なエラータイプを作成することができる。\n\n```typescript twoslash\nclass CustomError extends Error {\n  code = \"CustomError\";\n\n  constructor(message?: string) {\n    super(message);\n  }\n}\n\ntry {\n  throw new CustomError(\"This is a custom error\");\n} catch (error) {\n  if (error instanceof CustomError) {\n    console.log(`${error.code}: ${error.message}`);\n  }\n}\n```\n\n## 非同期処理\n\n- TypeScriptでは、[非同期プログラミング](reference/asynchronous/README.md)をサポートしていて、コード内で時間を要する処理を効率的に扱うことができる。\n\n### Promise\n\n- [Promise](reference/asynchronous/promise.md)は非同期操作の最終的な完了（または失敗）とその結果の値を表す。\n\n```typescript twoslash\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"Promise resolved\");\n  }, 2000);\n});\n\npromise.then((data) => {\n  console.log(data);\n});\n// @log: 'Promise resolved'\n```\n\n### async/await 構文\n\n- 非同期処理をより直感的に書くことができる[async構文](reference/asynchronous/async.md)と[await構文](reference/asynchronous/await.md)を導入している。\n- async/await 構文を使うと、非同期コードをあたかも同期コードであるかのように書ける。\n\n```typescript twoslash\nfunction delay(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function asyncFunction() {\n  console.log(\"Start\");\n  await delay(2000);\n  console.log(\"End\");\n}\n\nasyncFunction();\n\n// @log: 'Start'\n// 2秒後\n// @log: 'End'\n```\n\n## ジェネリクス\n\n- TypeScriptの[ジェネリクス](reference/generics/README.md)を使用すると、型の再利用性が向上し、型の一貫性を保つことができる。\n- ジェネリクスを使用すると、[型変数](reference/generics/type-variables.md)を導入でき、これにより機能の一部を一般化できる。\n\n```typescript twoslash\n// Tが型変数\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// 型変数Tにstringを割り当てる\nconst output1 = identity<string>(\"myString\");\n//    ^?\n\n// 型変数Tにnumberを割り当てる\nconst output2 = identity<number>(100);\n//    ^?\n```\n\n## モジュール\n\n- TypeScriptのモジュールシステムは、他のモジュールと共有するコードと、モジュール内部限定のコードとを分けることを可能にする([モジュール](reference/modules.md))。\n\n```typescript twoslash title=\"greeter.ts\"\nexport function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n```\n\n```typescript twoslash title=\"main.ts\"\n// @filename: greeter.ts\nexport function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n\n// @filename: main.ts\n// ---cut---\nimport { greet } from \"./greeter\";\nconsole.log(greet(\"TypeScript\"));\n// @log: 'Hello, TypeScript!'\n```\n\n### importとexport\n\n- モジュール内で定義した関数や変数を外部に公開するには、exportを使用する。\n- モジュールが公開した関数や変数を利用するには、importを使用する。\n\n```typescript twoslash title=\"math.ts\"\nexport function square(x: number) {\n  return x * x;\n}\n\nexport function cube(x: number) {\n  return x * x * x;\n}\n```\n\n```typescript twoslash title=\"main.ts\"\n// @filename: math.ts\nexport function square(x: number) {\n  return x * x;\n}\n\nexport function cube(x: number) {\n  return x * x * x;\n}\n\n// @filename: main.ts\n// ---cut---\nimport { square, cube } from \"./math\";\n\nconsole.log(square(2));\n// @log: 4\nconsole.log(cube(2));\n// @log: 8\n```\n\n### default export\n\n- defaultキーワードを使用すると、モジュールがデフォルトで1つの値のみをエクスポートすることを意味する。\n- default exportは、importする際に別名を指定することが可能である。\n\n```typescript twoslash title=\"greeter.ts\"\nexport default function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n```\n\n```typescript twoslash title=\"main.ts\"\n// @filename: greeter.ts\nexport default function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n\n// @filename: main.ts\n// ---cut---\nimport greetFunction from \"./greeter\";\nconsole.log(greetFunction(\"TypeScript\"));\n// @log: 'Hello, TypeScript!'\n```\n\n### 再export\n\n- モジュールは、別のモジュールからエクスポートされたものを再エクスポートすることができる。\n\n```typescript twoslash title=\"math.ts\"\nexport function add(x: number, y: number) {\n  return x + y;\n}\n```\n\n```typescript twoslash title=\"index.ts\"\n// @filename: math.ts\nexport function add(x: number, y: number) {\n  return x + y;\n}\n\n// @filename: index.ts\n// ---cut---\n// 再エクスポート\nexport { add } from \"./math\";\n```\n\n```typescript twoslash title=\"main.ts\"\n// @filename: math.ts\nexport function add(x: number, y: number) {\n  return x + y;\n}\n\n// @filename: index.ts\nexport { add } from \"./math\";\n\n// @filename: main.ts\n// ---cut---\nimport { add } from \"./index\";\nconsole.log(add(2, 3));\n// @log: 5\n```\n\n### type importとtype export\n\n- 型だけをエクスポート・インポートすることもできる。\n\n```typescript twoslash title=\"types.ts\"\nexport type MyObject = {\n  name: string;\n  age: number;\n};\n```\n\n```typescript twoslash title=\"main.ts\"\n// @filename: types.ts\nexport type MyObject = {\n  name: string;\n  age: number;\n};\n\n// @filename: main.ts\n// ---cut---\nimport type { MyObject } from \"./types\";\n//     ^^^^型インポート\n\nconst obj: MyObject = {\n  name: \"TypeScript\",\n  age: 3,\n};\n```\n\n## 型レベルプログラミング\n\n- TypeScriptには、typeof演算子やkeyof演算子、ユーティリティータイプなど、型レベルでプログラミングをするためのさまざまな機能が搭載されている。\n\n### typeof型演算子\n\n- [typeof演算子](reference/type-reuse/typeof-type-operator.md)は、変数名から型を逆算できる。\n\n```typescript twoslash\nconst object = {\n  name: \"TypeScript\",\n  version: 3.9,\n};\n\ntype ObjectType = typeof object;\n//   ^?\n```\n\n### keyof型演算子\n\n- [keyof演算子](reference/type-reuse/keyof-type-operator.md)を使うと、object型のすべてのキーを文字列リテラルのユニオン型として取得できる。\n\n```typescript twoslash\n// @errors: 2322\ntype Point = {\n  x: number;\n  y: number;\n};\n\ntype Key = keyof Point;\n//   ^?\nconst key1: Key = \"x\"; // 代入OK\nconst key2: Key = \"y\"; // 代入OK\nconst key3: Key = \"z\"; // 代入不可\n```\n\n### ユーティリティ型\n\n- TypeScriptは、既存の型から新しい型を作成するためのさまざまな一般的な型操作を提供している。\n\n#### Required\n\n- [`Required`](reference/type-reuse/utility-types/required.md)は、オプションプロパティーを必須プロパティーにするユーティリティ型。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age?: number;\n};\n\ntype RequiredPerson = Required<Person>;\n//   ^?\n// ageがオプションでなくなっている点に注目\n```\n\n#### Partial\n\n- [`Partial`](reference/type-reuse/utility-types/partial.md)は、型のすべてのプロパティをオプションにするユーティリティ型。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype OptionalPerson = Partial<Person>;\n//   ^?\n```\n\n#### Readonly\n\n- [`Readonly`](reference/type-reuse/utility-types/readonly.md)は、型のすべてのプロパティをreadonlyにするユーティリティ型。それらのプロパティは再代入できない。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype ReadonlyPerson = Readonly<Person>;\n//   ^?\n```\n\n#### Record\n\n- [`Record`](reference/type-reuse/utility-types/record.md)は、オブジェクトのすべてのプロパティ値を特定の型に設定するユーティリティ型。\n\n```typescript twoslash\ntype ThreeLetterRecord = Record<\"one\" | \"two\" | \"three\", string>;\n//   ^?\n```\n\n#### Pick\n\n- [`Pick`](reference/type-reuse/utility-types/pick.md)は、オブジェクトから特定のプロパティだけを拾い出すユーティリティ型。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n  address: string;\n};\n\ntype PersonNameAndAge = Pick<Person, \"name\" | \"age\">;\n//   ^?\n```\n\n#### Omit\n\n- [`Omit`](reference/type-reuse/utility-types/omit.md)は、オブジェクトから特定のプロパティを省いた型を作るユーティリティ型。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n  address: string;\n};\n\ntype PersonWithoutAddress = Omit<Person, \"address\">;\n//   ^?\n```\n\n#### Exclude\n\n- [`Exclude`](reference/type-reuse/utility-types/exclude.md)は、ユニオン型から特定の型を除外するユーティリティ型。\n\n```typescript twoslash\ntype T1 = number | string | boolean;\ntype T2 = Exclude<T1, boolean>;\n//   ^?\n```\n\n#### Extract\n\n- [`Extract`](reference/type-reuse/utility-types/extract.md)は、ふたつのユニオン型の共通の部分を抽出するユーティリティ型。\n\n```typescript twoslash\ntype T1 = number | string | boolean;\ntype T2 = string | boolean;\ntype T3 = Extract<T1, T2>;\n//   ^?\n```\n\n#### NonNullable\n\n- `NonNullable`は、nullまたはundefinedを含む型からいずれも除外するユーティリティ型。\n\n```typescript twoslash\ntype T1 = string | null | undefined;\ntype T2 = NonNullable<T1>;\n//   ^?\n```\n\n### Mapped types\n\n- [Mapped types](reference/type-reuse/mapped-types.md)を使うと、既存の型から新しい型を生成できる。\n- Mapped typesは、オブジェクトの各プロパティを”マップ”し、新しいオブジェクトを生成する。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype ReadOnlyPerson = { readonly [K in keyof Person]: Person[K] };\n//   ^?\n```\n\n### インデックスアクセス型\n\n- [インデックスアクセス型](reference/type-reuse/indexed-access-types.md)を使うと、型のプロパティの型を取得できる。\n\n```typescript twoslash\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype Name = Person[\"name\"];\n//   ^?\n```\n",
      "url": "https://typescriptbook.jp/README"
    },
    {
      "title": "作って学ぶTypeScript",
      "content": "---\nslug: /tutorials\n---\n\n# 作って学ぶTypeScript\n\nこの章では、TypeScriptを使った実践的な開発の流れを学びます。次のチュートリアルを用意しています。\n\n- [開発環境の準備](./setup.md)\n- [簡単な関数を作ってみよう](./make-a-simple-function-via-cli.md)\n- [Reactでいいねボタンを作ろう](./react-like-button-tutorial.md)\n- [Next.jsで猫画像ジェネレーターを作ろう](./nextjs.md)\n- [Vercelにデプロイしてみよう](./vercel-deploy.md)\n- [Jestでテストを書こう](./jest.md)\n- [Reactコンポーネントのテストを書こう](./component-test.md)\n- [Prettierでコード整形を自動化しよう](./prettier.md)\n- [ESLintでコーディング規約を自動化しよう](./eslint.md)\n\nこの章の目的は、「もし実務でTypeScriptを使ったらどんな開発になるのか？」について体験することです。この章を進めるにあたって、TypeScriptの知識はまだ無くても構いません。解説の手順どおりに進めることで、開発を追体験できるようになっています。\n\nこの章でのTypeScriptについての解説は最小限です。チュートリアルを進めるにあたり、必要なものは解説します。しかし、言語の詳しい仕様については省いています。まずは具体的な開発を体験してください。TypeScriptがどんな雰囲気なのか感じ取った上で、より詳しい言語の仕様や機能について学びたくなったら、次の章の「読んで学ぶTypeScript」をお読みください。\n\n[読んで学ぶTypeScript](/reference/README)\n",
      "url": "https://typescriptbook.jp/tutorials/README"
    },
    {
      "title": "Vercelにデプロイしてみよう",
      "content": "# Vercelにデプロイしてみよう\n\nこのチュートリアルでは前のNext.jsのハンズオンで作成した猫画像ジェネレーターをVercelへデプロイする方法を学びます。\n\n## Vercelとは？\n\nNext.jsを開発しているVercel社が提供しているフロントエンド向けのクラウドプラットフォームで、特徴としては次の点があります。\n\n- 特別な設定をせずにゼロコンフィグでGitHubリポジトリと連携をするだけで簡単にデプロイ環境を構築できる\n- プルリク単位で自動でプレビュー環境を利用できる\n- JavaScriptやCSSファイルを自動で圧縮してCDN環境で配信\n\n特にVercelはNext.jsをホスティングする環境として開発されており、Next.jsのAPIルートの自動スケールや特別な対応がなくISRを利用できるので、他のクラウドプラットフォームを利用する理由がない場合はNext.jsのホスティング環境としてVercelを利用することをオススメします。\n\n## このチュートリアルに必要なもの\n\n今回のチュートリアルではGitHubリポジトリとの連携を利用してデプロイ環境を構築するために、次のものが必要です。\n\n- GitHubアカウント\n- 「[Next.jsで猫画像ジェネレーターを作ろう](./nextjs.md)」で作成したコードと、それをpush済みのGitHubリポジトリ\n  - 上のチュートリアルを実施された方は、ご自身のGitHubアカウントのリポジトリにコードをpushしておいてください。\n  - 自分で作ったコードでなくても構わない方は、本書が提供する[random-catリポジトリ](https://github.com/yytypescript/random-cat)を[フォーク](https://docs.github.com/ja/get-started/quickstart/fork-a-repo)しておくのでも構いません。\n\n## デプロイの流れ\n\n- Vercelアカウントを作成する\n- Vercelにログインする\n- GitHubリポジトリを連携する\n\n## Vercelアカウントを作成する\n\n:::note\nVercelのアカウントをすでにお持ちの方は、この手順を飛ばしてください。\n:::\n\n最初に[Vercel](https://vercel.com/signup)にアクセスをして、GitHubアカウントでVercelのアカウントを作成しましょう。アカウント作成後に連携するGitHubリポジトリの選択画面が表示されるので、「GitHubリポジトリを連携する」にお進みください。\n\n## Vercelにログインする\n\n[Vercelのログイン画面](https://vercel.com/login)に遷移してGitHubアカウントでログインをします。\n\n## GitHubリポジトリを連携する\n\n[VercelのGitHubリポジトリ連携のページ](https://vercel.com/new)へアクセスして猫画像ジェネレーターのGitHubリポジトリを検索して「Import」ボタンをクリックします。\n\n![連携するGitHubリポジトリの選択](vercel-deploy/screen1.png)\n\nプロジェクトの設定画面が表示されるので、設定はデフォルトのままで「Deploy」ボタンをクリックしてください。\n\n![プロジェクトの設定画面](vercel-deploy/screen2.png)\n\nデプロイ完了画面が表示されればデプロイは完了です。🎉画面のプレビュー表示がリンクになっており、クリックすることでデプロイされたアプリを表示することができます。\n\n![デプロイ完了画面](vercel-deploy/screen3.png)\n\n「Continue To Dashboard」のボタンをクリックすることでプロジェクトのダッシュボードページへ遷移できます。ダッシュボード上でVercelが自動生成したドメインを確認できます。このドメインはプロジェクトが存続している限り変更されないため、このURLを他の人に共有することでアプリを公開することができます。\n\n![ダッシュボード](vercel-deploy/screen6.png)\n\n## 自動デプロイを体験\n\nプルリクエストを作成・マージして自動デプロイを実行してみます。VercelではGitHub連携が完了した段階で自動デプロイのCI/CD環境も自動で構築されるので、プルリクエストを作成・マージするだけで自動でデプロイがされる状態になっています。\n\n実際に猫画像ジェネレーターのコードの一部を修正して自動デプロイを実行してみましょう。\n\n次のようにボタンの文言を「他のにゃんこも見る」を「One more cat!」に変更してGitHubリポジトリでプルリクエストを作成してください。\n\n```tsx twoslash {13} title=\"src/pages/index.tsx\"\nimport { NextPage } from \"next\";\nimport { useState } from \"react\";\ntype Props = { initialImageUrl: string };\ntype Image = { url: string };\ndeclare function fetchImage(): Promise<Image>;\ndeclare const styles: any;\n// ---cut---\nconst IndexPage: NextPage<Props> = ({ initialImageUrl }) => {\n  const [imageUrl, setImageUrl] = useState(initialImageUrl);\n  const [loading, setLoading] = useState(false);\n  const handleClick = async () => {\n    setLoading(true);\n    const newImage = await fetchImage();\n    setImageUrl(newImage.url);\n    setLoading(false);\n  };\n  return (\n    <div className={styles.page}>\n      <button onClick={handleClick} className={styles.button}>\n        One more cat!\n      </button>\n      <div className={styles.frame}>\n        {loading || <img src={imageUrl} className={styles.img} />}\n      </div>\n    </div>\n  );\n};\n```\n\nVercelは連携しているGitHubリポジトリに新たにブランチがプッシュされると自動でビルドが実行されて、プレビュー環境をデプロイしてくれます。\n\nプルリクエストを作成するとVercel BOTが画像のようにビルドのステータスとプレビュー環境のURLをコメントとしてくれるので、「Visit Preview」のリンクをクリックすることでレビュアーは簡単に新しい変更の確認をすることができます。\n\n![VercelのBOTがプルリクエストのプレビュー環境のURLをコメント](vercel-deploy/screen4.png)\n\nビルドの結果はプルリクエストのstatus checksにも表示されるので、ビルドが失敗している状態で誤ってデプロイをする事故も防ぐこともできます。\n\n![プルリクエストのステータスチェック](vercel-deploy/screen5.png)\n\n「Merge pull request」ボタンをクリックして、このプルリクエストをマージしてみましょう。ベースブランチに新しくブランチがマージされると本番環境に更新が自動でデプロイされます。\n\n先ほど確認した本番環境のURLにアクセスをすることで、ボタンのデザインが変更されており今回の修正が本番環境に自動でデプロイされたのを確認できます。😺\n\n![ボタンのデザインを変更した画面](vercel-deploy/screen7.png)\n\n## プロジェクトを削除\n\nプロジェクトが残って気になる方は、Settingsページに移動して`Delete`ボタンをクリックし、ダイアログで必要なテキストを入力することでプロジェクトを削除できます。\n\n![プロジェクトの削除ボタン](vercel-deploy/screen8.png)\n![プロジェクトの削除ダイアログ](vercel-deploy/screen9.png)\n",
      "url": "https://typescriptbook.jp/tutorials/vercel-deploy"
    },
    {
      "title": "Jestでテストを書こう",
      "content": "# Jestでテストを書こう\n\nこのチュートリアルでは、テストフレームワーク「Jest」を使い、ユニットテストをTypeScriptで書くことを学びます。\n\n## 本章で学べること\n\n本章では、簡単な関数のテストをJestで書くことを目標に、次のことを学びます。\n\n- Jestを使ってTypeScriptの関数をテストする方法\n- Jestの導入方法\n- Jestでのテストの書き方\n- テストの実行方法\n- 結果の見方\n\n本章の目的はJestを完全に理解することではありません。むしろ、Jestがどういったものなのか、その雰囲気を実際に体験することに主眼を置いています。そのため、内容はかなり最低限のものとなりますが、逆に言えば少しの時間でJestを試してみれるシンプルな内容にまとまってますから、ぜひ手を動かしてみてください。\n\n## Jestとは\n\nJestはJavaScriptのテストフレームワークです。TypeScriptでテストを書くこともできます。Jestは、フロントエンドライブラリのReactやVueなどのテストだけでなく、Node.js向けのパッケージのテストも行えます。要するに、JavaScriptやTypeScriptで書かれたコードであれば、そのほとんどはJestでテストが行えます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルで必要なものは次のとおりです。\n\n- Node.js v16以上\n- Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)\n\nNode.jsの導入については、[開発環境の準備](./setup.md)をご覧ください。\n\nパッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```shell\nnpm install -g yarn\n```\n\n## プロジェクトを作成する\n\nまず、このチュートリアルに使うプロジェクトを作成します。\n\n```shell\nmkdir jest-tutorial\ncd jest-tutorial\n```\n\nプロジェクトルートにpackage.jsonを作ってください。\n\n```shell\ntouch package.json\n```\n\npackage.jsonの内容は次のようにします。\n\n```json title=\"package.json\"\n{\n  \"name\": \"jest-tutorial\",\n  \"license\": \"UNLICENSED\"\n}\n```\n\n## TypeScriptのインストール\n\nプロジェクトにTypeScriptをインストールします。\n\n```shell\nyarn add -D typescript\n```\n\n次に、tsconfig.jsonを生成します。\n\n```shell\nyarn tsc --init\n```\n\n## Jestをインストールする\n\nJestをプロジェクトにインストールしましょう。インストールが必要なパッケージは、次の3つです。\n\n1. jest\n2. ts-jest\n3. @types/jest\n\nこれらのインストールは次のコマンドで、一度にインストールできます。\n\n```shell\nyarn add -D 'jest@^28.0.0' 'ts-jest@^28.0.0' '@types/jest@^28.0.0'\n```\n\n`jest`はJest本体です。JavaScriptだけのプロジェクトであれば、このパッケージを入れるだけでテストが始められます。`ts-jest`は、JestをTypeScriptに対応させるためのものです。`ts-jest`を入れると、TypeScriptで書いたテストコードを、コンパイルの手間なしにそのまま実行できるようになります。`@types/jest`はJestのAPIの型定義ファイルです。TypeScriptの型情報を付与されるので、テストコードの型チェックが行えるようになります。\n\n## Jestの設定ファイルを作る\n\nJestはそのままではTypeScriptを直接テストできません。なので、ここではJestでTypeScriptコードがテストできるように設定を加えます。\n\n次のコマンドを実行すると、Jestの設定ファイル`jest.config.js`が生成されます。\n\n```shell\nyarn ts-jest config:init\n```\n\n生成された`jest.config.js`の内容は次のようになります。\n\n```ts twoslash title=\"jest.config.js\"\n/** @type {import(\"ts-jest/dist/types\").InitialOptionsTsJest} */\nmodule.exports = {\n  preset: \"ts-jest\",\n  testEnvironment: \"node\",\n};\n```\n\nこの`@type`のコメントはエディターに型情報を与えるためのものです。これを書いておくことで、エディター上で入力補完が効くようになります。\n\n## チェックポイント\n\nここまでに作成したファイルに漏れがないか確認しましょう。\n\n```text\n├── jest.config.js ... Jestの設定ファイル\n├── node_modules ... jestやtypescriptがインストールされたフォルダ\n├── package.json\n├── tsconfig.json ... TypeScriptの設定ファイル\n└── yarn.lock\n```\n\n## Jestが動くかを確認する\n\nここでは、実際のテストコードを書く前に、Jestでテストコードが実行できる状態になっているかを、動作確認用のテストファイルを作って確かめます。\n\nJestで実行できるテストファイルには命名規則があります。ファイル名が`.test.ts`または`.spec.ts`で終わるものが、テストファイルになります。動作確認用のファイルとして、`check.test.ts`を作ってください。\n\n```shell\ntouch check.test.ts\n```\n\n`check.test.ts`の内容は次のようにします。\n\n```ts twoslash title=\"check.test.ts\"\n// @types: jest\ntest(\"check\", () => {\n  console.log(\"OK\");\n});\n```\n\nファイルを保存したら、`jest`コマンドを実行してみてください。\n\n```shell\nyarn jest\n```\n\nすると、次のような結果が出るはずです。\n\n![](/tutorials/jest/check-jest-works.svg)\n\n結果に`check.test.ts`が「PASS」と表示されていれば、テストファイルが実行されていることになります。\n\n問題なく実行されていることが確認できたら、`check.test.ts`は削除してください。\n\n```shell title=\"削除するコマンド\"\nrm check.test.ts\n```\n\n## このチュートリアルでテストする関数\n\nここからは、TypeScriptのテスト対象コードを書いて、それをテストしていきます。\n\n具体的には、次のような簡単な関数のテストを書くことを例に進めていきます。\n\n```ts twoslash\nfunction isZero(value: number): boolean {\n  return value === 0;\n}\n```\n\nこの`isZero`関数は、数値がゼロかどうかを判定するものです。\n\n## テスト対象のファイルを作る\n\nまず、この関数を書いたファイルを作ります。ファイル名は`isZero.ts`にしてください。\n\n```shell\ntouch isZero.ts\n```\n\nこのファイルを作ると、プロジェクトのファイル構成は次のようになります。\n\n```text\n├── isZero.ts ... テスト対象ファイル\n├── jest.config.js\n├── node_modules\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n`isZero.ts`の内容は次のようにします。\n\n```ts twoslash title=\"isZero.ts\"\nfunction isZero(value: number): boolean {\n  return value === 0;\n}\n// 注意: このままではテストできません。\n```\n\nこのままでは`isZero`関数はテストできません。Jestでテストできるようにするには、関数をエクスポートする必要があります。関数をエクスポートするために、`function`の前に`export`キーワードを追加してください。\n\n```ts twoslash title=\"isZero.ts\" {1}\nexport function isZero(value: number): boolean {\n  return value === 0;\n}\n```\n\n## テストコードを書く\n\n上の`isZero`関数をテストするコードを書きます。\n\nJestではテストコードはテスト対象と別のファイルに書きます。テストファイルを作りましょう。ファイル名は、テストしたいファイル名に、`.test.ts`をつけたものにします。テスト対象ファイルが`isZero.ts`なので、ここでは`isZero.test.ts`というファイル名にします。\n\n```shell\ntouch isZero.test.ts\n```\n\nこのファイルを作ると、プロジェクトのファイル構成は次のようになります。\n\n```text\n├── isZero.ts ... テスト対象ファイル\n├── isZero.test.ts ... テストコードのファイル\n├── jest.config.js\n├── node_modules\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n\nテスト対象の関数をテストコードで扱うには、まず関数をインポートする必要があります。`import`文を使って、`isZero`関数を読み込みましょう。\n\n```ts twoslash title=\"isZero.test.ts\"\n// @filename: isZero.ts\nexport function isZero(value: number): boolean {\n  return value === 0;\n}\n\n// @filename: isZero.test.ts\n// ---cut---\nimport { isZero } from \"./isZero\";\n```\n\n次に、1つ目のテストケースを追加します。このテストケースは、`isZero`関数に`0`を渡したら`true`が返るかをチェックするものです。\n\n```ts twoslash {3-5} title=\"isZero.test.ts\"\n// @types: jest\n// @filename: isZero.ts\nexport function isZero(value: number): boolean {\n  return value === 0;\n}\n\n// @filename: isZero.test.ts\n// ---cut---\nimport { isZero } from \"./isZero\";\n\ntest(\"0を渡したらtrueになること\", () => {\n  const result = isZero(0);\n  expect(result).toBe(true);\n});\n```\n\nJestでは`expect`関数とマッチャーを使い、結果が期待する値になっているかを記述します。マッチャーは、`expect`関数の戻り値に生えているメソッドです。上の例では、`toBe`がマッチャーになります。このメソッドの引数には期待値を書きます。上のテストケースでは、`true`が期待値なので、`toBe(true)`と記述しています。\n\n`toBe`マッチャーは、JavaScriptの厳密等価比較(`===`)と同じです。したがって、`expect(result).toBe(true)`は内部的に`result === true`かを評価します。もし、この評価が真なら、テストは合格します。逆に、偽ならテストは不合格となります。\n\nマッチャーは、`toBe`以外にもさまざまなものがあります。このチュートリアルでは細かく解説しないので、詳しく知りたい方は、[公式ドキュメントのリファレンス](https://jestjs.io/ja/docs/expect)をご覧ください。\n\n## テストを実行する\n\n1つ目のテストケースができたので、Jestでテストを実行してみましょう。\n\n```shell\nyarn jest\n```\n\nテスト結果は次のように表示されていれば、テストの実行ができています。\n\n![](/tutorials/jest/yarn-jest-isZero-1.svg)\n\n## テストケースを追加する\n\nさらにテストケースを追加してみましょう。今度は、`isZero`関数に`1`を渡して、戻り値が`false`になるかをチェックするケースを追加します。\n\n```ts twoslash {8-11} title=\"isZero.test.ts\"\n// @types: jest\n// @filename: isZero.ts\nexport function isZero(value: number): boolean {\n  return value === 0;\n}\n\n// @filename: isZero.test.ts\n// ---cut---\nimport { isZero } from \"./isZero\";\n\ntest(\"0を渡したらtrueになること\", () => {\n  const result = isZero(0);\n  expect(result).toBe(true);\n});\n\ntest(\"1を渡したらfalseになること\", () => {\n  const result = isZero(1);\n  expect(result).toBe(false);\n});\n```\n\nテストケースを追加したら、再びJestを実行し、テストコードを走らせます。\n\n```shell\nyarn jest\n```\n\n今度は次のような結果になるはずです。\n\n![](/tutorials/jest/yarn-jest-isZero-2.svg)\n\n以上でJestを体験してみるチュートリアルは完了です。\n",
      "url": "https://typescriptbook.jp/tutorials/jest"
    },
    {
      "title": "簡単な関数を作ってみよう",
      "content": "# 簡単な関数を作ってみよう\n\nこのチュートリアルではTypeScriptで簡単な関数を作る体験を通じて、TypeScriptの型がJavaScriptのどのような問題を解決するのか、コンパイラはどのような役割を果たすのかを学びます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルをやるに当たり、必要なツールがあります。次にリストアップするものを準備しておいてください。\n\n- Node.js\n- VS CodeやWebStormなどのエディター\n- tsc(TypeScriptコンパイラ)\n\n[開発環境の準備](./setup.md)\n\n## JavaScriptで発生しうる問題\n\nまず、次のJavaScriptファイルをローカル環境に作ります。\n\n```js title=\"increment.js\"\nfunction increment(num) {\n  return num + 1;\n}\n\nconsole.log(increment(999));\n```\n\nこのプログラムは引数をインクリメントして返すだけのものです。これをNode.jsで実行してみましょう。\n\n```sh\n$ node increment.js\n1000\n```\n\n問題なく動いたと思います。つづいて、`increment`関数の引数を`999`からstring型の`\"999\"`に書き換えてみましょう。\n\n```js title=\"increment.js\"\nfunction increment(num) {\n  return num + 1;\n}\n\nconsole.log(increment(\"999\"));\n//                    ^^^^^\n```\n\nこの小さな変更で実行結果は大きく変わってしまいます。実行してみましょう。\n\n```sh\n$ node increment.js\n9991\n```\n\n出力結果は1000から9991に変わったはずです。この理由は、引数`num`が文字列になったせいで、`+`演算子が足し算ではなく文字列結合になったからです。JavaScriptは`\"999\" + 1`を`\"999\" + \"1\"`と解釈します。この解釈の詳細を知るには型強制の説明をご覧ください。\n\n[型強制](../reference/values-types-variables/type-coercion.md)\n\n引数は`999`と`\"999\"`という型の微妙な違いだけです。もしもこれが金額の計算だったら大問題です。`increment`関数は引数`num`がnumber型のときだけ正しい動きをします。しかし、関数を呼び出すときは、制約なしにさまざまな型を渡せてしまいます。引数にnumber型のみ代入できるように制約するには、どのようにしたらよいのでしょうか。ここでTypeScriptの出番になります。\n\n## JavaScriptをTypeScriptに変換する\n\nJavaScriptをTypeScriptにする第一歩は、ファイルの拡張子を`.js`から`.ts`に変更することです。TypeScriptはざっくり言って、JavaScriptに型関連の構文を追加したにすぎない言語です。なので、JavaScriptのコードはそのままでもTypeScriptとして扱えます。\n\n```sh\nmv increment.js increment.ts\n```\n\n## コンパイラを働かせる\n\nTypeScriptの目玉機能はなんと言ってもコンパイラです。コンパイラの役割のひとつは、上例のような型の問題をチェックし、発見した問題点をプログラマに報告することです。TypeScriptコンパイラはとても賢く、ノーヒントでも型の問題を指摘してくれます。しかし、ヒントを十分に与えたほうが、コンパイラはもっと緻密なチェックをしてくれます。\n\nコンパイラに与えるヒントのことを「型注釈(type annotation)」と言います。それでは、`increment`関数の引数`num`に型注釈を書いてみましょう。型注釈は`num`の右に`: number`と書きます。これを書くことで「引数`num`はnumber型だけが代入できます」という意味になります。コンパイラはこれをヒントに関数呼び出しコードをチェックするようになります。\n\n<!--prettier-ignore-->\n```ts twoslash {1,2} title=\"increment.ts\"\n// @noErrors\nfunction increment(num: number) {\n//                 ^^^^^^^^型注釈\n  return num + 1;\n}\n\nconsole.log(increment(\"999\"));\n```\n\n型注釈を書いたら、TypeScriptコンパイラにチェックをさせてみましょう。TypeScriptコンパイラのコマンドは`tsc`です。\n\n```sh\ntsc increment.ts\n```\n\nすると、次のエラーが報告されるはずです。\n\n```ts twoslash {1,2}\n// @errors: 2345\nfunction increment(num: number) {\n  return num + 1;\n}\n// ---cut---\nconsole.log(increment(\"999\"));\n```\n\nこのエラーの内容は、「引数`num`はnumber型しか代入できないはずだが、関数呼び出しではstring型を代入している。本当に問題ないか？」という指摘です。\n\nエラーというと望まれないものというイメージがあるかもしれません。しかし、コンパイラが報告するエラーはむしろ歓迎されるものです。なぜなら、自分の代わりにコードに潜んでいる危険を、コーディング時点で知らせてくれるからです。\n\n## コンパイルを通す\n\nコンパイラが指摘する問題点をすべて解消する作業のことを「コンパイルを通す」といいます。上のコードをコンパイルが通るコードに直してみましょう。直し方は単純に、関数呼び出しの引数をnumber型にするだけです。\n\n```ts twoslash {5} title=\"increment.ts\"\nfunction increment(num: number) {\n  return num + 1;\n}\n\nconsole.log(increment(999));\n//                    ^^^直す箇所\n```\n\n直したら再びコンパイルしてみましょう。\n\n```sh\ntsc increment.ts\n```\n\n今度は何も表示されずに処理が終わるはずです。コンパイル成功です。\n\n## 生成されたJavaScript\n\nここまでの手順で、increment.jsというファイルができていることに気づいたかもしれません。そのファイルの内容は次のようになっていると思います。\n\n```ts twoslash title=\"increment.js\"\n// @showEmit\n// @alwaysStrict: false\nfunction increment(num: number) {\n  return num + 1;\n}\n\nconsole.log(increment(999));\n```\n\nこれは、increment.tsをコンパイルする過程でコンパイラが生成したJavaScriptファイルです。TypeScriptのコードと比べてみると、引数`num`から型注釈が取り除かれていることがわかります。\n\n型注釈の部分はTypeScript固有のものです。それが書いてあるとブラウザやNode.jsでは実行できません。なので、TypeScriptコンパイラはJavaScript実行環境で動かす用のJavaScriptファイルを生成してくれます。開発者はこの成果物のJavaScriptファイルを本番環境にデプロイすることになります。\n\n<PostILearned>\n\n・JavaScriptからTypeScriptへの書き換えは拡張子を.tsにする\n・コンパイラは型の問題を教えてくれる\n・型注釈を書き加えると、コンパイラはより細かいチェックをしてくれる\n・コンパイラが生成したJSをデプロイして使う\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/tutorials/make-a-simple-function-via-cli"
    },
    {
      "title": "開発環境の準備",
      "content": "---\ndescription: TypeScriptの開発に必要になるNode.jsとTypeScriptコンパイラ、エディタをインストールしましょう。\n---\n\n# 開発環境の準備\n\n## Node.jsとは\n\nNode.jsは、JavaScriptをサーバーサイドで動かすことを目的に開発されたソフトウェアです。Node.jsはGoogle ChromeのJavaScriptエンジンと同じ「V8」でJavaScriptを実行します。\n\nNode.jsにはGoogle Chromeと同じJavaScriptエンジンが乗っていると言っても、組み込みのAPIは異なります。ブラウザはJavaScriptからHTMLを操作する必要があるのでDOM APIがありますが、Node.jsにはありません。代わりにNode.jsには、サーバーサイドのさまざまなリソースを制御する必要があるので、ファイルシステムにアクセスするAPIやHTTPサーバーを建てるためのAPI、プロセスを起動したり終了したりするAPIなどがあります。\n\nNode.jsの典型的な用途は、サーバーサイドアプリケーションの開発です。たとえば、ウェブサービスのバックエンドなどです。最近のフロントエンド開発でも、Node.jsが必要になってきています。なぜかというと、開発で使うツールをNode.jsで動かす必要があるからです。TypeScriptでの開発も、TypeScriptコンパイラ(tsc)を動かすのにNode.jsが必要になります。\n\n## Node.jsのインストール\n\nNode.jsは公式サイトからダウンロードしてインストールすることもできますが、もっとも手軽な方法はHomebrewを使ったインストールです。\n\n```shell\nbrew install node@16\n```\n\nインストールが完了したらシェルの環境変数`PATH`にNode.jsのパスを追加します。\n\n```shell\necho 'export PATH=\"/usr/local/opt/node@16/bin:$PATH\"' >> ~/.zshrc\n```\n\nパスを追加したらターミナルを再起動し、環境変数を反映させてください。\n\n`node -v`でバージョンが表示されるかを見て、`node`コマンドが実行できるかを確かめてください。\n\n```shell\nnode -v\n# v16.13.0\n```\n\n## TypeScriptをインストールする\n\nお使いのターミナルからTypeScriptコンパイラをインストールします。\n\n```shell\nnpm install -g typescript\n```\n\n`tsc`コマンドが実行できるか`tsc -v`コマンドで確認します。\n\n```shell\ntsc -v\n# Version 4.5.5\n```\n\n表示されたバージョンはインストール時の最新バージョンになります。上の例は執筆時のバージョンなので、これと異なっていても問題ありません。\n\n## エディター・IDE\n\nTypeScriptの開発にお勧めエディター・IDEはVisual Studio CodeまたはJetBrains IDEです。\n\n### Visual Studio Code\n\nVisual Studio Code(VS Code)は、Microsoftが提供する無料でオープンソースのIDEです。Windows、Mac、Linuxに対応しています。このIDE自体もTypeScriptで実装されています。\n\nhttps://code.visualstudio.com/download\n\n### JetBrains IDE\n\nJetBrains IDEはJetBrains社が提供する有償のIDEシリーズです。Windows、Mac、Linuxで使えます。JetBrains IDEシリーズはプログラミング言語ごとに最適化された個別のIDEが提供されています。TypeScript専用のIDEはありませんが、次にあげるIDEはTypeScriptにしっかり対応しています。\n\n- [IntelliJ IDEA Ultimate](https://www.jetbrains.com/idea/) (基本はJava向けIDEだが、JSやPHP、Ruby、Goなども扱える)\n- [WebStorm](https://www.jetbrains.com/webstorm/) (JavaScript向けIDE)\n- [PhpStorm](https://www.jetbrains.com/phpstorm/) (PHP向けIDE)\n- [RubyMine](https://www.jetbrains.com/ruby/) (Ruby向けIDE)\n- [PyCharm](https://www.jetbrains.com/pycharm/) (Python向けIDE)\n- [GoLand](https://www.jetbrains.com/go/) (Go向けIDE)\n\nフロントエンドの開発のみを予定している場合、最安のWebStormで十分です。バックエンドとフロントエンドの両方を開発する場合は、PhpStorm、RubyMine、PyCharm、GoLandの中からバックエンド言語に合ったものを選ぶとよいでしょう。さまざまな言語を使う予定がある場合、ハイエンドのIntelliJ IDEA Ultimateを選ぶと網羅的になります。JetBrains IDEシリーズには無償版IntelliJ Community Edition(CE)がありますが、これはTypeScriptには対応していません。\n\nJetBrains IDEには、30日間のフリートライアルと、学生は無料で使える[無料ライセンスプログラム](https://www.jetbrains.com/community/education/#students)もあります。\n\n日本の販売代理店の株式会社サムライズムからは、[300円から1,000円の割引](https://secure.samuraism.com/referral/8BF59FFA232F45460DFA1635194C68B6)で購入することもできます。\n",
      "url": "https://typescriptbook.jp/tutorials/setup"
    },
    {
      "title": "Reactコンポーネントのテストを書こう",
      "content": "# Reactコンポーネントのテストを書こう\n\nこのチュートリアルでは、Reactコンポーネントのテストを書くことを学びます。\n\n## 本章で学べること\n\n本章では、簡単なコンポーネントのテストを書くことを目標に、具体的には次のことをやっていきます。\n\n- UIテストのためのライブラリ群`testing-library`を使ったテストの作成\n- `Jest`を使ったスナップショットテストの作成\n\n本章の目的はコンポーネントのテストを完全に理解することではありません。むしろ、それがどういったものなのか、その雰囲気を実際に体験することに主眼を置いています。そのため、内容はかなり最低限のものとなりますが、逆に言えば少しの時間でコンポーネントテストを試してみれるシンプルな内容にまとまってますから、ぜひ手を動かしてみてください。\n\n:::info\nReactでコンポーネントが作れることを前提にしますので、Reactの基本的な使い方を知りたいという方は[Reactでいいねボタンを作ろう](./react-like-button-tutorial.md)をご参照ください。\n:::\n\nこのチュートリアルで作成するテストコードの完成形は[GitHub](https://github.com/yytypescript/component-test-tutorial/blob/main/src/SimpleButton.test.tsx)で確認することができます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルをやるに当たって、必要なツールがあります。それらはここにリストアップしておくのであらかじめ用意しておいてください。\n\n- Node.js (このチュートリアルではv18.15.0で動作確認しています)\n- NPM\n- Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)\n\nNode.jsの導入については、[開発環境の準備](./setup.md)をご覧ください。\n\nパッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```shell\nnpm install -g yarn\n```\n\n## Reactプロジェクトの作成\n\nテストに使用するためのReactプロジェクトを作成します。下記コマンドを実行してください。\n\n```shell\nyarn create react-app component-test-tutorial --template typescript\n```\n\n成功すると今いるディレクトリ配下に`component-test-tutorial`というディレクトリが作られます。そのまま下記コマンドを実行して`component-test-tutorial`に移動しましょう。\n\n```shell\ncd component-test-tutorial\n```\n\n`component-test-tutorial`配下のファイル構成は次のようになっているはずです。\n\n```text\n├── .gitignore\n├── node_modules\n├── README.md\n├── package.json\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n├── src\n│   ├── App.css\n│   ├── App.test.tsx\n│   ├── App.tsx\n│   ├── index.css\n│   ├── index.tsx\n│   ├── logo.svg\n│   ├── react-app-env.d.ts\n│   ├── reportWebVitals.ts\n│   └── setupTests.ts\n├── tsconfig.json\n└── yarn.lock\n```\n\nここで次のコマンドを実行してください。\n\n```shell\nyarn start\n```\n\n自動的にブラウザが開かれて次の画像のように表示されれば、プロジェクト作成が成功しています。\n\n![ひながた初期状態の画面](react-like-button-tutorial/screen1.png)\n\n## テストするコンポーネント\n\nここでは、簡単なボタンコンポーネントのテストを書くことを例に進めていきます。具体的には、はじめは`OFF`となっているボタン上の文字が、ボタンをクリックするたびに`ON`/`OFF`と切り替わるようなボタンを題材にします。\n\n![ボタン上の文字がクリックによってON,OFFと切り替わる様子](component-test/simpleButton.gif)\n\nこのコンポーネントについて、ボタンをクリックすると`ON`/`OFF`の表示が切り替わることをテストしましょう。\n\n## テスト対象のコンポーネントを作る\n\nテストを作成するために、まずはテスト対象となるコンポーネントを実装していきます。`src`ディレクトリ配下に、`SimpleButton.tsx`という名前でファイルを作成してください。\n\n```shell\ncd src\ntouch SimpleButton.tsx\n```\n\nこのファイルを作ると、`src`ディレクトリのファイル構成は次のようになります。\n\n```text\n├── App.css\n├── App.test.tsx\n├── App.tsx\n├── SimpleButton.tsx\n├── index.css\n├── index.tsx\n├── logo.svg\n├── react-app-env.d.ts\n├── reportWebVitals.ts\n└── setupTests.ts\n```\n\n`SimpleButton.tsx`の内容は次のようにします。\n\n```tsx twoslash title=\"SimpleButton.tsx\"\n// @noErrors\nimport { useState } from \"react\";\n\nexport const SimpleButton: () => JSX.Element = () => {\n  const [state, setState] = useState(false);\n  const handleClick = () => {\n    setState((prevState) => !prevState);\n  };\n  return <button onClick={handleClick}>{state ? \"ON\" : \"OFF\"}</button>;\n};\n```\n\nここで、この`SimpleButton`コンポーネントの挙動を確認してみましょう。`index.tsx`ファイルを次のようにして保存してください。\n\n```tsx twoslash title=\"index.tsx\"\n// @noErrors\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport { SimpleButton } from \"./SimpleButton\";\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\") as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <SimpleButton />\n  </React.StrictMode>\n);\n```\n\nそのうえで下記コマンドを実行しましょう。\n\n```shell\nyarn start\n```\n\nすると、ブラウザが自動で立ち上がり、次のようなボタンが表示されます。初めは`OFF`と表示され、クリックにより`ON`と`OFF`が交互に切り替わることを確認してください。\n\n![ボタン上の文字がクリックによってON,OFFと切り替わる様子](component-test/simpleButton.gif)\n\n:::info\nボタンが小さければ、ブラウザの拡大率を上げてみると大きく表示されます。\n:::\n\nこれで今回テストするコンポーネントを作成できました。\n\n## `testing-library`を使ったテストの作り方とやり方\n\nここからはテストの作り方とやり方に入ります。今回は、ボタンをクリックすると`ON`/`OFF`の表示が切り替わることをテストしていきます。\n\nReactコンポーネントをテストする方法は複数ありますが、ここでは利用者が比較的多い`testing-library`というライブラリ群を用いる方法を紹介します。`testing-library`はUIコンポーネントのテストをするためのライブラリ群であり、コンポーネントの描画やコンポーネントに対する操作などが実現できます。`testing-library`があれば、コンポーネントのテストはひととおりできると考えてよいでしょう。\n\n### testing-libraryをインストールする\n\n次のコマンドを実行してtesting-libraryをインストールしてください。\n\n```shell\nyarn add \\\n  @testing-library/react@14 \\\n  @testing-library/jest-dom@5 \\\n  @testing-library/user-event@14\n```\n\n### テストを作る\n\nそれでは、実際に`testing-library`を使ってテストを作っていきましょう。まずは先ほどと同じ`src`ディレクトリ配下で`SimpleButton.test.tsx`というファイルを作成します。\n\n```shell\ntouch SimpleButton.test.tsx\n```\n\nこのファイルに、テストを実行するためのひな形を書きます。\n\n```tsx twoslash title=\"SimpleButton.test.tsx\"\n// @noErrors\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  // ここにテストの中身を書いていきます\n});\n```\n\nここにテストの中身を追加していきます。今回はボタンをクリックすると`ON`/`OFF`の表示が切り替わることがテストしたいので、次のような流れのテストコードになります。\n\n1. ボタンを描画する\n2. `OFF`と表示されていることを確かめる\n3. ボタンをクリックする\n4. `ON`と表示されていることを確かめる\n\n:::info\nコンポーネントのテストは、コンポーネントを描画した後、次の2つのことを組み合わせて実現されます。\n\n1. コンポーネントに操作を施す\n2. コンポーネントの状態を確かめる\n\n今回の例もボタンを描画した後、「`OFF`と表示されている」という状態確認から始まり、「クリック」という操作を施した後、再び「`ON`と表示されている」という状態確認をします。みなさんが自分でコンポーネントのテストを書く際も、どのような操作と状態確認を行えばよいかを意識することでテスト作成がスムーズにできるはずです。\n:::\n\nまずはボタンを描画してみましょう。コンポーネントの描画は`@testing-library/react`の`render()`を使って、次のようにするだけです。なお、この`@testing-library/react`というライブラリは、今回`yarn create react-app`でReactアプリケーションを作成したためすでにプロジェクトにインストールされています。\n\n```tsx twoslash {1,2,5} title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render } from \"@testing-library/react\";\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  render(<SimpleButton />);\n});\n```\n\nボタンが描画されたので、次は`OFF`と表示されていることを確かめます。具体的には、ボタンのDOM(DOMとは、ここではボタンを表すオブジェクトくらいに捉えていただければ大丈夫です)を取得し、そのテキストが`OFF`という文字列に等しいかのアサーションを実施します。今回、ボタンのDOMの取得には`@testing-library/react`が提供するクエリのひとつである`getByRole()`を使います。これは[WAI-ARIA](https://developer.mozilla.org/ja/docs/Learn/Accessibility/WAI-ARIA_basics)(アクセシビリティ向上を主目的として定められたwebの仕様)で定められたRoleを引数に指定すると、そのRoleを持つコンポーネントを取得するクエリです。詳細は[公式ドキュメント](https://testing-library.com/docs/queries/byrole)をご参照ください。具体的には、このように書けます。\n\n```tsx twoslash {1-2,7} title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render, screen } from \"@testing-library/react\";\n//               ^^^^^^追加\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  render(<SimpleButton />);\n  const simpleButton = screen.getByRole(\"button\");\n});\n```\n\nそして、ボタンのテキストのアサーションは`@testing-library/jest-dom`が提供する`toHaveTextContent()`を使います。`expect()`にコンポーネントを渡し、そのまま`toHaveTextContent()`を呼び出すと、そのコンポーネントがどのようなテキストを持っているかのアサーションが行なえます。具体的には次のようになります。\n\n```tsx twoslash {7} title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render, screen } from \"@testing-library/react\";\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  render(<SimpleButton />);\n  const simpleButton = screen.getByRole(\"button\");\n  expect(simpleButton).toHaveTextContent(\"OFF\");\n});\n```\n\nここで一旦`yarn test`コマンドでテストを実行し、テストが通ることを確認しましょう。\n\n```shell\nyarn test\n```\n\n次のような結果になるはずです。\n\n![テストがPASSしているコンソールの画面](component-test/result_pass2.png)\n\nさて、次にボタンをクリックします。コンポーネントの操作は`testing-library`に収録されている`@testing-library/user-event`を使って実現できます。`@testing-library/user-event`はコンポーネントの操作を含む、色々なユーザーイベントをテストで実行するライブラリです。具体的には`click()`にクエリでみつけた`simpleButton`を引数として渡すことで、ボタンのクリックを実現できます。\n\n```tsx twoslash {2,6,10} title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  const user = userEvent.setup();\n  render(<SimpleButton />);\n  const simpleButton = screen.getByRole(\"button\");\n  expect(simpleButton).toHaveTextContent(\"OFF\");\n  await user.click(simpleButton);\n});\n```\n\n続けて、ボタンがクリックされた後のアサーションを実施します。先ほどと同様に`toHaveTextContent()`を用いますが、今度はボタンのテキストが`ON`になっていることを確認しましょう。\n\n```tsx twoslash {11} title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"ボタンをクリックするとON/OFFの表示が切り替わる\", async () => {\n  const user = userEvent.setup();\n  render(<SimpleButton />);\n  const simpleButton = screen.getByRole(\"button\");\n  expect(simpleButton).toHaveTextContent(\"OFF\");\n  await user.click(simpleButton);\n  expect(simpleButton).toHaveTextContent(\"ON\");\n});\n```\n\nこの状態で`yarn test`コマンドでテストを実行し、テストが通ることを確認しましょう。次のような結果になるはずです。\n\n![テストがPASSしているコンソールの画面](component-test/result_pass2.png)\n\n以上が、`testing-library`を用いてコンポーネントのテストを作成する流れです。`testing-library`からは、ここで紹介したもの以外にも多くのクエリやアサーション、ユーザーイベントの機能が提供されています。英語にはなってしまいますが、クエリは[こちら](https://testing-library.com/docs/queries/about)、アサーションは[こちら](https://github.com/testing-library/jest-dom#custom-matchers)、ユーザーイベントは[こちら](https://testing-library.com/docs/user-event/intro)に公式ドキュメントによる詳細な説明があります。実際に自分でテストを作る際には、ぜひそれらも確認してみてください。\n\n## `Jest`を使ったスナップショットテストの作り方とやり方\n\nここからは「スナップショットテスト」と呼ばれるテスト手法について解説します。\n\n先ほどまでのテストはコンポーネントのある部分(例: テキスト)の状態を確認するものでしたが、「スナップショットテスト」はコンポーネントの全体の状態を確かめるためのテストです。より正確には、コンポーネントのDOMをまるごと保存し、その保存したDOMと、テスト実行時にコンポーネントを描画して生成したDOMとが一致するかを確認します(DOMとは何かがよく分からない場合、ここではひとまず「コンポーネントを表すオブジェクト」程度に捉えてください)。\n\n「スナップショットテスト」は簡単に書くことができます。それでいてスタイルなど含めた全体の確認ができるので、手軽なリグレッションテストとして活用できます。一方で、そうであるからこそコンポーネントを一旦作り終えるまでは機能しないテストですので、テストファーストの開発には不向きです。\n\n:::caution\n本来、スナップショットテストの対象はコンポーネントおよびDOMに限られたものではありません。幅広い対象にスナップショットテストが実施できます。詳しくはJestの[公式ドキュメント](https://jestjs.io/ja/docs/snapshot-testing#%E3%82%B9%E3%83%8A%E3%83%83%E3%83%97%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AFreact%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%A7%E3%81%AE%E3%81%BF%E5%88%A9%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%81%8B)をご参照ください。\n:::\n\nそれでは、スナップショットテストを実際にやってみましょう。先ほどと同じ`src`ディレクトリ配下で`SimpleButton.test.tsx`というファイルを作成します。\n\n```shell\ntouch SimpleButton.test.tsx\n```\n\n:::info\n「`testing-library`を使ったテストの作り方とやり方」から続けてこのチュートリアルを実施される方は、ここから作成するテストケースを`SimpleButton.test.tsx`内に追加で書いていくのでも大丈夫です。\n:::\n\nスナップショットテストは次の2ステップから成ります。\n\n1. スナップショットを検証したい状態にコンポーネントを持っていく\n2. スナップショットに照合する\n\nここではボタンが描画されてまだ何も操作されていない状態、つまりボタンにOFFと表示されている状態についてスナップショットテストを実施することを考えます。描画されたばかりの状態を検証したいので、描画してすぐにスナップショット照合を行えばよいことになります。\n\nこの考えをもとに、実際のコードを書いてみましょう。コンポーネントの描画には`@testing-library/react`の`render`関数を、スナップショットの照合にはJestの`toMatchSnapshot()`関数をそれぞれ使用して次のように書くことができます。\n\n```tsx twoslash title=\"SimpleButton.test.tsx\"\n// @noErrors\nimport { render } from \"@testing-library/react\";\nimport { SimpleButton } from \"./SimpleButton\";\n\ntest(\"描画されてすぐはOFFと表示されている\", () => {\n  const view = render(<SimpleButton />);\n  expect(view.container).toMatchSnapshot();\n});\n```\n\n:::info\nJest単体ではReactコンポーネントの描画ができません。そこで、コンポーネントの描画をするためのライブラリを使用する必要があります。多くのライブラリがありますが、ここでは前章「`testing-library`を使ったテストの作り方とやり方」でも紹介した`@testing-library/react`を用いました。\n:::\n\nテストファイルが作成できたら、`yarn test`コマンドを実行します。\n\n```shell\nyarn test\n```\n\nそうすると次のように表示され、テストが実行されて成功した(`PASS`した)ことがわかります。\n\n![SimpleButtonコンポーネントのテストがPASSした結果画面](component-test/result_pass.png)\n\nさて、このとき`src`ディレクトリの中に`__snapshots__`というディレクトリが自動で追加されているはずです。これはJestがスナップショットテスト用のファイルを保存していくためのフォルダです。Jestのスナップショットテストは初回実行時にスナップショットテスト用のファイルを生成し、2回目から照合を行います。いまは初回実行だったため、ファイルとその置き場であるディレクトリが自動で生成されました。\n\nここでスナップショットテストについてもう少しだけ知るために、生成されたスナップショットテスト用のファイルの中身を覗いてみましょう。\n\n`__snapshots__`ディレクトリの中に作られた`SimpleButton.test.tsx.snap`は次のようになっています。\n\n```js twoslash title='SimpleButton.test.tsx.snap'\n// @noErrors\n// Jest Snapshot v1, https://goo.gl/fbAQLP\nexports[`描画されてすぐはOFFと表示されている 1`] = `\n<div>\n  <button>\n    OFF\n  </button>\n</div>\n`;\n```\n\nこのように、スナップショットテスト用のファイルはテストケースの名前と、そのテストケースで使われるスナップショットで構成されています。\n\nさて、今回生成されたスナップショットは`OFF`というテキストを持った`button`タグと、その親要素である`div`タグで構成されています。これは、まさに先ほど作った`SimpleButton`コンポーネントのDOMに一致します(`div`要素はReactの起動時に自動生成される要素です)。このスナップショットテストは実行のたびに、`SimpleButton`コンポーネントを描画して、たった今作られたこのスナップショットとの違いが生まれていないかを確認してくれます。\nたとえば、もしも何かの手違いで`SimpleButton`コンポーネントが描画されたときに`ON`と表示されるようになっていたら、このスナップショットテストに引っかかるのです。\n\nここで、実際に失敗する様子も確認してみましょう。`SimpleButton`コンポーネントが描画されたときに`ON`と表示されるよう変更を加えます。\n\n```tsx twoslash {4,5} title=\"SimpleButton.tsx\"\nimport { useState } from \"react\";\n\nexport const SimpleButton: () => JSX.Element = () => {\n  const [state, setState] = useState(true);\n  // falseからtrueに変更               ^^^^\n  const handleClick = () => {\n    setState((prevState) => !prevState);\n  };\n  return <button onClick={handleClick}>{state ? \"ON\" : \"OFF\"}</button>;\n};\n```\n\nこの状態で`yarn start`コマンドを実行すると、描画されたボタンの文字の初期値が`ON`になっていることが分かります。\n\nさて、ここで`yarn test`コマンドを実行します。\n\n```shell\nyarn test\n```\n\n先ほどのスナップショットテストが実行されますが、今回はテストが通らず、描画されたコンポーネントとスナップショットの差分が表示されます。\n\n![SimpleButtonコンポーネントのテストがFAILし、描画されたコンポーネントとスナップショットの差分が表示されている結果画面](component-test/result_fail.png)\n\n今回はボタン内テキストの初期値を変更しましたが、たとえば`button`タグから`div`タグへの変更や`button`タグへのクラスの追加など、DOMに対する変更のほとんどをスナップショットテストで検知できます。\n\nスナップショットテストの詳しいやり方やベストプラクティスなど、さらに詳しい情報に触れたい方はJestの[公式ドキュメント](https://jestjs.io/ja/docs/snapshot-testing)をご参照ください。\n\n以上でJestを使ったスナップショットテストのチュートリアルは完了です。また、Reactコンポーネントのテストのチュートリアルも完了です。\n",
      "url": "https://typescriptbook.jp/tutorials/component-test"
    },
    {
      "title": "Next.jsで猫画像ジェネレーターを作ろう",
      "content": "# Next.jsで猫画像ジェネレーターを作ろう\n\n## Next.jsの概要\n\n[Next.js](https://nextjs.org/)は、オープンソースのUIライブラリReactをベースにしたフロントエンドフレームワークです。\n\nReactで開発する場合、webpackのようなバンドラーを用いるのが普通です。webpackの設定ファイルを記述するには、一定の知識が必要です。特に、チャンク分割やCSSモジュールの設定は複雑だったりと、設定ファイルのメンテナンスが大変です。Next.jsは、webpackの設定があらかじめなされた状態で開発が始められるようになっています。\n\nNext.jsはルーティング時のプリフェッチや画像の最適化などのパフォーマンス最適化をフレームワーク内で内包しており、ゼロコンフィグで簡単にパフォーマンスの高いアプリケーションを構築することができます。ページ単位のサーバーサイドレンダリング(SSR)や静的サイト生成(SSG)の機能も提供しており、用途に合わせて柔軟にアーキテクチャを選択できるのも特徴です。\n\nNext.jsはVercel社が開発しています。同社は[Vercel](https://vercel.com/)というホスティングサービスを提供しているので、Next.jsで構築したアプリケーションは簡単に公開できます。\n\n## これから作るもの\n\nこのチュートリアルでは、題して「猫画像ジェネレーター」です。どんなものかというと、ボタンを押したら、猫画像のAPIから画像のURLを取得し、ランダムに可愛い猫画像を表示するシンプルなウェブアプリケーションです。\n\n<video width=\"600\" controls=\"controls\" loop=\"controls\" autoPlay=\"autoplay\" muted=\"muted\" playsInline=\"playsinline\">\n  <source src=\"/tutorials/nextjs/demo.mp4\" type=\"video/mp4\" />\n</video>\n\n最終的な成果物は[デモサイト](https://random-cat.typescriptbook.jp/)で確認できます。チュートリアルを開始する前に事前に触ってみることで、各ステップでどんな実装をしているかのイメージが掴みやすくなります。また、完成形のソースコードは[GitHub](https://github.com/yytypescript/random-cat)で確認することができます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルで必要なものは次のとおりです。\n\n- Node.js v16以上\n- Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)\n- ブラウザ (このチュートリアルではGoogle Chromeを想定しています)\n\nNode.jsの導入については、[開発環境の準備](./setup.md)をご覧ください。\n\nパッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```shell\nnpm install -g yarn\n```\n\n## Next.jsをセットアップする\n\n最初に`yarn create next-app`コマンドでプロジェクトを作成します。TypeScriptをベースにしたプロジェクトを作成するために `--example with-typescript` を指定します。`random-cat` はリポジトリ名となる部分です。この部分は好きな名前でも構いませんが、本チュートリアルでは`random-cat`として話を進めます。\n\n```sh\nyarn create next-app --example with-typescript random-cat\n```\n\nこのコマンドを実行すると、`random-cat`ディレクトリが作成されるので、そのディレクトリに移動してください。\n\n```sh\ncd random-cat\n```\n\nプロジェクトのファイル構成が次のようになっているか確認してください。\n\n```text\n.\n├── components ---- ディレクトリ\n├── interfaces ---- ディレクトリ\n├── node_modules -- ディレクトリ\n├── pages --------- ディレクトリ\n├── utils --------- ディレクトリ\n├── README.md\n├── next-env.d.ts\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n## 開発サーバーを起動する\n\n次のコマンドを実行して、開発サーバーを起動してください。\n\n```sh\nyarn dev\n```\n\n開発サーバーが起動したら、ターミナルに表示されているURLにブラウザでアクセスしてください。\n\n## 不要なファイルを消す\n\nチュートリアルを進める前に、ここでは使わないファイルを削除します。プロジェクトをシンプルな状態にして、作業を進めやすくしましょう。\n\n```sh\nrm -rf pages utils interfaces components\n```\n\n## ページコンポーネントディレクトリを作る\n\nNext.jsでは、`pages`ディレクトリ配下のディレクトリ構造がページのルーティングに対応します。たとえば、pages/users.tsxとファイルを作成すると、`/users`へアクセスしたとき、それが実行されます。pages/index.tsxの場合は、`/` へアクセスしたときに実行されます。\n\nこの`pages`ディレクトリに置かれたコンポーネントのことを、Next.jsの用語でページコンポーネント(page component)と呼びます。\n\n次のコマンドを実行してページコンポーネントを置くためのディレクトリを作成してください。\n\n```sh\nmkdir pages\n```\n\n## トップページのページコンポーネントを作る\n\n次のコマンドを実行して、トップページのページコンポーネントを作成してください。\n\n```sh\ntouch pages/index.tsx\n```\n\nページコンポーネントの内容は、次のようにします。この`IndexPage`関数がページコンポーネントです。これは「猫画像予定地」が表示されるだけの単純なものです。\n\n```tsx twoslash title=\"pages/index.tsx\"\nimport { NextPage } from \"next\";\n\nconst IndexPage: NextPage = () => {\n  return <div>猫画像予定地</div>;\n};\nexport default IndexPage;\n```\n\nNext.jsでは、1ファイルにつき1ページコンポーネントを作成します。Next.jsは`pages`ディレクトリの各`tsx`ファイルを読み込み、デフォルトエクスポートされた関数をページコンポーネントとして認識します。上のコードで`IndexPage`関数を`export default`にしているのは、Next.jsにページコンポーネントと認識させるためです。`NextPage`はページコンポーネントを表す型です。この型を注釈しておくと、関数の実装がページコンポーネントの要件を満たしているかがチェックできます。\n\nコンポーネントを実装したら、ブラウザをリロードして画面に「猫画像予定地」と表示されているか確認してください。\n\n<!-- todo: 画像 -->\n\n:::info Next.jsではアロー関数を使うべきですか？\n\nJavaScriptで関数を作るには、大きく分けて[アロー関数と関数宣言を使った方法の2種類](../reference/functions/function-expression-vs-arrow-functions.md)があります。上で書いた`IndexPage`関数はアロー関数です。これを関数宣言に書き換えると次のようになります。\n\n```tsx twoslash\nimport { ReactElement } from \"react\";\n\nexport default function IndexPage(): ReactElement<any, any> | null {\n  return <div>猫画像予定地</div>;\n}\n```\n\nNext.jsでは、アロー関数と関数宣言のどちらで書いても構いません。このチュートリアルでアロー関数を採用しているのは、ページコンポーネントに`NextPage`型の型注釈をつけるのが、アロー関数のほうがやりやすいためです。\n\n:::\n\n## The Cat API\n\nこのチュートリアルでは猫の画像をランダムに表示するにあたり[The Cat API](https://thecatapi.com/)を利用します。このAPIは特定の条件で猫の画像を取得したり、品種ごとの猫の情報を取得することができます。今回のチュートリアルでは[APIドキュメント](https://docs.thecatapi.com/)のQuickstartに記載されている`/v1/images/search`へリクエストを投げてランダムな猫の画像を取得します。\n\n試しにブラウザで<https://api.thecatapi.com/v1/images/search>へアクセスしてみてください。ランダムな結果が返ってくるので値は少し違いますが、次のような構造のデータがレスポンスとして取得できます。レスポンスのデータ構造が配列になっている点に注意してください。\n\n```json title=\"The Cat APIのレスポンスのサンプル\"\n[\n  {\n    \"id\": \"co9\",\n    \"url\": \"https://cdn2.thecatapi.com/images/co9.jpg\",\n    \"width\": 900,\n    \"height\": 600\n  }\n]\n```\n\nレスポンスにある`url`が猫画像のURLです。この値を取得して猫の画像をランダムに表示します。\n\n## 画像を取得する関数を実装する\n\nこのステップでは、The Cat APIにリクエストし猫画像を取得する関数を実装します。次の実装をした`fetchImage`関数を`export default IndexPage`の後ろに追加してください。\n\n```ts twoslash\nconst fetchImage = async () => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n```\n\n`fetch`はHTTPリクエストでリソースを取得するブラウザ標準のAPIです。戻り値として[Response](https://developer.mozilla.org/ja/docs/Web/API/Response)オブジェクトを返します。Responseオブジェクトの`json()`メソッドを実行することで、レスポンスのボディーをJSONとしてパースし、JavaScriptのオブジェクトとして取得できます。\n\n`fetchImage`関数についている[`async`キーワード](/reference/asynchronous/async)は、この関数が非同期処理を行うことを示すものです。`fetch`と`res.json`は非同期関数で、これらの処理を待つために、それぞれに[`await`キーワード](/reference/asynchronous/await)がついています。\n\n<!-- todo: async/awaitのリライトが完了したらリンク先を変更する -->\n\n`fetchImage`関数がAPIを呼び出せているかテストするために、これを呼び出す処理を`fetchImage`関数の後ろに追加してください。\n\n```tsx twoslash {15} title=\"pages/index.tsx\"\nimport { NextPage } from \"next\";\n\nconst IndexPage: NextPage = () => {\n  return <div>猫画像予定地</div>;\n};\nexport default IndexPage;\n\nconst fetchImage = async () => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n\nfetchImage(); // 追加\n```\n\nChromeの開発者ツールを開いてからページをリロードしてください。「コンソール」タブで次のようなテキストが表示されていたら成功です。\n\n![](/tutorials/nextjs/the-cat-api-response-is-shown-in-console.png)\n\n`fetchImage`関数の動作確認が済んだら、この関数の呼び出しは不要になるので消してください。\n\n## 関数の戻り値に型をつける\n\n上で作った`fetchImage`関数の戻り値の型は`any`型です。そのため、呼び出し側で存在しないプロパティを参照しても気づけずにバグが発生する危険性があります。\n\n```ts twoslash\nconst fetchImage = async () => {\n  //  ^?\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n\nfetchImage().then((image) => {\n  //                   ^?\n  console.log(image.alt); // 存在しないプロパティを参照している\n});\n```\n\n`image`には`alt`プロパティがありませんが、`image`が`any`型なので、上のような誤ったコードを書いても、コンパイル時に誤りに気づけません。\n\nAPIレスポンスの取り扱いはフロントエンドでバグが混在しやすい箇所なので、型を指定することで安全にAPIレスポンスを扱えるようにしていきます。\n\nレスポンスに含まれる画像情報の型を`Image`として定義します。そして、`fetchImage`関数の戻り値を`Promise<Image>`として型注釈します。\n\n```ts twoslash {1-5}\ntype Image = {\n  url: string;\n};\nconst fetchImage = async (): Promise<Image> => {\n  //                       ^^^^^^^^^^^^^^^^型注釈\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n```\n\nAPIレスポンスには`url`以外のプロパティも含まれていますが、このアプリケーションで必要な情報は`url`だけなので、他のプロパティの型の定義は省略しています。もし、他のプロパティも必要になった場合でも、`Image`にプロパティの定義を追加していけばよいです。\n\n`fetchImage`関数の戻り値が正しく型注釈がされていると、万が一APIレスポンスに存在しないプロパティを参照するコードを書いてしまっても、コンパイルエラーが発生することで問題に気がつけるようになります。\n\n```ts twoslash\n// @errors: 2339\ntype Image = { url: string };\ndeclare const fetchImage: () => Promise<Image>;\n// ---cut---\nfetchImage().then((image) => {\n  //               ^?\n  console.log(image.alt); // 存在しないプロパティを参照している\n});\n```\n\n:::info 厳密なレスポンスのチェック\n\n上のコードは、サーバーサイドを100%信頼するコードになっています。クライアントサイドが期待するデータ構造を、サーバーサイドが必ず返すことを前提としたコードなのです。しかし、サーバーサイドは本当に期待するデータ構造を返してくれているでしょうか？\n\nより防衛的にするなら、クライアントサイドではサーバーのレスポンスをチェックするほうが望ましいでしょう。チェックの一例として次のような実装も考えられます。\n\n```ts twoslash\n// @noErrors\ntype Image = {\n  url: string;\n};\n// ---cut---\nconst fetchImage = async (): Promise<Image> => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images: unknown = await res.json();\n  // 配列として表現されているか？\n  if (!Array.isArray(images)) {\n    throw new Error(\"猫の画像が取得できませんでした\");\n  }\n  const image: unknown = images[0];\n  // Imageの構造をなしているか？\n  if (!isImage(image)) {\n    throw new Error(\"猫の画像が取得できませんでした\");\n  }\n  return image;\n};\n\n// 型ガード関数\nconst isImage = (value: unknown): value is Image => {\n  // 値がオブジェクトなのか？\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  // urlプロパティが存在し、かつ、それが文字列なのか？\n  return \"url\" in value && typeof value.url === \"string\";\n};\n```\n\nこのチェック処理では、型が不明な値を安全に型付けする[unknown型](../reference/statements/unknown.md)や、値の型をチェックしながら型付する[型ガード関数](../reference/functions/type-guard-functions.md)などのTypeScriptのテクニックも用いています。これらについては、ここでは理解する必要はありませんが、興味のある方はチュートリアルを終えてから解説をご覧ください。\n\nこのチュートリアルでは厳密さよりもシンプルさに重心を置くため、上のようなチェック処理はあえて追加せずに話を進めます。\n\n:::\n\n## ページを表示したときに画像を表示する\n\nページを表示したときに`fetchImage`を呼び出して、猫の画像を表示する処理を書いています。`IndexPage`関数の中身を次のように変更してください。\n\n```tsx twoslash {2,5-16} title=\"pages/index.tsx\"\nimport { NextPage } from \"next\";\nimport { useEffect, useState } from \"react\";\n\nconst IndexPage: NextPage = () => {\n  // ❶ useStateを使って状態を定義する\n  const [imageUrl, setImageUrl] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  // ❷ マウント時に画像を読み込む宣言\n  useEffect(() => {\n    fetchImage().then((newImage) => {\n      setImageUrl(newImage.url); // 画像URLの状態を更新する\n      setLoading(false); // ローディング状態を更新する\n    });\n  }, []);\n  // ❸ ローディング中でなければ、画像を表示する\n  return <div>{loading || <img src={imageUrl} />}</div>;\n};\nexport default IndexPage;\n\ntype Image = {\n  url: string;\n};\nconst fetchImage = async (): Promise<Image> => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n```\n\n変更内容をひとつひとつ見ていきましょう。\n\n❶ まず、Reactの`useState`関数を使い、`imageUrl`と`loading`の2つの状態を定義します。\n\n```tsx twoslash\nimport { useState } from \"react\";\n// ---cut---\nconst [imageUrl, setImageUrl] = useState(\"\");\nconst [loading, setLoading] = useState(true);\n```\n\n`imageUrl`は画像のURLが代入される変数です。初期値は空文字列です。`loading`はAPIを呼び出し中かどうかを管理する変数です。初期値は呼び出し中を意味する`true`です。\n\n❷ 次に、コンポーネントがマウントされたときに、APIから猫の画像情報を取得する処理を定義します。\n\n```tsx twoslash\nimport { useEffect, useState } from \"react\";\n\nconst [imageUrl, setImageUrl] = useState(\"\");\nconst [loading, setLoading] = useState(true);\n// ---cut---\nuseEffect(() => {\n  fetchImage().then((newImage) => {\n    setImageUrl(newImage.url); // 画像URLの状態を更新する\n    setLoading(false); // ローディング状態を更新する\n  });\n}, []);\n// ---cut-after---\ntype Image = { url: string };\ndeclare const fetchImage: () => Promise<Image>;\n```\n\nReactの`useEffect`関数を使用します。`useEffect`は2つの引数を指定しています。第1引数は処理内容、第2引数はどのタイミングで処理内容を実行するかの指定です。第2引数は空の配列`[]`になっています。空配列であるため一見すると不要そうに見えますが、これには「コンポーネントがマウントされたときのみ実行する」という重要な役割があるので省略しないでください。\n\n`useEffect`関数の第1引数となる関数の処理を見てみましょう。`fetchImage`関数は非同期処理です。非同期処理が完了したタイミングで、`imageUrl`に画像URLをセットするために`setImageUrl`関数を呼び出します。同時に、ローディング状態を`false`に更新するために`setLoading`関数も呼び出します。\n\n:::info `useEffect`には非同期関数は渡せない\n\n`useEffect`に渡している関数は非同期処理をしているのに、`async`キーワードを使わずに`then`を使って記述していることに気がついた方もいるかもしれません。その方の中には、次のように非同期関数を渡す書き方にして、コードが読みやすくしたいと思う方もいるでしょう。\n\n```ts twoslash\nimport { useState } from \"react\";\n\nconst [imageUrl, setImageUrl] = useState(\"\");\nconst [loading, setLoading] = useState(true);\ndeclare const useEffect: any;\ntype Image = { url: string };\ndeclare const fetchImage: () => Promise<Image>;\n// ---cut---\nuseEffect(async () => {\n  const newImage = await fetchImage();\n  setImageUrl(newImage.url);\n  setLoading(false);\n}, []);\n```\n\nしかし、`useEffect`には非同期関数を直接渡すことはできません。渡そうとすると、コンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2345\nimport { useEffect } from \"react\";\n// ---cut---\nuseEffect(async () => {\n  /* 中略 */\n}, []);\n```\n\n:::\n\n❸ 最後に画像を表示するロジックです。`||`は論理和演算子で、`loading`が`false`のときに`<img>`要素を表示します。\n\n```tsx twoslash\ndeclare const loading: boolean;\ndeclare const imageUrl: string;\nconst IndexPage = () => {\n  // ---cut---\n  return <div>{loading || <img src={imageUrl} />}</div>;\n  // ---cut-after---\n};\n```\n\n:::info JSXには文が書けない\n上の条件分岐を見て「なぜ素直にif文を使わないのか？」と疑問の思ったかもしれません。これには理由があります。JSXの`{}`で囲った部分には、JavaScriptの式だけが書けます。ifは文であるため使うことができません。もし使おうとすると次の例のようにコンパイルエラーになります。\n\n```tsx twoslash title=\"JSXの式には文が使えない\"\n// @errors: 1109 1381\ndeclare const loading: boolean;\ndeclare const imageUrl: string;\n  // ---cut---\n<div>{if (!loading) { <img src={imageUrl} /> }}</div>\n```\n\nしたがって、JSXの式で条件分岐するには論理演算子や三項演算子を使う必要があります。\n\n```tsx twoslash\ndeclare const loaded: boolean;\ndeclare const loading: boolean;\n// ---cut---\n<div>\n  {loaded && <img src=\"...\" />} ── 論理積演算子\n  {loading || <img src=\"...\" />} ── 論理和演算子\n  {loading ? \"読み込み中\" : <img src=\"...\" />} ── 三項演算子\n</div>;\n```\n\n:::\n\n変更内容の詳細は以上です。`IndexPage`の変更が済んだら、猫の画像が表示されているか確認してみてください。画像がちゃんと表示されているでしょうか。\n\n![猫の画像がuseEffectによって表示されるようになった様子](/tutorials/nextjs/cat-image-is-displayed-by-use-effect.png)\n\n## ボタンをクリックしたときに画像が更新されるようにする\n\nここではボタンをクリックしたときに、APIから新しい画像情報を取得し、表示中の画像を新しい画像に置き換える機能を作ります。次のように`IndexPage`コンポーネントに、`handleClick`関数とボタンを追加してください。\n\n```tsx twoslash {13-25} title=\"pages/index.tsx\"\nimport { NextPage } from \"next\";\nimport { useEffect, useState } from \"react\";\n\nconst IndexPage: NextPage = () => {\n  const [imageUrl, setImageUrl] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    fetchImage().then((newImage) => {\n      setImageUrl(newImage.url);\n      setLoading(false);\n    });\n  }, []);\n  // ボタンをクリックしたときに画像を読み込む処理\n  const handleClick = async () => {\n    setLoading(true); // 読込中フラグを立てる\n    const newImage = await fetchImage();\n    setImageUrl(newImage.url); // 画像URLの状態を更新する\n    setLoading(false); // 読込中フラグを倒す\n  };\n  return (\n    <div>\n      <button onClick={handleClick}>他のにゃんこも見る</button>\n      <div>{loading || <img src={imageUrl} />}</div>\n    </div>\n  );\n};\nexport default IndexPage;\n\ntype Image = {\n  url: string;\n};\nconst fetchImage = async (): Promise<Image> => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n```\n\nこれでクリックしたら画像が更新されるようになります。うまく動いているかブラウザで確認してみてください。\n\n<video width=\"600\" controls=\"controls\" loop=\"controls\" autoPlay=\"autoplay\" muted=\"muted\" playsInline=\"playsinline\">\n  <source src=\"/tutorials/nextjs/cat-image-is-changed-when-click-the-button.mp4\" type=\"video/mp4\" />\n</video>\n\n## Next.jsのSSRとデータフェッチAPI\n\nReactはクライアントサイドでのレンダリングに特化していますが、Next.jsはサーバーサイドレンダリング(server-side rendering; SSR)をサポートしています。これにより、初回読み込みの速度を向上させることができ、SEOやパフォーマンスにもよい影響を与えます。\n\nSSRはウェブアプリケーションのレンダリングをサーバーサイドで行う技術のことです。通常、クライアントサイドレンダリング(client-side rendering; CSR)では、ブラウザがHTML、CSS、JavaScriptファイルをダウンロードして、JavaScriptを使用してページをレンダリングします。これに対して、SSRではサーバーがHTMLを生成し、ブラウザに送信します。\n\nNext.jsでSSRを行うには、次のデータフェッチAPIの関数を使います。\n\n- `getServerSideProps`\n- `getStaticProps`\n- `getInitialProps`\n\nこれらの関数を使うことで、Next.jsで簡単にSSRを実装できます。\n\n### getServerSideProps\n\n`getServerSideProps`は、ページがリクエストされるたびにサーバーサイドで実行され、ページのプロパティを返す関数です。この関数を使用すると、リクエストごとにページのデータを取得できます。また、クライアントサイドでルーティングが発生した場合も、この関数がサーバーサイドで実行されます。\n\nサーバーサイドでのみ実行されるため、`getServerSideProps`内でのみ利用しているモジュールや関数は、クライアントのコードにバンドルされません。これは、配信するファイルサイズを削減することにも繋がります。\n\nサーバーサイドで実行されるため、データベースなどウェブに公開していないミドルウェアから直接データを取得するような処理も記述できます。\n\n### getStaticProps\n\n`getStaticProps`は、静的生成するページのデータを取得するための関数で、ビルド時に実行されます。この関数を使用すると、ビルド時にページのデータを取得しておき、クライアントからのリクエスト時にはそのキャッシュからデータを返すようになります。この関数は、リクエスト時や描画時にはデータ取得が実行されないことに注意が必要です。ユーザーログインが不要なランディングページや、内容のリアルタイムさが不要なブログなどの静的なページを構築するときに利用します。\n\n### getInitialProps\n\n`getInitialProps`は、SSR時にサーバーサイドでデータ取得の処理が実行されます。また、クライアントサイドでルーティングが発生した場合は、クライアント側でもデータの取得が実行されます。このAPIはサーバーとクライアントの両方で実行されるため、両方の環境で動作するように実装する必要があります。\n\n`getInitialProps`は、Next.js 9までのバージョンで使われていた古い方法です。現在でもサポートされていますが、Next.js 10以降では、代わりに `getServerSideProps`や`getStaticProps`の使用を推奨しています。\n\n## データフェッチAPIを使ってリクエスト時に初期画像を取得する\n\nこれまでに作ってきた`IndexPage`コンポーネントには、クライアントサイドで最初の画像を取得し表示していました。ここでは、データフェッチAPIの`getServerSideProps`を使って、サーバーサイドで初期画像を取得するように変更します。先に完成形のコードを示すと、次のようになります。\n\n```tsx twoslash {1-2,4-18,34-43} title=\"pages/index.tsx\"\nimport { GetServerSideProps, NextPage } from \"next\";\nimport { useState } from \"react\";\n\n// getServerSidePropsから渡されるpropsの型\ntype Props = {\n  initialImageUrl: string;\n};\n\n// ページコンポーネント関数にpropsを受け取る引数を追加する\nconst IndexPage: NextPage<Props> = ({ initialImageUrl }) => {\n  const [imageUrl, setImageUrl] = useState(initialImageUrl); // 初期値を渡す\n  const [loading, setLoading] = useState(false); // 初期状態はfalseにしておく\n  // useEffect(() => {\n  //   fetchImage().then((newImage) => {\n  //     setImageUrl(newImage.url);\n  //     setLoading(false);\n  //   });\n  // }, []);\n  const handleClick = async () => {\n    setLoading(true);\n    const newImage = await fetchImage();\n    setImageUrl(newImage.url);\n    setLoading(false);\n  };\n  return (\n    <div>\n      <button onClick={handleClick}>他のにゃんこも見る</button>\n      <div>{loading || <img src={imageUrl} />}</div>\n    </div>\n  );\n};\nexport default IndexPage;\n\n// サーバーサイドで実行する処理\nexport const getServerSideProps: GetServerSideProps<Props> = async () => {\n  const image = await fetchImage();\n  return {\n    props: {\n      initialImageUrl: image.url,\n    },\n  };\n};\n\ntype Image = {\n  url: string;\n};\nconst fetchImage = async (): Promise<Image> => {\n  const res = await fetch(\"https://api.thecatapi.com/v1/images/search\");\n  const images = await res.json();\n  console.log(images);\n  return images[0];\n};\n```\n\n上で行った変更をひとつひとつ見ていきましょう。まず、`getServerSideProps`関数を追加しました。この関数は、サーバーサイドで実行する処理を書きます。上のコードは画像情報を取得する処理になっています。`getServerSideProps`関数は、`IndexPage`コンポーネントが引数として受け取る`prop`を戻り値に含めます。`getServerSideProps`関数は、Next.jsに認識させるために`export`しておく必要があります。\n\n次に、`IndexPage`関数は`getServerSideProps`が返す`props`を受け取れるように引数を追加してあります。`props`の`initialImageUrl`には初期画像のURLが入っていて、この値を`image`の初期値となるように、`useState`の引数に渡します。\n\n初期画像はサーバーサイドで取得するようにしたので、クライアントサイドで初期画像を取得していた`useEffect`の部分は不要になります。\n\nこれで、ページをリクエストするタイミングで、サーバーサイドで画像情報が取得され、ランダムに猫画像が表示されるようになります。\n\n## ビジュアルを作り込む\n\n機能面が完成したので、最後にビジュアルデザインを作り込んでいきましょう。まず、スタイルシートを作成します。スタイルシートの内容は長くなるので、次のURLからスタイルシートをダウンロードしてください。ダウンロードしたら、`pages`ディレクトリに`index.module.css`として保存してください。\n\n<https://raw.githubusercontent.com/yytypescript/random-cat/main/pages/index.module.css>\n\nこのスタイルを`IndexPage`コンポーネントに当てます。まず、`index.module.css`をインポートします。`.module.css`で終わるファイルはCSSモジュール(CSS Modules)と言うもので、CSSファイル内で定義したクラス名をTypeScriptからオブジェクトとして参照できるようになります。次に、各要素に`className`属性でクラス名を指定してください。\n\n```tsx twoslash {3,8,9,12,13} title=\"pages/index.tsx\"\nimport { GetServerSideProps, NextPage } from \"next\";\nimport { useState } from \"react\";\nimport styles from \"./index.module.css\";\n\nconst IndexPage: NextPage<Props> = ({ initialImageUrl }) => {\n  // 中略\n  return (\n    <div className={styles.page}>\n      <button onClick={handleClick} className={styles.button}>\n        他のにゃんこも見る\n      </button>\n      <div className={styles.frame}>\n        {loading || <img src={imageUrl} className={styles.img} />}\n      </div>\n    </div>\n  );\n};\n// 以下略\n// ---cut-after---\ntype Image = { url: string };\ntype Props = { initialImageUrl: string };\ndeclare const fetchImage: () => Promise<Image>;\ndeclare const handleClick: () => Promise<void>;\ndeclare const imageUrl: string;\ndeclare const loading: boolean;\n```\n\n以上でNext.jsを使った猫画像ジェネレーターの開発は完了です。\n\n## プロダクションビルドと実行\n\nNext.jsでは`next build`を実行することで最適化されたプロダクション用のコードを生成でき、`next start`で生成されたプロダクションコードを実行できます。このチュートリアルではボイラテンプレートを利用しているので、package.jsonにbuildコマンドとstartコマンドがすでに用意されています。`yarn build`と`yarn start`を実行して本番用のアプリケーションを実行してみましょう。\n\n```sh\nyarn build && yarn start\n```\n\nアプリケーション起動後に<http://localhost:3000>へブラウザでアクセスをすることで、本番用のアプリケーションの実行を確認できます。\n",
      "url": "https://typescriptbook.jp/tutorials/nextjs"
    },
    {
      "title": "Prettierでコード整形を自動化しよう",
      "content": "# Prettierでコード整形を自動化しよう\n\nこのチュートリアルでは、コードフォーマッターの「Prettier」を使いTypeScriptのコードフォーマットを自動化することを学びます。\n\n## 本章で学べること\n\n本章ではPrettierを導入してコード整形を自動化することを目標に次のことを学びます。\n\n- Prettierの導入方法\n- Prettierの実行方法\n- 整形ルールの設定方法\n\n## Prettierとは\n\nPrettierはコードのフォーマットを自動整形するツールです。Prettierがサポートしている形式は幅広く次の形式をサポートしています。\nまた、プラグインを利用することでPHPなどの他の言語のフォーマットを行うこともできます。\n\n- JavaScript\n- TypeScript\n- [JSX](./../reference/jsx/README.md)\n- Flow\n- JSON\n- HTML\n- Vue\n- Angular\n- Ember\n- Css\n- Less\n- SCSS\n- styled-components\n- styled-jsx\n- GraphQL\n- Markdown\n- MDX\n- YAML\n- Svelte\n\n## なぜPrettierを導入するのか\n\n複数人で開発していると、人によってインデントがズレていたり、オブジェクトの最後のカンマをつけるorつけないといったコードスタイルの違いが発生します。\n\n<!-- prettier-ignore -->\n```ts\n// オブジェクトの最後にカンマが付いている\n// 文字列はダブルクォート\n// 行末にセミコロンが付いている\nconst user1 = {\n  name: \"太郎\",\n  age: 20,\n};\n\n// オブジェクトの最後にカンマが付かない\n// 文字列はシングルクォート\n// 行末にセミコロンが付かない\nconst user2 = {\n  name: 'まさる',\n  age: 30\n}\n```\n\n手動でこれらのコードスタイルを統一するには、ガイドラインを作成してチーム内で共有をしてコードレビューで注意深くチェックする必要があります。また、新しいメンバーがチームに参加した際にはルールを共有する手間も発生します。\n\nPrettierを導入してコード整形を自動化することで、簡単にコードのスタイルを統一することができます。開発者は細かいコードスタイルのことを意識する必要がなくなり開発に集中することができるようになるので、より効率的に開発をすることができます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルで必要なものは次のとおりです。\n\n- Node.js v16以上\n- Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)\n\nNode.jsの導入については、[開発環境の準備](./setup.md)をご覧ください。\n\nパッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```shell\nnpm install -g yarn\n```\n\n## プロジェクトを作成する\n\nこのチュートリアルに使うプロジェクトを作成します。\n\n```shell\nmkdir prettier-tutorial\ncd prettier-tutorial\n```\n\nプロジェクトのルートにpackage.jsonを作成してください。内容は次のようにします。\n\n```json title=\"package.json\"\n{\n  \"name\": \"prettier-tutorial\",\n  \"license\": \"UNLICENSED\"\n}\n```\n\n## Prettierをインストール\n\nPrettierは開発時にだけ使うパッケージなので`-D`オプションをつけてインストールします。\n\n```shell\nyarn add -D 'prettier@^2'\n```\n\nバージョンを表示してインストールを確認してください。\n\n```shell\nyarn prettier -v\n2.8.1\n```\n\n## TypeScriptを自動整形する\n\n`prettier`コマンドを利用して、TypeScriptのファイルをPrettierで自動整形してみましょう。\n\n最初に`src`ディレクトリを作成して、`src/helloWorld.ts`を作成してください。\n\n```shell\nmkdir src\ntouch src/helloWorld.ts\n```\n\n`helloWorld.ts`の内容を次のように変更します。\nこのコードは自動整形を確認するために、わざと見づらいコードになっています。\n\n<!--prettier-ignore-->\n```ts twoslash title=\"src/helloWorld.ts\"\nconst hello = ( name: string) =>   {\nconsole.log(\"Hello,World \"\n+ name)\n\n}\n```\n\n`prettier`コマンドを実行してみましょう。\nコマンドは`prettier [オプション] [ファイル/ディレクトリ]`の形式で実行できます。\n\n次の例では`src`を引数で指定することで`src`ディレクトリ配下のすべてファイルを対象として自動整形を実行します。\n\n```shell\nyarn prettier src\n```\n\n整形結果が表示されていますが、`helloWorld.ts`を確認するとファイル内容が変更されていないことに気づくと思います。`prettier`コマンドをオプションなしで実行した場合は整形結果だけが表示されて、ファイルの書き換えは実行されません。\n\nファイルの書き換えを一緒に実行する場合は`--write`オプションを指定します。\n\n```shell\nyarn prettier --write src\n```\n\n実行後に`helloWorld.ts`を確認してみると、次のようにコードが整形されているのが確認できます。\n\n```ts twoslash title=\"src/helloWorld.ts\"\nconst hello = (name: string) => {\n  console.log(\"Hello,World \" + name);\n};\n```\n\n## Prettierのデフォルトの整形ルール\n\nPrettierはデフォルトの整形ルールが定義されています。先ほどの実行結果を見るとインデントが幅2つのスペースでインデントがされているのが分かります。\n\n代表的な項目のデフォルト値は次のようになっています。\nすべての項目のデフォルト値を確認したい場合は、[Prettierの公式ドキュメント](https://prettier.io/docs/en/options.html)を参照してください。\n\n| 項目            | デフォルト値   |\n| --------------- | -------------- |\n| 1行の最大文字数 | 80             |\n| インデント幅    | 2              |\n| インデント      | スペース       |\n| セミコロン      | つける         |\n| クォート        | ダブルクォート |\n\n## Prettierの整形ルールを設定する\n\n### CLIオプションで設定\n\n整形ルールは`prettier`コマンドを実行する時にオプションとして指定することができます。\n先ほど整形した`helloWorld.ts`を別の整形ルールで整形してみます。\n\n```shell\nyarn prettier --no-semi --tab-width 4 --write src\n```\n\n整形されたコードを見るとセミコロンが消えて、インデント幅が2から4に変更されているのを確認できます。\n\n<!--prettier-ignore-->\n```ts twoslash title=\"src/helloWorld.ts\"\nconst hello = (name: string) => {\n    console.log(\"Hello,World \" + name)\n}\n```\n\n### 設定ファイルを作成する\n\nPrettierは整形ルールを設定ファイルに記述することもできます。\n\nプロジェクトのルートに`.prettierrc`を作成します。\n\n```shell\ntouch .prettierrc\n```\n\n次に`.prettierrc`を次のように変更します。\n\n```json title=\".prettierrc\"\n{\n  \"tabWidth\": 2,\n  \"semi\": true,\n  \"singleQuote\": true\n}\n```\n\n設定ファイルが作成できたら、`prettier`コマンドを実行してみましょう。\nPrettierはプロジェクトルートに`.prettierrc`が存在する場合は自動で設定ファイルを読み込んで整形ルールを設定してくれます。\n\n```shell\nyarn prettier --write src\n```\n\n設定ファイルで記述した整形ルールで`helloWorld.ts`が変更されているのを確認できます。\n\n<!--prettier-ignore-->\n```ts twoslash title=\"src/helloWorld.ts\"\nconst hello = (name: string) => {\n  console.log('Hello,World ' + name);\n};\n```\n\n上記の例ではJSONフォーマットで設定ファイルを作成しましたが、PrettierはJSON以外にもJS,YAML,TOMLのフォーマットをサポートしています。\n\n```js twoslash title=\"prettier.config.js\"\nmodule.exports = {\n  tabWidth: 2,\n  semi: true,\n  singleQuote: true,\n};\n```\n\n```yaml title=\".prettierrc.yml\"\ntabWidth: 2\nsemi: true\nsingleQuote: true\n```\n\n```toml title=\".prettierrc.toml\"\ntabWidth = 2\nsemi = true\nsingleQuote = true\n```\n\n`.prettierrc`以外でも自動で設定ファイルとして認識可能なファイル名がいくつか存在します。\nフォーマットとファイル名の組み合わせは次のとおりです。\n\n| フォーマット | ファイル名                                                                              |\n| :----------- | :-------------------------------------------------------------------------------------- |\n| json         | `.prettierrc`, `.prettierrc.json`, `.prettierrc.json5`                                  |\n| js           | `.prettierrc.js`, `.prettierrc.cjs`, `prettier.config.js`, <br /> `prettier.config.cjs` |\n| yaml         | `.prettierrc`, `.prettierrc.yml`, `.prettierrc.yaml`                                    |\n| toml         | `.prettierrc.toml`                                                                      |\n\n### 他の整形ルールを確認する\n\nここで紹介した以外にもいくつかの整形ルールが存在します。\n他の整形ルールやCLIコマンドのオプション名、設定ファイルのキー名などを確認したい場合は[Prettierの公式ドキュメント](https://prettier.io/docs/en/options.html)をご参照ください。\n\n### どのような整形ルールがよいのか？\n\nPrettierをプロジェクトに導入する時に整形ルールについて悩む場合があるかもしれません。\n\n整形ルールについては好みの部分も大きいので、プロジェクトの開発者で話し合って決めるようにしましょう。整形ルールを変更したい場合は`prettier`コマンドを実行するだけなので、後から簡単に変更できる前提で決めてしまっても問題ありません。\n\n特にこだわりが無い場合は、Prettierのデフォルトの整形ルールをそのまま利用するのがオススメです。\n\n## Prettierの自動整形を無効にする\n\n`prettier-ignore`をコメントとして記述することで、一部のコードをPrettierの自動整形の対象から除外することができます。\n\n```ts twoslash title=\"src/helloWorld.ts\"\nconst board1 = [1, 0, 0, 1];\n\n//  prettier-ignore\nconst board2 = [\n  1, 0,\n  0, 1\n];\n```\n",
      "url": "https://typescriptbook.jp/tutorials/prettier"
    },
    {
      "title": "🚧huskyでコミット前チェックを自動化しよう",
      "content": "# 🚧huskyでコミット前チェックを自動化しよう\n\n:::caution\n\n執筆中\n\nhuskyを導入しprettierやeslintをコミット時に実行できるようになるチュートリアルを書く。\n\n:::\n",
      "url": "https://typescriptbook.jp/tutorials/husky"
    },
    {
      "title": "ESLintでTypeScriptのコーディング規約チェックを自動化しよう",
      "content": "---\nsidebar_label: ESLintでコーディング規約を自動化しよう\n---\n\n# ESLintでTypeScriptのコーディング規約チェックを自動化しよう\n\n本章では、<ruby>ESLint<rt>イーエスリント</rt></ruby>を使って、TypeScriptをチェックするためのノウハウをチュートリアル形式で学びます。\n\n## 本章で学べること\n\n本章では次のことを学んでいただきます。\n\n- コーディング規約の必要性とコーディング規約の問題点\n- ESLintでJavaScriptやTypeScriptをチェックする方法\n- ESLintのルールの設定のしかた\n- Airbnbのコーディング規約をESLintで活用する術\n- エラーを解消する方法\n- チェックを部分的に無効化する方法\n- VS CodeやJetBrains IDEとESLintを統合する方法\n\nチュートリアルをやり終えると、ご自身のプロジェクトにESLintを導入できるようになったりと、実務で役立つ基本的なスキルが身につくはずです。\n\n## 本章の流れと読み進め方\n\n本章は次の3部構成です。\n\n- [背景知識]\n- [ESLintでJavaScriptをリントしよう]\n- [ESLintでTypeScriptをリントしよう]\n\n本章の前半は座学です。「コーディング規約」や「リンター」が何か知らない方向けに、その背景知識を解説します([背景知識])。すでにコーディング規約やリンターが分かっている方、すぐに手を動かしたい方は、ここは読み飛ばしても構いません。\n\n本章の後半はチュートリアルです。本章のゴールは、TypeScriptをESLintでチェックできるようになることです。しかしながら、ESLintでTypeScriptを扱うのは発展的な用法です。そこで、チュートリアルの流れとしては、まず基礎編として、JavaScriptをESLintで扱う方法を学びます([ESLintでJavaScriptをリントしよう])。その後、TypeScriptをESLintを扱う方法を学んでいただきます([ESLintでTypeScriptをリントしよう])。\n\n章末にはおまけとして次のチュートリアルも用意してあります。関心と余力がある方はこちらもご覧ください。\n\n- [VS CodeとESLintを統合しよう]\n- [JetBrains IDEとESLintを統合しよう]\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルで必要なものは次のとおりです。\n\n- Node.js v16以上\n- NPM v7系以上\n- Yarn v1系 (このチュートリアルはv1.22.18で動作確認しています)\n\nNode.jsの導入については、[開発環境の準備](./setup.md)をご覧ください。\n\nパッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```shell\nnpm install -g yarn\n```\n\n## 背景知識\n\n[背景知識]: #背景知識\n\n### TypeScriptの書き方はさまざま\n\nTypeScriptに限らず、プログラミング言語には文法があります。文法を守って書かれたコードは、エラーなく実行やコンパイルができます。\n\nプログラムは文法さえ守れば、誰が書いても一字一句同じコードになるかというと、そうではありません。たとえば、TypeScriptでは文末のセミコロンが省略できます。次の2行のコードの違いは、セミコロンの有無です。どちらも文法的に正しく、どちらを使うかは好みの問題です。\n\n```ts twoslash\n// prettier-ignore\nconsole.log(\"OK\")\nconsole.log(\"OK\");\n```\n\n文字列はシングルクォート、ダブルクォート、バッククォートの3通りで書けます。シングルクォートとダブルクォートは機能上の違いがありません。バッククォートは[テンプレートリテラル](/reference/values-types-variables/string#テンプレートリテラル)と言い、文字列リテラルとは仕様が異なります。しかし、次の例のような単純な文字列では、この3つは同じ意味になります。\n\n```ts twoslash\n// prettier-ignore\nconsole.log('OK');\nconsole.log(\"OK\");\nconsole.log(`OK`);\n```\n\nこの例は、どれを使うか意見が割れるところです。本書独自の調査では、「原則的にどれをもっとも多く使うか？」という問いに対し、シングルクォートが55%ともっとも多く、次にダブルクォートが29%、バッククォートは16%という回答が得られました。(回答数232件)\n\n<figure><img src=\"/img/tutorial/eslint/string-quotes-chart.svg\" width=\"320\" /></figure>\n\n上でとりあげた例はほんの一例です。意味が同じで書き方が異なる例は、数多くあります。\n\n### 書き方の違いが問題になることも\n\n書き方の違いが問題なることがあります。たとえば、プログラムを共同で開発する場合です。人によって書き方が異なると、その違いが気になったり驚いたりして、コードの本筋が頭に入ってこないことがあります。インデントの幅が統一されていないと、コードが読みにくくなることもあります。結果的に、**書き方に違いがあるとプログラムの保守性を損ねる**一因になります。\n\n### コーディング規約で書き方を統一\n\n理想は、誰が書いても同じコードになることです。そのためにはどうしたらよいでしょうか。解決策のひとつは、書き方のルールを決めることです。コードの**書き方の取り決めは「コーディング規約(coding standards)」**と呼ばれます。\n\nコーディング規約では、たとえば、次のようなことを決めます。\n\n- 変数名はキャメルケースにしましょう。\n- `function`の中カッコは関数名と同じ行に書きましょう。(次の行に置いてはなりません)\n- `console.log`は消しましょう。\n- if文の条件式で変数代入してはいけません。たとえば`if (data = getData())`はだめ。\n\nこのようなルールを取りまとめて規約を作るのですが、実用的な規約に仕上げるにはかなりの労力を要します。実務では、公開されている規約を借りてくるほうが現実的です。\n\n公開されている規約には主に次のものがあります。これらは実際に多くのプロジェクトで利用されています。\n\n- [Google JavaScript Style Guide]\n- [JavaScript Standard Style]\n- [Airbnb JavaScript Style Guide]\n\n[google javascript style guide]: https://google.github.io/styleguide/jsguide.html\n[javascript standard style]: https://standardjs.com/rules.html\n[airbnb javascript style guide]: https://github.com/airbnb/javascript\n\nコーディング規約をチームのみんなで守れば、書き方を統一しやすくなります。\n\n### コーディング規約の問題点\n\nコーディング規約にも問題点があります。\n\n#### 運用の手間は少なくない\n\n開発者ひとりひとりが規約を守れば、コーディング規約は機能します。しかし、ヒューマンエラーは起きるものです。規約を知った上で破る場合もありますが、多いのは知らずに破ってしまうことや、間違えてしまうことです。もしも、規約が守られなければ、規約は形式上のものになってしまいます。そうなると、書き方を統一するという目標は達成できなくなってしまいます。\n\nヒューマンエラーを防ぐには、コードが**規約に準拠しているかを日々点検しなければなりません**。しかし、これには多くの労力がかかります。もっと重要な仕事がある中で、点検を行うのは無理な場合もあるかもしれません。規約を正しく運用するには、多くの手間がかかるのです。\n\n#### コミュニケーション上の心理的な負担が増す\n\nコーディング規約は、何が正しく、何が間違いかを定めます。すると、明らかに誤りと判断できるコードが出てきます。他者が書いたコードの誤りを指摘する場面も出てきます。**人の仕事の誤りを指摘するのは難しいものです**。想像以上に心理的な負担になります。指摘する側は相手の心象を悪くしないよう、伝え方に苦慮します。指摘される側も、前向きに受け取れない場合もあります。相手との対人関係によっては、指摘することが遠慮される場合もあります。\n\n### コーディング規約の自動化\n\n書き方を統一するには、コーディング規約は不可欠です。しかし、運用の手間や心理的な課題もあります。これを解決する手助けとなるのがESLintです。**ESLintは、JavaScriptやTypeScriptのコードがコーディング規約に準拠しているかをチェックするツール**です。\n\nESLintは、コマンドひとつでチェックが行なえます。チェックは数秒で完了し、すぐに結果がわかります。そのため、点検の手間がほぼなくなります。\n\n加えて、自動修正機能もあります。コードによっては、ESLintが規約に準じたコードに直せる場合もあります。この機能を利用できる場合は、規約違反箇所を修正する手間もなくせます。\n\n不思議なもので、同じ指摘でも人に言われるより、機械に指摘されたほうが気が楽なものです。ESLintでは機械的に問題を指摘してくれるため、コミュニケーション上の心理的負担も軽減できます。\n\nESLintを導入すると、開発者は規約の運用や心理的ストレスから開放され、**開発などのより重要な仕事に集中できるようになります**。\n\n<PostILearned>\n\n📝TypeScriptは同じ意味処理でも異なる書き方が可能\n💥チーム開発では書き方の違いが問題になることも…\n🤝書き方統一のためにコーディング規約を導入しよう\n😵でも、規約には運用の手間や心理的な課題もある\n✅この課題はESLintで解決できる！\n\n</PostILearned>\n\n### リンターとは\n\nESLintは一般的に「リンター(linter)」というジャンルのツールです。リンターは、プログラムを**静的に解析し、バグや問題点を発見するツール**を言います。リンターを使って、問題点を解析することを「リントする(lint)」と言います。\n\nリント(lint)の由来は紡績です。羊毛や綿花から、繊維をつむぐ際に不要になるホコリのような糸くずをリントと呼びます。紡績ではリントを取り除く工程があり、これにちなんでプログラミングでもリントという名前が使われだしたと言われています。\n\n### コンパイラとリンターの違い\n\nコンパイラの本質は、ある言語から別の言語に変換することです。TypeScriptコンパイラの場合は、TypeScriptからJavaScriptへの変換です。\n\nリンターの本質は、プログラムの問題点を指摘することです。言語から言語への変換は行いません。\n\n実際は、TypeScriptコンパイラもプログラムの問題点を報告します。たとえば、コンパイラオプション[`noUnusedLocals`](/reference/tsconfig/nounusedlocals)を有効にすると、未使用の変数をチェックできます。ESLintにもこれと同等のチェックがあります。こうした点はリンターの機能と重複する部分です。\n\n類似のチェック機能があるものの、両者は得意分野が異なります。TypeScriptコンパイラは型のチェックが充実しています。型の側面から問題点を発見するのが得意です。一方、ESLintはインデントや命名規則などのコーディングスタイルや、どのようなコードを書くべきか避けるべきかの意思決定、セキュリティやパフォーマンスに関する分野でのチェックが充実しています。どちらも相互補完的な関係です。したがって、コンパイラとリンターの両方を導入すると、より幅広いチェックが行えるようになります。\n\n<figure>\n<figcaption>TypeScriptコンパイラとESLintの得意分野の比較</figcaption>\n\n|                      | TypeScriptコンパイラ | ESLint |\n| -------------------- | :------------------: | :----: |\n| 言語から言語への変換 |          ○           |        |\n| 型のチェック         |          ○           |        |\n| 構文チェック         |          ○           |   ○    |\n| コーディングスタイル |                      |   ○    |\n| コードの意思決定     |                      |   ○    |\n| セキュリティ         |                      |   ○    |\n| パフォーマンス       |                      |   ○    |\n\n</figure>\n\n<PostILearned>\n\n🧵リンター：コードを静的解析し問題点を指摘するツール。ESLintはリンター。\n🔀コンパイラ：静的解析もするが、別言語への変換が主目的。tscはコンパイラ。\n\n⚖️tscとESLintの相違点\n・tsc：型のチェックが得意\n・ESLint：コーディング規約のチェックが得意\n\n</PostILearned>\n\n## ESLintでJavaScriptをリントしよう\n\n[eslintでjavascriptをリントしよう]: #eslintでjavascriptをリントしよう\n\nここからはESLintの導入方法や使い方をチュートリアル形式で説明していきます。ぜひお手元の環境で実際にトライしてみてください。\n\n### プロジェクトを作成する\n\nまず、このチュートリアルに使うプロジェクトを作成します。\n\n```shell\nmkdir eslint-tutorial\ncd eslint-tutorial\n```\n\nプロジェクトルートにpackage.jsonを作ってください。その内容は次のようにします。\n\n```json title=\"package.json\"\n{\n  \"name\": \"eslint-tutorial\",\n  \"license\": \"UNLICENSED\"\n}\n```\n\n### ESLintを導入する\n\nESLintはYarnでインストールしましょう。ESLintは開発時だけ使うパッケージなので、`yarn add`コマンドには`-D`オプションをつけてインストールします。\n\n```shell\nyarn add -D 'eslint@^8'\n```\n\n:::info\nNext.jsは最初からESLintが導入されています。実務でNext.jsプロジェクトでESLintを使う場合は、導入ステップは省略できます。\n:::\n\nESLintが正しくインストールされたか、バージョンを表示して確認してください。\n\n```shell\nnpx eslint -v\nv8.15.0\n```\n\nちなみにこの`npx`コマンドは、Nodeモジュール(ライブラリ)の実行ファイルを起動するツールです。`npx eslint`を実行すると、`./node_modules/.bin/eslint`が実行されます。\n\n### ESLintの設定ファイルを作る\n\nESLintの設定ファイル`.eslintrc.js`をプロジェクトルートに作ってください。\n\n```shell\ntouch .eslintrc.js\n```\n\n```text title=\"設定ファイル作成後のディレクトリ構造\"\n.\n├── .eslintrc.js\n├── node_modules\n├── package.json\n└── yarn.lock\n```\n\n設定ファイルの内容は次のようにします。\n\n```js twoslash title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n};\n```\n\nこの設定内容は次で説明します。\n\n#### `root`\n\n`eslint`コマンドを実行したディレクトリを起点に、ディレクトリをさかのぼって設定ファイルを探す仕様がESLintにはあります。たとえば、ディレクトリ`/a/b/`でコマンドを実行した場合、ESLintは次の順で設定ファイルを探します。\n\n1. `/a/b/.eslintrc.js`\n1. `/a/.eslintrc.js`\n1. `/.eslintrc.js`\n\nこの探索はルートディレクトリに達するまでさかのぼります。探索中に複数の設定ファイルが見つかった場合は、設定内容がマージされていきます。この仕様は便利な反面、プロジェクト外の設定ファイルまで見にいってしまう危険性もあります。設定ファイルの探索範囲をしぼるためにも、`root`に`true`を設定するのがお勧めです。これがある設定ファイルが見つかると、これ以上ディレクトリをさかのぼらなくなります。\n\n#### `env`\n\n`env`はチェック対象のJavaScript/TypeScriptコードがどの実行環境で使われるかをESLintに伝えるためのオプションです。これを設定すると、ESLintがグローバル変数を認識するようになります。たとえば、`browser: true`を設定すると、`window`や`alert`などのグローバル変数が認識されます。`es2021`を設定すると、ES2021までに導入されたグローバル変数が認識されます。他にも`node`などの指定ができます。指定できる実行環境の一覧は[公式ドキュメント](https://eslint.org/docs/user-guide/configuring/language-options#specifying-environments)をご覧ください。\n\nこの設定は、ESLintの[no-undefルール](https://eslint.org/docs/rules/no-undef)に関係します。このルールは未定義の変数をチェックするルールです。グローバル変数は定義せずに利用できる変数です。ESLintはどのグローバル変数が定義済みかを知らないと、このルールを正しく適用できません。そのため、`env`オプションは正しく設定する必要があります。\n\n#### `parserOptions`\n\n##### `ecmaVersion`\n\n`parserOptions`はチェック対象のJavaScriptがどの構文を使っているかをESLintに伝えるためのオプションです。`ecmaVersion`は、どのバージョンのECMAScriptの構文を使うかを指定します。`\"latest\"`を設定すると、最新のECMAScriptの構文を使うという指定になります。デフォルトではECMAScript 5になっています。これはかなり古いバージョンです。実務ではES5で開発することはまれなので、ここは必ず指定しましょう。なお、`env`オプションで`es2022`などECMAScriptのバージョンを指定している場合、`ecmaVersion`にも自動的に`es2022`が設定されます。どちらも同じバージョンを指定する場合は、`ecmaVersion`の指定は省略できます。\n\n##### `sourceType`\n\nJavaScriptにはスクリプトモードとモジュールモードがあります。`sourceType`はJavaScriptコードがどちらのモードで書かれるかを指定するオプションです。モジュールモードでは、`import`文や`export`文といった追加の構文がサポートされます。`sourceType`のデフォルト値は`\"script\"`(スクリプトモード)です。実務で開発する場合は、モジュールモードでJavaScript/TypeScriptを書くほうが普通なので、`sourceType`には`\"module\"`(モジュールモード)を指定しましょう。\n\n### ESLintのルールを設定する\n\nESLintには「ルール(rule)」という概念があります。ルールはチェックの最小単位です。たとえば、ルールには次のようなものがあります。\n\n- `no-console`: `console.log`を書いてはならない\n- `camelcase`: 変数名はキャメルケースにすること\n- `semi`: 文末セミコロンは省略しない\n\nESLintには200を超えるルールがあります。[全ルールのリストは公式ドキュメント](https://eslint.org/docs/rules/)にあります。\n\nESLintでは、複数のルールを組み合わせてコーディング規約を組み立てていきます。\n\nルールには、重大度(severity)という重み付けが設定できます。重大度は、`off`、`warn`と`error`の3種類です。`off`はルールを無効化し、チェックを行わなくする設定です。`warn`は発見した問題を警告として報告します。報告はするものの、`eslint`コマンドの終了コードには影響しません。`error`は発見した問題をエラーとして報告し、終了コードを1にする効果があります。それぞれの重大度は、`0`から`2`までの数値で設定することもできます。\n\n<figure><figcaption>ESLintの重大度</figcaption>\n\n| 重大度 | 数値 | 効果                             |\n| ------ | ---- | -------------------------------- |\n| off    | 0    | ルールをオフにする               |\n| warn   | 1    | 警告するが終了コードに影響しない |\n| error  | 2    | 警告し、終了コードを1にする      |\n\n</figure>\n\nルールは`.eslintrc.js`の`rules`フィールドに、`ルール名: 重大度`のキーバリュー形式で書きます。まずは、`no-console`をルールに追加してみましょう。\n\n```js twoslash {11-13} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  rules: {\n    \"no-console\": \"error\",\n  },\n};\n```\n\nルールによっては、細かく設定できるものもあります。たとえば、`camelcase`です。これは変数名がキャメルケースかをチェックするルールです。変数の種類によっては、キャメルケース以外が使いたい場合があります。たとえば、プロパティ名はアンダースコアを使いたいことがあるかもしれません。ウェブAPIによっては、JSONオブジェクトがスネークケース(`foo_bar`のようなアンダースコア区切り)を採用している場合があるからです。この場合、`ルール名: [重大度, 設定値]`のような配列形式で設定することで、細かいルール設定ができます。次の設定例は、プロパティ名に限ってはキャメルケースを強制しない設定です。試しに、この設定を`.eslintrc.js`に加えてみましょう。\n\n```js twoslash {13} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  rules: {\n    \"no-console\": \"error\",\n    camelcase: [\"error\", { properties: \"never\" }],\n  },\n};\n```\n\n:::note ここまでのふりかえり\n\n- package.jsonを作りました。\n- eslintをインストールしました。\n- 設定ファイル`.eslintrc.js`を作りました。\n- 設定ファイルには次のルールを追加しました。\n  - `no-console`: `console.log`をコードに残しておいてはいけない。\n  - `camelcase`: 変数名はキャメルケースにすること(プロパティ名を除く)。\n\n:::\n\n### JavaScriptをチェックする\n\n設定ファイルが準備できたので、JavaScriptファイルを作り、ESLintでチェックしてみましょう。\n\nまず、`src`ディレクトリを作ってください。\n\n```shell\nmkdir src\n```\n\n`src`ディレクトリにJavaScriptファイル`helloWorld.js`を作ってください。\n\n```shell\ntouch src/helloWorld.js\n```\n\n`helloWorld.js`が加わったディレクトリ構造が、次のようになっているか確認してください。\n\n```txt\n.\n├── .eslintrc.js\n├── node_modules\n├── package.json\n├── src\n│   └── helloWorld.js\n└── yarn.lock\n```\n\n`helloWorld.js`の内容は次のようにします。\n\n```js twoslash title=\"src/helloWorld.js\"\nexport const hello_world = \"Hello World\";\nconsole.log(hello_world);\n```\n\nこの`helloWorld.js`は、わざとコーディング規約に違反するコードになっています。1行目の変数`hello_world`はキャメルケースになっていません。2行目では、使ってはいけない`console.log`が使われています。\n\nでは、ESLintでチェックを実行してみましょう。チェックは、`eslint`コマンドを起動するだけです。`eslint`コマンドは第一引数に、チェック対象のファイル名やディレクトリ名を指定します。ここでは、`src`ディレクトリ全体をチェックするために、引数は`src`にします。\n\n```shell title=\"srcディレクトリをESLintでチェックする\"\nnpx eslint src\n```\n\nこれを実行すると、次の出力が表示されます。\n\n![](/img/tutorial/eslint/terminal-npx-eslint-src.svg)\n\n#### 結果の読み方\n\nチェックした結果、問題点が見つかると表形式で詳細が表示されます。各行は4つの列からなります。左から順に、コードの行番号列番号、重大度、問題点の説明、ルール名です。\n\n![](/img/tutorial/eslint/error-meaning.svg)\n\n結果に表示されている内容だけでは、どうして問題点になっているのか、どう直したらいいのかが分からないことがあります。その場合は、ルール名からESLintのドキュメントでルールの詳細を調べます。たとえば、上の結果ではルール名に`no-console`が挙がっていますが、この文字列をもとにルールの詳細を探します。`no-console`の詳細ページは、<https://eslint.org/docs/rules/no-console>にあります。\n\n### コードを修正してエラーを解消する\n\n```js twoslash title=\"src/helloWorld.js\"\nexport const hello_world = \"Hello World\";\nconsole.log(hello_world);\n```\n\n上のコードをESLintでチェックした結果、2つの問題点が指摘されました。\n\n- 1行目: 変数名`hello_world`がキャメルケースではない\n- 2行目: `console.log`は使ってはいけない\n\nこのエラーを解消したいので、`helloWorld.js`を編集してみましょう。変数名`hello_world`は`helloWorld`に変更します。2行目の`console.log`は削除しましょう。修正後のコードは次のようになります。\n\n```js twoslash title=\"src/helloWorld.js\"\nexport const helloWorld = \"Hello World\";\n```\n\n再びESLintでチェックして、もう問題がなくなっているか確認してみましょう。\n\n```shell\nnpx eslint src\n```\n\nこの実行結果に何も出力されなければ、問題点が解消されています。\n\n### コードを自動修正する\n\nESLintのルールの中には、コードの自動修正ができるものがあります。たとえば、[`semi`](https://eslint.org/docs/rules/semi)は、文末セミコロンをつけるつけないを定めるルールですが、これは自動修正に対応しています。ここでは、`semi`を使ってESLintの自動修正をためしてみましょう。\n\nまず、設定ファイル`.eslintrc.js`の`rules`に`semi`を追加します。\n\n```js twoslash {14} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  rules: {\n    \"no-console\": \"error\",\n    camelcase: [\"error\", { properties: \"never\" }],\n    semi: [\"error\", \"always\"],\n  },\n};\n```\n\nこのルール設定では、`\"always\"`を指定しています。これは、文末セミコロンを必須にする設定です。\n\nつぎに、`src/helloWorld.js`のコードのセミコロンを消して保存してください。\n\n```js twoslash title=\"src/helloWorld.js\"\n// prettier-ignore\nexport const helloWorld = \"Hello World\"\n```\n\n自動修正の前にチェックだけを実行し、`semi`についての問題が報告されるか確認します。\n\n```shell\nnpx eslint src\n```\n\n次のような結果が表示されれば、追加した`semi`ルールが効いていることになります。\n\n![](/img/tutorial/eslint/terminal-npx-eslint-src-semi.svg)\n\nESLintでコードを自動修正するには、`eslint`コマンドに`--fix`オプションをつけます。次のコマンドを実行し、自動修正してみましょう。\n\n```shell\nnpx eslint src --fix\n```\n\n自動修正が成功していれば、出力は何も表示されずに処理が終了します。自動修正が効いているかを確認するために、`src/helloWorld.js`を開いてみてください。文末にセミコロンが追加されているでしょうか。追加されていれば自動修正成功です。\n\n:::note ここまでのふりかえり\n\n- `src/helloWorld.js`を作りました。\n- `npx eslint src`を実行し、`src`ディレクトリをチェックしてみました。\n- コードを手直しして、ESLintのチェックを通過する流れを体験しました。(`camelcase`, `no-console`)\n- `npx eslint src --fix`を実行し、ESLintの自動修正機能を試しました。(`semi`)\n\n:::\n\n### ESLintにはどんなルールがある？\n\nここまでのチュートリアルでは3つのルールを扱いました(`camelcase`、`no-console`、`semi`)。ESLintにはもっと多くのルールがあります。ルール数は200を超えます。\n\nルールの一覧は、[公式ドキュメントのRules](https://eslint.org/docs/rules/)にあります。この一覧では、どのルールが自動修正に対応しているかも確認できます。\n\n### Shareable configを導入する\n\nESLintのルールは数があまりにも多いため、ルールをひとつひとつ調べて導入していくのは大変です。そこで、お勧めなのがshareable configの活用です。\n\nshareable configは、誰かが設定したルールのプリセットです。これを導入すると、自分でルールを設定する手間が省けます。\n\n有名なshareable configのひとつに、ESLint公式が公開している`eslint:recommended`があります。これを導入すると、[Rulesの一覧](https://eslint.org/docs/rules/)でチェックマークがついているルールが一括して有効化されます。これは公式が提供してるため有名ですが、有効になっているルールが少ないため、実務では物足りなさがあるかもしれません。\n\n第三者が公開しているshareable configもあり、次にあげるものは実務でも広く使われています。\n\n| 名前                        | 作成        | 準拠するコーディング規約                                        |\n| --------------------------- | ----------- | --------------------------------------------------------------- |\n| [eslint-config-airbnb]      | Airbnb      | [Airbnb JavaScript Style Guide]、[Airbnb React/JSX Style Guide] |\n| [eslint-config-airbnb-base] | Airbnb      | [Airbnb JavaScript Style Guide]                                 |\n| [eslint-config-standard]    | Standard JS | [JavaScript Standard Style]                                     |\n| [eslint-config-google]      | Google      | [Google JavaScript Style Guide]                                 |\n\n[airbnb react/jsx style guide]: https://github.com/airbnb/javascript/tree/master/react\n[eslint-config-airbnb]: https://www.npmjs.com/package/eslint-config-airbnb\n[eslint-config-airbnb-base]: https://www.npmjs.com/package/eslint-config-airbnb-base\n[eslint-config-standard]: https://www.npmjs.com/package/eslint-config-standard\n[eslint-config-google]: https://www.npmjs.com/package/eslint-config-google\n\n上のshareable configはコーディング規約に基づいて作成されているため、文書としてのコーディング規約とESLintの設定をセットでプロジェクトに導入できる利点があります。\n\nこのチュートリアルでは、人気のAirbnbのものを使っていきます。Airbnbの設定には、[eslint-config-airbnb]と[eslint-config-airbnb-base]の2つがあります。前者は、React向けの設定が追加で盛り込まれています。今回はReactは扱わないので、よりシンプルな後者を導入します。\n\n<figure><figcaption>各shareable configのインストール件数の推移</figcaption><iframe src=\"https://npmcharts.com/compare/eslint-config-airbnb-base,eslint-config-airbnb,eslint-config-standard,eslint-config-google?interval=30&log=false&minimal=true\" height=\"500\" width=\"100%\"></iframe></figure>\n\nまず、Yarnで`eslint-config-airbnb-base`をインストールします。その際、合わせて`eslint-plugin-import`も導入します。\n\n```shell\nyarn add -D \\\n  'eslint-config-airbnb-base@^15' \\\n  'eslint-plugin-import@^2'\n```\n\n次に、設定ファイル`.eslintrc.js`の`rules`を消します。その上で、`extends: [\"airbnb-base\"]`を追加してください。\n\n```js twoslash {11} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  extends: [\"airbnb-base\"],\n};\n```\n\nこれで、shareable configの導入は完了です。\n\nチェックを試すために、`src/helloWorld.js`を次の内容に置き換えてください。\n\n```js twoslash title=\"src/helloWorld.js\"\nexport const hello_world = \"Hello World\";\nconsole.log(hello_world);\n```\n\nこのコードはAirbnbの規約にわざと違反する内容になっています。\n\n最後に`eslint`を実行し、チェックを動かしてみましょう。\n\n```shell\nnpx eslint src\n```\n\nすると、次のような結果が得られるはずです。\n\n![](/img/tutorial/eslint/terminal-npx-eslint-src-airbnb.svg)\n\nここで報告されている問題点は、次のような内容になります。\n\n- `import/prefer-default-export`: デフォルトエクスポートを使わければなりません。\n- `camelcase`: 変数`hello_world`はキャメルケースでなければなりません。\n- `quotes`: 文字列リテラルはシングルクォートで囲む必要があります。\n- `no-console`: `console.log`は残しておいてはいけません。\n\n続いて、shareable configのルールを上書きする方法を学んでいきましょう。\n\n上の結果では、`import/prefer-default-export`違反が報告されていました。これは、名前付きエクスポート(`export const helloWorld = \"...\"`)ではなく、デフォルトエクスポート(`export default \"...\"`)にすべきというエラーです。しかし、ここでは名前付きエクスポートを使いたいので、このルールをオフにすることで警告されないようにしてみましょう。ルールを上書きするには、`.eslintrc.js`の`rules`に`\"import/prefer-default-export\": \"off\"`を追加します。\n\n```js twoslash {12-14} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  extends: [\"airbnb-base\"],\n  rules: {\n    \"import/prefer-default-export\": \"off\",\n  },\n};\n```\n\nさらに、文字列リテラルはダブルクォートのほうを使いたいので、`rules`に`quotes: [\"error\", \"double\"]`を追加します。\n\n```js twoslash {14} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  extends: [\"airbnb-base\"],\n  rules: {\n    \"import/prefer-default-export\": \"off\",\n    quotes: [\"error\", \"double\"],\n  },\n};\n```\n\n再び`eslint`を実行して、ルールの上書きが効いているか確認してみましょう。\n\n```shell\nnpx eslint src\n```\n\n次のように、出力結果からデフォルトエクスポートと文字列クォートについての警告が消えていれば、ルールが効いています。\n\n![](/img/tutorial/eslint/terminal-npx-eslint-src-airbnb-with-rules.svg)\n\n### ルールを部分的に無効化する\n\n`.eslintrc.js`で設定した規約はプロジェクト全体に及びます。コードを書いていると、どうしても規約を破らざるをえない部分が出てくることがあります。その場合は、コードのいち部分について、ルールを無効化することもできます。\n\n部分的にルールを無効にするには、その行の前にコメント`eslint-disable-next-line`を追加します。たとえば、次の例ように書いておくと、変数名`hello_world`がキャメルケースでなくても、ESLintは警告を出さなくできます。\n\n```js twoslash\n// eslint-disable-next-line camelcase\nexport const hello_world = \"Hello World\";\n```\n\nこの方法はいざというときに知っておくとよいというものです。ルール無効化コメントだらけになってしまうと本末転倒です。節度を持って使うのが望ましいです。\n\n:::note ここまでのふりかえり\n\n- shareable configの`eslint-config-airbnb-base`を導入しました。\n- これのルールを一部上書きしてみました。\n  - `import/prefer-default-export`を無効化\n  - `quotes`の指定をシングルクォートからダブルクォートに変更\n- ルール無効化コメント`// eslint-disable-next-line`を試しました。\n\n:::\n\n## ESLintでTypeScriptをリントしよう\n\n[eslintでtypescriptをリントしよう]: #eslintでtypescriptをリントしよう\n\nここまでのチュートリアルでは、JavaScriptにESLintをかける方法を学んできました。ここからは、TypeScriptにESLintを使う方法を学んでいきます。\n\nそもそもESLintでは、TypeScriptはチェックできません。これを補うのが[TypeScript ESLint]です。これを導入するとESLintでTypeScriptがチェックできるようになります。\n\n[typescript eslint]: https://typescript-eslint.io/\n\n### プロジェクトを作成する {#create-typescript-project}\n\nここからは別のプロジェクトを作り、その新プロジェクトでチュートリアルを進めていきます。空のディレクトリを作り、その中に最低限のpackage.jsonを配置してください。\n\n```shell\nmkdir eslint-typescript-tutorial\ncd eslint-typescript-tutorial/\necho '{\"name\": \"eslint-typescript-tutorial\",\"license\": \"UNLICENSED\"}' > package.json\n```\n\n### TypeScriptを導入する\n\nTypeScript ESLintを使うには、TypeScript環境を構築しておく必要があります。まず、`typescript`を導入しておいてください。合わせてNode.jsの型定義`@types/node`もインストールしておきます。この型情報は、`.eslintrc.js`などのNode.js環境で実行されるファイルをESLintでチェックするときに利用されます。\n\n```shell\nyarn add -D 'typescript@^4.6' '@types/node@^16'\n```\n\nTypeScriptコンパイラの設定ファイルも作っておきます。\n\n```shell\ntouch tsconfig.json\n```\n\ntsconfig.jsonの内容はこうします。\n\n```json title=\"tsconfig.json\"\n{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n続いて、`src`ディレクトリにTypeScriptファイル`helloWorld.ts`を追加します。内容は空で構いません。\n\n```shell\nmkdir src\ntouch src/helloWorld.ts\n```\n\nコンパイルもできるか試してみましょう。\n\n```shell\nnpx tsc\n```\n\nコンパイルが成功すると、`dist/helloWorld.js`が生成されます。\n\nこの段階では、ディレクトリ構成が次のようになっているはずです。\n\n```text title=\"ディレクトリ構成\"\n.\n├── dist\n│   └── helloWorld.js\n├── node_modules\n├── package.json\n├── src\n│   └── helloWorld.ts\n├── tsconfig.json\n└── yarn.lock\n```\n\n### TypeScript ESLintを導入する\n\nESLint本体と[TypeScript ESLint]の両方をインストールします。\n\n```shell\nyarn add -D \\\n  'eslint@^8' \\\n  '@typescript-eslint/parser@^5' \\\n  '@typescript-eslint/eslint-plugin@^5'\n```\n\nTypeScript ESLintは2つのパッケージから成ります。`@typescript-eslint/parser`は、ESLintにTypeScriptの構文を理解させるためのパッケージです。`@typescript-eslint/eslint-plugin`は、TypeScript向けのルールを追加するパッケージです。\n\nESLintがインストールされ、実行可能になっているかバージョンを表示して確認しましょう。\n\n```shell\nnpx eslint -v\nv8.15.0\n```\n\n### TypeScript ESLintにはどんなルールがある？\n\nESLintの[200以上のルール](https://eslint.org/docs/rules/)に加えて、TypeScript ESLintを導入すると、100以上のルールが追加されます。追加されるルールの一覧は、[TypeScript ESLintのドキュメント](https://typescript-eslint.io/rules/)で確認できます。\n\n:::note ここまでのふりかえり\n\n- 新規プロジェクト`eslint-typescript-tutorial`を作成しました。\n- TypeScriptをインストールし、`tsconfig.json`を設定しました。\n- 中身が空の`src/helloWorld.ts`を作成し、コンパイルしてみました。\n- ESLintとTypeScript ESLintをインストールしました。\n\n:::\n\n### TypeScript向けのshareable configを導入する\n\nコーディング規約[Airbnb JavaScript Style Guide]に準拠したshareable configをインストールします。\n\n```shell\nyarn add -D \\\n  'eslint-config-airbnb-base@^15' \\\n  'eslint-plugin-import@^2' \\\n  'eslint-config-airbnb-typescript@^17'\n```\n\n`eslint-config-airbnb-base`はJavaScript向けのshareable configです。これを上書きして、TypeScript ESLintのルールを追加したり、TypeScriptコンパイラがチェックするためESLintでチェックする必要がないルールを除外する設定を加えるのが`eslint-config-airbnb-typescript`です。`eslint-plugin-import`は依存関係上、導入が必要なパッケージです。\n\n### TypeScript ESLintの設定ファイルを作る\n\nTypeScript ESLintを動かすためには、次の2つの設定ファイルを作る必要があります。\n\n- tsconfig.eslint.json\n- .eslintrc.js\n\nこれらファイルをプロジェクトルートに作成してください。\n\n```shell\ntouch tsconfig.eslint.json .eslintrc.js\n```\n\n```text title=\"作成後のディレクトリ構造\"\n.\n├── .eslintrc.js\n├── dist\n│   └── helloWorld.js\n├── node_modules\n├── package.json\n├── src\n│   └── helloWorld.ts\n├── tsconfig.eslint.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n#### tsconfig.eslint.json\n\nTypeScript ESLintは、チェック時に型情報を利用するために、TypeScriptコンパイラを使います。その際のコンパイラ設定を`tsconfig.eslint.json`に書きます。コンパイラ設定は、`tsconfig.json`の内容を`extends`で継承しつつ、上書きが必要なところだけ記述していきます。\n\n```json title=\"tsconfig.eslint.json\"\n{\n  \"extends\": \"./tsconfig.json\"\n}\n```\n\n今回は、TypeScriptファイルに加えて、ESLintの設定ファイル`.eslintrc.js`自体もESLintのチェック対象に含めたいので、`allowJs`の追加と`include`の上書きをします。\n\n```json {2-5} title=\"tsconfig.eslint.json\"\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"allowJs\": true\n  },\n  \"include\": [\"src\", \".*.js\"]\n}\n```\n\n`\".*.js\"`は、`.eslintrc.js`などドット始まりのJSファイルにマッチするパターンです。パターンマッチにしておくことで、将来的に導入される他の設定ファイルもチェック対象に含めるようにできます。\n\nまた、テストフレームワーク「Jest」の設定ファイルでは、`jest.config.js`のようにドットはじまりでないJSファイルもありえます。このようなファイルが追加されるのを見越して、`\"*.js\"`もあらかじめ追加しておくとよいです。\n\n```json {5} title=\"tsconfig.eslint.json\"\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"allowJs\": true\n  },\n  \"include\": [\"src\", \".*.js\", \"*.js\"]\n}\n```\n\nこのように、TypeScript ESLintでチェックする対象は、`include`に追加していく必要があります。\n\n`tsconfig.eslint.json`が正しく設定されているか、次のコマンドを実行して出力を確認してください。\n\n```shell\nnpx tsc --showConfig --project tsconfig.eslint.json\n```\n\n設定が正しいと、次のような出力になるはずです。\n\n```text\n{\n    \"compilerOptions\": {\n        \"outDir\": \"./dist\",\n        \"allowJs\": true\n    },\n    \"files\": [\n        \"./src/helloWorld.ts\",\n        \"./.eslintrc.js\"\n    ],\n    \"include\": [\n        \"src\",\n        \".*.js\",\n        \"*.js\"\n    ]\n}\n```\n\n#### .eslintrc.js\n\n次にESLintの設定ファイル`.eslintrc.js`を作ります。内容は次のとおりにしてください。\n\n```js twoslash {3-4,12-13,15,18-19,23} title=\".eslintrc.js\"\nmodule.exports = {\n  root: true,\n  parser: \"@typescript-eslint/parser\",\n  plugins: [\"@typescript-eslint\"],\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n    project: \"./tsconfig.eslint.json\",\n    tsconfigRootDir: __dirname,\n  },\n  ignorePatterns: [\"dist\"],\n  extends: [\n    \"airbnb-base\",\n    \"airbnb-typescript/base\",\n    \"plugin:@typescript-eslint/recommended-requiring-type-checking\",\n  ],\n  rules: {\n    \"import/prefer-default-export\": \"off\",\n    \"@typescript-eslint/quotes\": [\"error\", \"double\"],\n  },\n};\n```\n\n`root`、`env`、`parserOptions`の`ecmaVersion`と`sourceType`については[前のチュートリアル](#eslintの設定ファイルを作る)の解説をご覧ください。まだ説明していない、追加のオプションは次で説明します。\n\n#### `parser`\n\n```js twoslash {3}\nmodule.exports = {\n  // ...\n  parser: \"@typescript-eslint/parser\",\n  // ...\n};\n```\n\n`parser`で設定したパーサーを使って、ESLintはJavaScriptやTypeScriptの構文を解析します。上の例では、TypeScriptパーサーを指定しています。この指定がないと、ESLintはTypeScriptを解釈できず、エラーが発生します。\n\nTypeScriptはJavaScriptの構文を拡張した言語です。なので、このパーサーさえ入れておけば、TypeScriptに限らずJavaScriptのこのパーサーひとつで対応できます。要するに、このパーサーひとつで、TypeScriptとJavaScriptのファイルどちらもリントできるようになります。\n\n#### `plugins`\n\n```js twoslash {3}\nmodule.exports = {\n  // ...\n  plugins: [\"@typescript-eslint\"],\n  // ...\n};\n```\n\nESLintは公式が提供するルールに加えて、第三者が作成したルールを使うこともできます。第三者が作成したルールはプラグインという形で公開されています。この`plugins`フィールドにプラグインを追加すると、ルールが追加できます。上の例では、TypeScript ESLint独自のルールを追加するために、`@typescript-eslint`を設定しています。\n\n#### `parserOptions` {#parser-options-2}\n\n```js twoslash {3-7}\nmodule.exports = {\n  // ...\n  parserOptions: {\n    // ...\n    project: \"./tsconfig.eslint.json\",\n    tsconfigRootDir: __dirname,\n  },\n  // ...\n};\n```\n\n`project`と`tsconfigRootDir`はTypeScript ESLint独自のオプションです。`tsconfigRootDir`はプロジェクトルートの絶対パスを指定します。`project`は、ESLint実行時に使うコンパイラ設定ファイルを`tsconfigRootDir`からの相対パスで指定します。これらの設定は、TypeScript ESLintが型情報を参照するために必要な設定です。\n\n#### `ignorePatterns`\n\n```js twoslash {3}\nmodule.exports = {\n  // ...\n  ignorePatterns: [\"dist\"],\n  // ...\n};\n```\n\n`ignorePatterns`はESLintのチェック対象外にするファイルやディレクトリを指定するオプションです。TypeScriptプロジェクトでは、コンパイルで生成されるJavaScriptは、リントしないのが普通です。なので、`dist`ディレクトリをチェック対象外にしておきます。\n\n#### `extends`\n\n```js twoslash {3-7}\nmodule.exports = {\n  // ...\n  extends: [\n    \"airbnb-base\", // ①\n    \"airbnb-typescript/base\", // ②\n    \"plugin:@typescript-eslint/recommended-requiring-type-checking\", // ③\n  ],\n  // ...\n};\n```\n\n`extends`はshareable configを使うための設定です。①は、JavaScript向けのルールです。これを拡張してTypeScript ESLintのルールにも範囲を広げたのが②です。①と②は上の順番でないと正しく設定されないので注意してください。\n\n③はTypeScript ESLintが提供する推奨ルールセットで、型情報を要するルールを含みます。このルールセットでどのルールが有効になるかは、[公式ドキュメント](https://typescript-eslint.io/rules/)をご覧ください。\n\n#### `rules`\n\n```js twoslash {3-6}\nmodule.exports = {\n  // ...\n  rules: {\n    \"import/prefer-default-export\": \"off\",\n    \"@typescript-eslint/quotes\": [\"error\", \"double\"],\n  },\n  // ...\n};\n```\n\nここの`rules`は、shareable configで有効化されたルールを上書きするのに用いています。TypeScript ESLintで追加されたルールは、`@typescript-eslint/`が接頭辞になります。\n\n:::note ここまでのふりかえり\n\n- コーディング規約Airbnb JavaScript Style Guideに準拠したshareable configをインストールしました。\n- TypeScript ESLintの設定ファイルを作りました。\n  - tsconfig.eslint.json\n  - .eslintrc.js\n\n:::\n\n### TypeScriptをチェックする\n\nTypeScript ESLintを使う準備ができたので、いよいよTypeScriptをチェックしてみたいと思います。\n\nまず、空だった`src/helloWorld.ts`に次のコードを書いて保存してください。\n\n```ts twoslash title=\"src/helloWorld.ts\"\nexport const hello_world = \"Hello World\";\nconsole.log(hello_world);\n```\n\nそうしたら、ESLintを実行してみましょう。\n\n```shell\nnpx eslint .\n```\n\nすると、次の結果が出力されるはずです。\n\n![](/img/tutorial/eslint/terminal-npx-eslint-src-typescript.svg)\n\n2つの問題点が報告されています。1つ目は、変数名の命名規則が守られていない点についてのエラーです。2つ目は、`console.log`が使われている点についての警告です。\n\nこれらの問題点を修正してみましょう。`src/helloWorld.ts`を次の内容に変更し、保存してください。\n\n```ts twoslash title=\"src/helloWorld.ts\"\nexport const helloWorld = \"Hello World\";\n```\n\n再びESLintを実行して、問題点が解消されているか確認してみましょう。\n\n```shell\nnpx eslint .\n```\n\n出力結果に何も表示されていなければ、問題点が解決されています。\n\n以上で、ESLintでTypeScriptをリントするチュートリアルは終わりです。\n\n## VS CodeとESLintを統合しよう\n\n[vs codeとeslintを統合しよう]: #vs-codeとeslintを統合しよう\n\nここでは、Visual Studio Code(VS Code)に、ESLintを組み込む方法を説明します。\n\nESLintはコマンドひとつでコーディング規約をチェックできるようになり、それだけでも便利です。しかし、VS CodeとESLintを統合するとさらに便利になります。コードを書いているときに、リアルタイムで問題点のフィードバックが得られるようになるからです。\n\n<figure><figcaption>ESLintのエラーがVS Codeに表示される様子</figcaption>\n\n![](/img/tutorial/eslint/vscode-eslint-example.png)\n\n</figure>\n\nVS CodeとESLintを統合するには、[ESLintの拡張](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)をVisual Studio Codeのマーケットプレイスからインストールするだけです。\n\n![](/img/tutorial/eslint/vscode-marketplace.png)\n\n## JetBrains IDEとESLintを統合しよう\n\n[jetbrains ideとeslintを統合しよう]: #jetbrains-ideとeslintを統合しよう\n\nここでは、WebStormなどのJetBrains IDEに、ESLintを組み込む方法を説明します。\n\nESLintはコマンドひとつでコーディング規約をチェックできるようになり、それだけでも便利です。しかし、JetBrains IDEとESLintを統合するとさらに便利になります。コードを書いているときに、リアルタイムで問題点のフィードバックが得られるようになるからです。\n\n<figure><figcaption>ESLintのエラーがWebStormに表示される様子</figcaption>\n\n![](/img/tutorial/eslint/webstorm-eslint-example.png)\n\n</figure>\n\nWebStormは、ESLint統合機能がデフォルトで入っているので、プラグインなどをインストールする必要はありません。ESLintを有効にするには、「Preferences」を開き、検索に「eslint」と入力します(①)。絞り込まれたメニューから「ESLint」を開きます(②)。「Automatic ESLint configuration」にチェックを入れます(③)。最後に「OK」を押すと設定完了です(④)。\n\n![](/img/tutorial/eslint/webstorm-eslint-config.png)\n",
      "url": "https://typescriptbook.jp/tutorials/eslint"
    },
    {
      "title": "Reactでいいねボタンを作ろう",
      "content": "# Reactでいいねボタンを作ろう\n\nこのチュートリアルでは、TypeScriptとReactの両方を用いて、SNSでよく見かける「いいねボタン」のUIを実装します。\n\n本チュートリアルは、TypeScriptとReactによるコーディングの体験をすることを主眼に置いています。そのため、TSとReactの理論的な説明は省きます。「TypeScriptとReactでUIを開発するにはどのような流れになるのか」を感じ取って頂くことを目的としています。\n\nReactの専門書と比べて、本書の解説は詳しさや正確さは劣ります。それでも、初めてReactに触れる方でも読み進められるよう、Reactについて随時ワンポイント解説をしていくので、安心してお読みください。\n\nこのチュートリアルで作成するいいねボタンの最終的な成果物は[デモサイト](https://like-button.typescriptbook.jp)で確認できます。チュートリアルを開始する前に事前に触ってみることで、各ステップでどんな実装をしているかのイメージが掴みやすくなります。また、完成形のソースコードは[GitHub](https://github.com/yytypescript/like-button)で確認することができます。\n\n## Reactとは？\n\nReactはFacebook社が開発した、ウェブアプリケーションのUIを作るためのパッケージです。JavaScriptやTypeScriptだけでもインタラクティブなUIは実装できます。しかし、UIが複雑になるとReactなしではコードの記述量が増大したり、可読性が悪くなったりと難易度が上がります。なんといっても、UIが今どのような状態なのかを管理するのは、プログラマが把握しきれない複雑さになることがあります。Reactを使うと、複雑なUIやインタラクションを短く簡潔に読みやすく書けるようになり、状態の管理も分かりやすくなります。\n\n## Reactの3大特徴\n\nReactはどのような特徴を持ったパッケージなのでしょうか？ここではReactの特徴を3つに分けて説明します。Reactについて多少の予備知識を得たい方は、このセクションをお読みください。今すぐコードを書きたいという方は、ここは読み飛ばしても問題ありません。\n\n### 特徴その1: 仮想DOM\n\nReactは仮想DOM(virtual DOM)という考えを採用しています。仮想DOMを理解するには、仮想ではない普通のDOMが何かを知る必要があります。DOM(document object model)とは、HTMLをJavaScriptから参照・操作する仕組みです。これのおかげで、HTMLを文字列操作ではなく、オブジェクトとして処理できます。DOMはHTMLを操作するためのAPIのようなものです。\n\nプログラマがDOMを操作すると、間接的にHTMLが書き換えられ、その結果が画面に描画されます。多くの動的なUIはDOM操作で成り立っています。\n\n```js twoslash\n// <input id=\"email\">の文字色を赤色にするDOM操作の例\nconst emailInput = document.getElementById(\"email\");\nemailInput.style.color = \"red\";\n```\n\nDOMは必ずしもプログラマにとって使いやすいAPIではありません。上の例のようなスタイルを少し変更するくらいなら実用的です。しかし、複雑なUIを作ろうとすると途端に難しくなります。注意深く実装しないと、表示や状態の変更し忘れといったバグを生みやすくなります。操作の方法が悪くパフォーマンス面で問題が出たりします。\n\n仮想DOMはリアルDOMのプロキシのようなものです。リアルDOMと比べて、状態管理上のバグを起こしにくい設計になっています。加えて、パフォーマンス面では描画処理の最適化もします。プログラマにとっては、リアルDOMを扱うときのような慎重さが不要になります。画面表示を変えたければ、仮想DOMを操作します。仮想DOMに起こった変更はリアルDOMに伝わり、画面に現れてきます。仮想DOMは、複雑なUIを苦労せずに実装するための仕組みと言えます。\n\n### 特徴その2: 宣言的UI\n\nReactの2つ目の特徴はUIを宣言的に書ける点です。Reactを使わずにUIを実装すると、命令的なコードになります。命令的なコードでは、何かを表示したい場合でもどのように表示するかのhowの部分を細かく書く必要があります。\n\n次の簡単なHTMLのリストを表示するために、命令的なコードと宣言的なコードで書き方がどう違うかを見ていきましょう。\n\n```html\n<ul>\n  <li>リンゴ</li>\n  <li>オレンジ</li>\n  <li>ぶどう</li>\n</ul>\n```\n\nまず、命令的なコードでは、次のようになります。\n\n```js twoslash\nconst list = document.createElement(\"ul\");\nconst apple = document.createElement(\"li\");\napple.innerText = \"リンゴ\";\nlist.append(apple);\nconst orange = document.createElement(\"li\");\norange.innerText = \"オレンジ\";\nlist.append(orange);\nconst grape = document.createElement(\"li\");\ngrape.innerText = \"ぶどう\";\nlist.append(grape);\n```\n\nこの処理を日本語に書き下すと、次のようになります。\n\n- `ul`要素を作り、変数`list`に代入する\n- `li`要素を作り、変数`apple`に代入する\n- `apple`のテキストは「リンゴ」にする\n- `list`に`apple`を追加する\n- `li`要素を作り、変数`orange`に代入する\n- `orange`のテキストは「オレンジ」にする\n- `list`に`orange`を追加する\n- ...\n\n3つの果物のリストのような簡単なUIでも、どのように作ったらいいかを細かく記述しなければなりません。これを見るだけでも、UIを命令的に書くのは大変で、保守していくことも考えると望ましい書き方には思えないのではないでしょうか。\n\n今度は宣言的な書き方を見てみましょう。次はReactでの書き方です。\n\n```js twoslash\nfunction Fruits() {\n  return (\n    <ul>\n      <li>リンゴ</li>\n      <li>オレンジ</li>\n      <li>ぶどう</li>\n    </ul>\n  );\n}\n```\n\n見てのとおり、どのように表示するかの部分はなく、「このような表示になってほしい」という目標だけが書かれています。\n\n宣言的UIでは、実装の細部やアルゴリズムを気にしなくてよいです。「どんなUIにしたいか」の一点に集中してコードを書けるようになります。\n\n### 特徴その3: コンポーネントベース\n\nReactの3つ目の特徴は、コンポーネントベースです。コンポーネントというのはUIの部品のことです。たとえば、小さいもので言えばボタンや入力欄、より大きめの部品だとフォーム、さらに大きい部品ではページもコンポーネントです。\n\nReactには、小さいコンポーネントを組み合わせ、大きなアプリケーションを成すという思想があります。ここがReactがコンポーネントベースと言われるゆえんです。\n\nコンポーネントベースのメリットは、同じコンポーネントを再利用できる点です。たとえば、ボタンコンポーネントを1つ作っておけば、それをアプリケーションの至るところで使い回せます。プログラマは同じコードを何度も書かなくて済み、開発効率が良くなります。\n\n加えて、オープンソースのコンポーネントも数多く公開されています。プログラマは自分でゼロからコンポーネントを作らなくても、公開されているコンポーネントを利用することもできます。カレンダーUIのような自力で作ると面倒なコンポーネントも種類豊富に公開されているので、開発者はオープンソースのコンポーネントを使うとより手軽にアプリケーションが作れます。\n\n## このチュートリアルに必要なもの\n\nこのチュートリアルをやるに当たって、必要なツールがあります。それらはここにリストアップしておくのであらかじめ用意しておいてください。\n\n- Node.js (このチュートリアルではv18.15.0で動作確認しています)\n- NPM\n- Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)\n- VS CodeやWebStormなどのエディター\n\n## Yarnのインストール\n\nチュートリアルではパッケージ管理ツールとして Yarn を利用しているので、最初にインストールをしておきます。\n\nすでにインストール済みの方はここのステップはスキップして大丈夫です。\n\n```sh\nnpm install -g yarn\n```\n\n## プロジェクトを作る\n\nまず、`yarn create`コマンドでReactプロジェクトのひながたを生成します。\n\n```sh\nyarn create react-app like-button --template typescript\n```\n\n1分ほどするとひながたの生成が完了します。like-buttonディレクトリが生成されるので、次のコマンドを実行してそのディレクトリに移動すると、ひながたが生成されているのが分かります。\n\n```sh\ncd ./like-button\n```\n\n```text title=\"生成後のディレクトリ構成\"\n.\n├── .gitignore\n├── README.md\n├── package.json\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n├── src\n│   ├── App.css\n│   ├── App.test.tsx\n│   ├── App.tsx\n│   ├── index.css\n│   ├── index.tsx\n│   ├── logo.svg\n│   ├── react-app-env.d.ts\n│   ├── reportWebVitals.ts\n│   └── setupTests.ts\n├── tsconfig.json\n└── yarn.lock\n```\n\n`yarn create react-app`ではReactのインストールも自動で行われます。インストールされたReactのバージョンを確認するには次のコマンドを用います。\n\n```sh\nyarn list react\n```\n\n```text title=\"yarn list reactの実行結果\"\nyarn list v1.22.19\n└─ react@18.2.0\n```\n\nこのディレクトリにて`yarn start`を実行すると、Reactのローカル開発サーバーが起動します。\n\n```sh\nyarn start\n```\n\n開発サーバーが起動すると自動的にブラウザが開かれ、ひながたアプリの様子が確認できます。ブラウザが起動しない場合は、ターミナルに表示されているURLをブラウザで開いてください。\n\n![ひながた初期状態の画面](react-like-button-tutorial/screen1.png)\n\nReactのローカル開発サーバーを停止する場合は、Ctrl + Cキーを押してください。\nCtrlキーとCキーを同時に押すと、コマンドを中断することができます。\n\nここからは実際にコードを書いて行きますので、生成したlike-buttonプロジェクトをお好みのエディターで開いてください。\n\nひながた初期状態の上のページはsrc/App.tsxの内容が描画されています。ためしに、src/App.tsxを変更してみましょう。App.tsxの`<header>`要素の中身を消して、「TypeScriptはいいぞ」に書き換えてみましょう。\n\n```tsx twoslash {7} title=\"App.tsx\"\n// @noErrors\nimport React from \"react\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">TypeScriptはいいぞ</header>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n:::tip ワンポイント解説: .tsxって何？TypeScriptの中にHTMLが書ける？\n\nApp.tsxを見てこのような疑問を持ったのではないでしょうか。このHTMLに見える部分はJSXと言われるものです。JSXはJavaScriptを拡張した言語で、JavaScriptの中にXMLを直接書けるようにしたものです。XMLとHTMLは厳密には異なりますが、ここでは同じものと考えてください。\n\nUIを実装しようとするとHTMLと密接に関わるコードを書くことになりますが、JavaScriptの構文だけでHTMLを表現しようとすると、可読性が低くなりがちです。ReactではJSXを採用することで可読性の問題を解決しました。JSXは、HTMLをほぼありのままに書けるので、可読性の高いコードになります。\n\nTypeScriptとJSXは本来無関係の言語ですが、開発者の利便性のために、TypeScriptでもJSXが書けるようになっています。\n\nJSXを書いたJavaScriptファイルは拡張子を.jsxにします。同様にTypeScriptファイルは.tsxにします。\n\n:::\n\n[JSX](../reference/jsx/README.md)\n\n書き換えたらファイルを保存し、ブラウザで確認してみてください。ブラウザに書いた文言が表示されていればOKです。\n\n![変更が反映された状態](react-like-button-tutorial/screen2.png)\n\n## ボタンを作る場所を用意する\n\nここからは、いいねボタンを実際に作っていきます。まずは、いいねボタンを実装する場所を作ります。\n\nまず、先ほど「TypeScriptはいいぞ」と書いたところを`<LikeButton />`に変えます。次に、`LikeButton`関数を作ります。次のコードのようになるようにしてください。\n\n```tsx twoslash {7-9,14-16} title=\"App.tsx\"\nimport React from \"react\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <LikeButton />\n      </header>\n    </div>\n  );\n}\n\nfunction LikeButton() {\n  return <span>いいねボタン予定地</span>;\n}\n\nexport default App;\n```\n\nこの`LikeButton`関数が、これからいいねボタンを作っていく場所になります。\n\n:::tip ワンポイント解説: 関数コンポーネント\n\nReactのJSXでは、HTMLタグの`div`や`header`が使えるだけでなく、自分で定義した関数もタグとして使うことができます。上で定義した`LikeButton`関数はその一例です。JSXを戻り値として返す関数だけがタグとして使えます。上の例では、`span`タグが戻り値になっているのがわかると思います。\n\nJSXを戻り値にする関数をReact用語で「関数コンポーネント」と言います。Reactを使ったフロントエンドアプリケーション開発では、関数コンポーネントをうまく使うことがポイントになります。画面の部品をコンポーネントにしておくと、再利用できたり変更が一箇所で済んだりと、開発や保守がしやすくなります。\n\n:::\n\n:::tip ワンポイント解説: JSXのセルフクロージング要素\n\n先ほども書いたように、JSXはJavaScriptの拡張構文であり、厳密にはHTMLと異なるものです。そのため、JSXにはHTMLとは異なる書き方や制約があります。\n\n`<LikeButton />`のようにスラッシュをタグに含める書き方も、JSXならではの書き方です。これはセルフクロージング要素(self-closing element)と呼ばれます。自己閉じ要素、自己完結型要素と呼ばれることもあります。`<LikeButton></LikeButton>`のように子要素などを持たない場合に、`<LikeButton />`のように末尾に`/`をつけることで、短く表現できる書き方です。\n\nJSXとHTMLのその他の違いについては、[Reactの公式ドキュメント](https://beta.reactjs.org/learn/writing-markup-with-jsx)を参照してください。\n\n:::\n\n## ボタンのビジュアルを作り込む\n\nいいねボタンの実装場所が確保できたので、ここではボタンのタグを変更したり、CSSを書いたりして、ボタンの見た目を作っていきます。今回作るボタンは次の図のようなシンプルなものです。\n\n![今回実装するいいねボタン](react-like-button-tutorial/like1.png)\n\nまずは、`LikeButton`関数の`span`タグのテキストを`♥ {count}`にします。この`count`は変数なので、その変数も一緒に定義します。\n\n```tsx twoslash {2-3} title=\"App.tsx\"\nfunction LikeButton() {\n  const count = 999;\n  return <span>♥ {count}</span>;\n}\n```\n\n`count`変数は固定値になっていますが、あとでクリックしたときに増減するように変えるので今はこれで構いません。JSX内では`{}`で囲まれた部分には、JavaScriptの変数や式が書けます。上の例は変数名だけですが、`{count + 1}`のような式も有効です。\n\n次に、CSSのクラスを割り当てるために、`span`タグに`className`属性を追加します。\n\n```tsx twoslash {3} title=\"App.tsx\"\nfunction LikeButton() {\n  const count = 999;\n  return <span className=\"likeButton\">♥ {count}</span>;\n}\n```\n\n:::tip ワンポイント解説: class属性は使わない？\n\nHTMLではCSSクラスを指定するのに`class`属性を用いるので、ここで`className`属性にしていることに驚いたのではないでしょうか。これは初期のReactがDOMプロパティに直接値をセットしていた名残りです。DOMでは、HTMLの`class`属性が`className`プロパティになります。現在は、ReactがDOMプロパティを直接セットすることがなくなったので、`className`属性に縛られる技術的理由はないのですが、React開発陣は`class`属性への乗り換えは慎重のようです。これまで作られたコンポーネントが動かなくなるかも知れないからです。また、両方サポートする気もないようです。`class`と`className`のどちらもOKとなると混乱を招くからです。\n\n:::\n\n続いて、`likeButton`クラスのCSSを書いていきます。Reactではスタイルシートを実装するのにいくつか方法がありますが、ここではApp.cssにCSSを書く方法にします。次のCSSをApp.cssの最後に追加してください。\n\n```css title=\"App.css\"\n.likeButton {\n  background-color: rgb(231, 76, 60);\n  color: white;\n  padding: 0.8rem;\n  border-radius: 0.4rem;\n  cursor: pointer;\n}\n```\n\nApp.cssに上の内容を書いたら、ブラウザで確認してみましょう。スタイルが効いていれば、次の図のような表示になっているはずです。\n\n![スタイルが効いている様子](react-like-button-tutorial/screen3.png)\n\n:::caution トラブルシューティング\n\nApp.cssはApp.tsxで`import`しているので特に何もしなくても`LikeButton`コンポーネントのスタイルに反映されます。もし、スタイルが反映されていないようなら、App.tsxにApp.cssを`import`するコードがあるか確認してください。\n\n```tsx twoslash {2} title=\"App.tsx\"\nimport React from \"react\";\nimport \"./App.css\"; // この行があるか確認する\n\nfunction App() {\n  // ...\n}\n```\n\n:::\n\nここまでで、ボタンのビジュアルの作り込みは一旦完了です。\n\n## ボタンに機能をつける\n\nこのままでは、ボタンを押しても何も起きません。ここからは、ボタンを押したときに999がひとつ増えて1,000にカウントアップされる機能を作っていきます。\n\n現状のボタンは`count`変数を表示していますが、この変数は固定値になっています。この値が変動できるように、Reactの`useState`関数を使い、カウント数の状態をReactに管理させるようにします。\n\n```tsx twoslash {1,7} title=\"App.tsx\"\nimport React, { useState } from \"react\";\n//          ^^^^^^^^^^^^^^ここも追加\n\n/* ... */\n\nfunction LikeButton() {\n  const [count, setCount] = useState(999); // このように書き換える\n  return <span className=\"likeButton\">♥ {count}</span>;\n}\n```\n\nこの`useState`は関数コンポーネントに状態を持たせるためのReactの機能です。`useState`の戻り値を`count`と`setCount`の2つの変数に代入しています。`count`には`999`のような値が代入され、`setCount`には`count`の値を変更する関数が代入されます。\n\n次に、`span`要素をクリックしたときに、`count`の値を増加する`handleClick`関数を実装します。この関数では、現在の`count`の値に1を足した値を`setCount`関数に渡すようにします。そして、`span`要素の`onClick`属性に`handleClick`関数を渡します。\n\n```tsx twoslash {3-5,7} title=\"App.tsx\"\nimport React, { useState } from \"react\";\n// ---cut---\nfunction LikeButton() {\n  const [count, setCount] = useState(999);\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n  return (\n    <span className=\"likeButton\" onClick={handleClick}>\n      ♥ {count}\n    </span>\n  );\n}\n```\n\nこれで、ボタンをクリックしたらいいねの数が増えるようになります。\n\n![](react-like-button-tutorial/like2.gif)\n\n以上でTypeScriptで作るReactいいねボタンは完成です。\n",
      "url": "https://typescriptbook.jp/tutorials/react-like-button-tutorial"
    },
    {
      "title": "TypeScriptの学習リソース",
      "content": "# TypeScriptの学習リソース\n\nTypeScriptには本書や開発元のMicrosoftが提供しているものを含め、学習や調査に役立つ数多くのリソースが存在しています。\n\nこのページでは本書の解説を読んだ後や、読んでいる途中でも利用できるTypeScriptについての情報源を紹介します。さらにこのページの後半では学習や開発において非常に重要となる公式ドキュメントについて構造と読み方などを含めた攻略方法を解説します。\n\n:::tip 効率的にリソースを利用しよう\nこのページで紹介したリソースのすべてを完全に読みこなすというのは困難かつ非効率なので、それぞれの情報源について役割やレベルなどを意識して取捨選択して部分的に読み込んだり、目的に応じて使い分けることをオススメします。\n:::\n\n## リソースの紹介\n\n### Microsoft公式の情報源\n\nMicrosoftが公式で提供している主要な情報源を紹介します。\n\n| リソース                                                                | 特徴                                                                                                                                                                  |\n| ----------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [TypeScript Documentation](https://www.typescriptlang.org/docs/)        | TypeScriptの公式ドキュメントです。最重要の情報源であり、学習や開発の際に必須のリファレンスとなります。このページの後半で内容の詳細と攻略方法を解説します。            |\n| [Microsoft Developer Blogs](https://devblogs.microsoft.com/typescript/) | Microsoftの開発者ブログにおけるTypeScriptについての記事です。新しいバージョンの情報告知など、TypeScriptの最新情報を知ることができます。                               |\n| [FAQ](https://github.com/microsoft/TypeScript/wiki/FAQ)                 | 開発リポジトリのwiki上にまとめられたTypeScriptについてのよくある質問集です。挙動やプラクティスなどについてWhy/What/How/Shouldのタイプの質問と回答が提供されています。 |\n\n公式から提供される情報源の中でもっとも重要なものが公式ドキュメントですが、公式ドキュメントに記載されていない細かい挙動や概念などは開発リポジトリにあるいくつかの情報源を参照する必要があります。\n\n| リソース                                                                                                                            | 特徴                                                                                                                                                                                                                           |\n| ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [Roadmap](https://github.com/microsoft/TypeScript/wiki/Roadmap)                                                                     | TypeScriptに将来的に追加される機能のロードマップです。これまでリリースされてきた各バージョンで導入された機能のプルリクエストが一覧となっており、各プルリクエストでは言語開発者による概念や機能の詳細な説明が記載されています。 |\n| [docs/spec-ARCHIVED.md](https://github.com/microsoft/TypeScript/blob/3c99d50da5a579d9fa92d02664b1b66d4ff55944/doc/spec-ARCHIVED.md) | TypeScriptの古い仕様書であり、公式ドキュメントに未記載のいくつかの細かい挙動や概念などが記載されています。現在はmainブランチから削除されているため注意が必要です。                                                             |\n| [compiler/checker.ts](https://raw.githubusercontent.com/microsoft/TypeScript/main/src/compiler/checker.ts)                          | 型チェッカーの実装となるソースコードのファイルです。現在のTypeScriptには更新されている仕様書が存在せず、型チェックの挙動がコメントとして記載されている唯一のドキュメントとなります。                                           |\n\n### サードパーティの情報源\n\nサードパーティの情報源として人気のある学習リソースをいくつか紹介します。\n\n| リソース                                                                                                                             | 特徴                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [roadmap.sh](https://roadmap.sh/typescript)                                                                                          | 開発者が学ぶべき内容についてロードマップ形式でまとめられているサイト「roadmap.sh」のTypeScriptバージョンです。このサイトではTypeScriptという言語の全体像や学習パスをロードマップの形で俯瞰することができます。                                 |\n| [TypeScript Deep Dive 日本語版](https://typescript-jp.gitbook.io/deep-dive/)                                                         | オンライン上で公開されているオープンソースの解説書です。コンパクトながらTypeScriptについての高度な内容を知ることができます。オリジナルバージョンは英語ですが、有志による日本語翻訳があるため日本語で読むことができます。                       |\n| [プログラミングTypeScript ―スケールするJavaScriptアプリケーション開発](https://www.oreilly.co.jp/books/9784873119045/)               | O'Reilly Japanから出版されているTypeScriptの入門書です。TypeScriptのシンタックス以前に型安全性や、型チェッカーとは何か、そもそも型とは何なのかなど根本的なことから解説されており、TypeScriptの型システムについて一から理解することができます。 |\n| [プロを目指す人のためのTypeScript入門 安全なコードの書き方から高度な型の使い方まで](https://gihyo.jp/book/2022/978-4-297-12747-3)    | 技術評論社から出版されているTypeScriptの入門書です。通称「ブルーベリー本」と呼ばれ、TypeScriptのみならずJavaScriptについての解説も含まれています。                                                                                             |\n| [プレイリスト:日本一わかりやすいTypeScript入門](https://www.youtube.com/watch?v=kd8VH10jXwc&list=PLX8Rsrpnn3IW0REXnTWQp79mxCvHkIrad) | Youtubeでとらゼミから提供されているTypeScriptの解説動画シリーズです。動画で分かりやすくTypeScriptの基本について学ぶことができます。                                                                                                            |\n\n#### JavaScriptの学習リソース\n\nTypeScriptの学習にはJavaScriptの学習が欠かせません。ここではJavaScriptの学習リソースとして有名なものをいくつか紹介しておきます。実際、TypeScriptの学習の過程ではJavaScript自体についてもっと詳しく知りたいという場面も多々出てきますので、必要になった時にはこれらのドキュメントを参照することをオススメします。\n\n| リソース                                                             | 特徴                                                                                                                                                                                                                                                             |\n| -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [MDN Web Docs](https://developer.mozilla.org/ja/docs/Web/JavaScript) | JavaScriptのシンタックスや機能について記載されたWeb上のドキュメントで、Mozillaの運営でオープンソースの形で執筆されています。JavaScriptに限らずHTMLやCSS、WebAPIなどWebに関わる技術について網羅的にカバーしており、さまざまな場面でリファレンスとして機能します。 |\n| [JavaScript Primer 迷わないための入門書](https://jsprimer.net)       | ES2015以降の機能をベースにしてJavaScriptについて一から学ぶことができるWeb上のドキュメントです。読みやすいように書籍版としても出版されており、書籍で読みたい方はAmazonや達人出版会の方から入手することができます。                                                |\n\n本書と同じく、両者共にコンテンツ自体がGitHubで管理されているため、プルリクエストやissueを作成して貢献することが可能な点が特徴的です。\n\n## 公式ドキュメントの攻略\n\nTypeScriptの公式ドキュメントは英語で書かれている上に分量が多いため、手出しすることを躊躇してしまうかもしれません。\n\nとはいえ、TypeScriptの学習や開発を進める上で各機能についての正確な情報や詳細情報を知るためには公式ドキュメントを読むことが必須となるので、この項目では中核となるハンドブックを中心に公式ドキュメントの構造や読み方などを含めた攻略方法を紹介します。\n\n公式ドキュメントは本書を読み終えた後でもお世話になることが頻繁にあるため、ぜひ読み方をマスターして公式ドキュメントと仲良くなりましょう。\n\n### 構成要素\n\nまずは公式ドキュメントの構成要素から把握していきましょう。TypeScriptの公式ドキュメントは次にリストアップした複数のセクションから構成されます。\n\n| セクション            | 内容                                                                                                                                                                                                                                               |\n| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Get Started**       | 学習者のバックグラウンドやスキルに基づいたイントロダクションのセクションです。                                                                                                                                                                     |\n| **Handbook**          | ハンドブックは言語機能と挙動の包括的ガイドです。日常的なユースケースにおけるTypeScriptの機能と挙動について数時間で読めるような構成となっています。                                                                                                 |\n| **Reference**         | ハンドブックでカバーしていない応用的な話題のリファレンスとなるようなセクションです。ユーティリティ型や名前空間、型の互換性などの話題が含まれます。                                                                                                 |\n| Tutorial              | いくつかの代表的な環境でTypeScriptの導入と利用を行うためのチュートリアルです。                                                                                                                                                                     |\n| Declaration Files     | [型定義ファイル](reference/declaration-file)(`.d.ts`)についての解説を行うドキュメントです。パッケージの配布などで型定義ファイルを作成する際にはこのセクションが役立ちます。                                                                        |\n| JavaScript            | JavaScriptを利用するプロジェクトでTypeScriptのツールなどの恩恵を受けるために必要な情報などが記載されています。                                                                                                                                     |\n| Project Configuration | プロジェクト設定についてのドキュメントです。[tsconfig](reference/tsconfig)の設定方法などについて解説されています。コンパイラオプションについての詳細な情報を知りたい場合にはこのセクションが役立ちます。                                           |\n| **Cheat Sheets**      | シンタックスなどが画像に分かりやすくまとめられているチートシート。TypeScriptのシンタックスを俯瞰したい際に有用です。                                                                                                                               |\n| What's new            | 各バージョンごとに追加された機能の紹介ページです。新しいバージョンのページでは実際にその機能が追加されたプルリクエストが紐付けられているため、より詳細な挙動の説明を知りたい場合にはそのリンクをたどることで開発者による説明を読むことができます。 |\n\n公式ドキュメントと言うと通常はハンドブックのことを指す場合が多いですが、TypeScriptの公式サイト上の「[TypeScript Documentation](https://www.typescriptlang.org/docs/)」というページが存在しており、チートシートなどを含めてこのページにまとめられているドキュメントの一群が公式ドキュメントとなります。\n\nとはいっても、すべてのセクションを隅から隅まで一気に読んでいく必要はありません。初学者が重点的に読み込むべき箇所や効率的に読むための方法はいくつかあります。\n\n### 基本的な攻略方針\n\n公式ドキュメントの攻略方針は「学習のレベルや状況に応じて公式ドキュメントの読み方を変えていく」というのが有効です。この方法によって分量のある公式ドキュメントを効率的に読みこなすことができます。\n\n具体的には次のような方法が順当かつオススメです。\n\n- (A) 公式ドキュメントの構造や特徴を掴む\n- (B) 「Get Started」のイントロダクションを読む\n- (C) ハンドブックを頭から読む\n- (D) 詳細な知識が必要になった段階でリファレンスなどを読む\n- (E) TypeScriptの開発リポジトリにある一次情報を読む\n- (X) チートシートでシンタックスの概要を俯瞰する\n\n基本的には(A)から(E)までの方法を時系列順で行っていくことで知識を徐々に拡張してくことができます。\n\n(A)についてはこのページを読み込むことで完了しますが、特に公式ドキュメントを学習リソースとして見なすときには「Get Started」とハンドブックが重要となり、初学者が重点的に読み込むべき箇所となります。この２つについては時間をとって重点的に読み込み、リファレンスなどは必要になった時や暇な時につまみ食いしていくように読んでいくと効率的に読みこなすことができます。\n\nまた、特定の機能は公式ドキュメントでは説明が不十分なものなどがあります。より詳細な挙動などについて知りたい場合などは、TypeScriptのコードベースとなっているリポジトリからその機能が実装されたプルリクエストの説明を読み込みことで細かい挙動を知ることができます。各機能が導入されたTypeScriptのバージョンは「What's new」のページや開発リポジトリの「[Roadmap](https://github.com/microsoft/TypeScript/wiki/Roadmap)」から知ることができるのでそれらの資料からプルリクエストにアクセスして詳細な情報を得ることができます。\n\n(X)のチートシートにはTypeScriptのシンタックスが網羅的に分かりやすくまとめられており、これを眺めることで必要となる知識を俯瞰することができるので気になった時に見てみるとよいでしょう。\n\n公式ドキュメントの攻略方法の基本方針はこのようになりますが、以下では中核となるハンドブックについて解説していきます。\n\n### ハンドブックのバージョン\n\nTypeScriptは2012年に初めてリリースされてから今や10年以上の歴史があります。その間も継続的なアップデートが繰り返されて機能的に進化してきた訳ですが、言語自体のアップデートに伴って公式ドキュメントも進化してきました。\n\n[TypeScript誕生の背景](overview/before-typescript.md)\n\n公式ドキュメントにはさまざまなセクションがありますが、中でも「ハンドブック」と呼ばれるセクションが非常に重要です。ハンドブックはTypeScript言語の包括的なガイドであり、日常的に使用するTypeScriptの機能と挙動について学習者が強固な理解を得られるようなウォークスルーを提供しています。\n\nそして、公式ドキュメントの顕著な進化として、2021年に「v2」と呼ばれる新しいバージョンのハンドブックが公開されたことが挙げられます。v2以前のハンドブックは「v1」と呼ばれ、現在では非推奨(deprecated)なものとして[アーカイブされたリポジトリ](https://github.com/microsoft/TypeScript-Handbook)から閲覧することが可能です。\n\n:::caution\nv2ハンドブックの公開はかなり最近のことなので、これまでのポピュラーな入門書籍やWeb上のリソースの多くはv1の内容が反映されたものとなっていることに注意してください。\n:::\n\n### ハンドブックの特徴\n\nv2ハンドブックは開発者ブログの記事「[Announcing the New TypeScript Handbook](https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-handbook/)」において次のような制約のもとで執筆されていると語られています。\n\n- JavaScriptの解説は専門家に任せる (Leave teaching JavaScript to the experts)\n- インクリメンタルに教える (Teach incrementally)\n- コンパイラに話させる (Let the compiler do the talking)\n- 日常的なケースについて執筆する (Write for the everyday cases)\n\n特徴的なのは、ハンドブックではJavaScriptの知識についての解説を一からすることなく、他の書籍やWeb上のリソースに任せることで内容をコンパクトにしている点です。ハンドブックの目的のひとつが、言語的にスーパセットとなるTypeScriptがJavaScriptの上にどのように構築されているかをエンジニアが理解できるようにすることであるため、読者に対してJavaScriptの程度の知識や背景があることを前提にして話が進んでいきます。\n\nただし、あとで語るようにさまざまなスキルレベルを持つ読者のためにハンドブックの外側に「Get Started」というイントロダクション用のセクションを用意しており、他の言語習得者を含めて初学者はこのセクションのページから読むことが推奨されています。\n\n#### サバイバルTypeScriptと併用しよう\n\n上で語ったようにハンドブックではJavaScriptに元々ある機能やシンタックスなどについての解説はありません。しかし、TypeScriptの理解にはJavaScriptの理解が欠かせないという事実から、TypeScriptと並行してJavaScript自体も学びたい場合には本書の内容が非常に有用です。\n\n[JavaScriptはTypeScriptの一部](overview/javascript-is-typescript.md)\n\n本書を読んで気になった機能や深堀りしたい内容があれば、ハンドブックを含めた公式ドキュメント全体で探してみましょう。英語が苦手であれば、本書のページを熟読して内容をしっかり理解した上で該当する公式ドキュメントのページを読んでみることをオススメします。本書では次のページを含めオリジナルの英単語を数多く表記しているのでそれらの単語を使って公式ドキュメント内を検索していくと目的の読みたい箇所が簡単に見つかります。\n\n[索引:記号とキーワード](symbols-and-keywords.md)\n\nまた、本書との類似点としてハンドブックではすべてのエッジケースや特殊すぎる機能をカバーすることなく、日常的なケースを意識した内容となっています。そして、その範疇を超えるものはリファレンスセクションのページに記載されています。\n\n逆に本書と公式ドキュメントの違いとして挙げられるのが、本書はより実務を意識した作りとなっている点です。さまざまなアプリケーションを実際に実装してみる第３章の「[作って学ぶTypeScript](tutorials)」やコーディングテクニックを紹介する第5章の「[Tips](tips)」、他にも各所で解説しているプラクティスなどが実務を行う上で役立つはずです。したがって、公式ドキュメントと本書の両方を目的や状況に応じて使い分けることで効率的に学習を進めることができます。\n\n:::tip 言語のレイヤーを意識しよう\n\nTypeScriptについては本書と公式ドキュメントを併用するのがよいですが、JavaScriptの機能やシンタックスについてより深く知りたいという場合にはMDN Web Docsを併用し、さらに仕様まで知りたいという場合にはECMAScriptの仕様書を参照するようにしてください。\n\n- TypeScript → [公式ドキュメント](https://www.typescriptlang.org/docs/)\n- JavaScript → [MDN Web Docs](https://developer.mozilla.org/ja/docs/Web/JavaScript)\n- ECMAScript → [ecma262](https://tc39.es/ecma262/)\n\nTypeScriptという言語は「型システム+ランタイム+言語仕様」というように別々に存在する複数の言語や仕様、APIなどのレイヤーを内包しているため挙動や問題の調査などを行う場合にはそれぞれのレイヤーでのドキュメントに当たる必要があります。TypeScriptの公式ドキュメントを参照するタイミングは、TypeScriptの機能や設定、つまり型に関しての機能(型注釈や型推論、型演算子など)やコンパイラオプションなどについて知りたい場合となります。\n\n何についての情報を知りたいのかを意識して、JavaScriptのシンタックスやECMAScript仕様を知りたい場合にはそれが書いてあるドキュメントを読むようにしましょう。\n:::\n\n### イントロダクションを読もう\n\nハンドブックに取り組みはじめる前に読むべき項目として「Get Started」というイントロダクションのセクションが存在します。このセクションのページでは、さまざまなスキルレベルやバックグラウンドを持つ多様な読者がTypeScriptの特徴を簡単に知れるように次の５つのドキュメントが用意されています。\n\n| ページ                                                                                                                  | 内容                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [TypeScript for New Programmers](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)             | TypeScriptの最初の言語として選んだプログラミング初心者のためのイントロダクション。                                                                      |\n| [TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)      | JavaScriptの経験があるプログラマーのためのイントロダクション。                                                                                          |\n| [TypeScript for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)     | JavaやC#などのオブジェクト指向プログラミング(OOP)の経験があるプログラマーのためのイントロダクション。                                                   |\n| [TypeScript for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html) | HaskellやMLなどの関数型プログラミング(FP)の経験があるプログラマーのためのイントロダクション。                                                           |\n| [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)    | TypeScriptのインストールからシンプルなWebアプリケーションの構築までの方法を簡単に解説したページ。今すぐにTypeScriptを使いたいという読者に適しています。 |\n\n自身のスキルやバックグラウンドに応じたイントロダクションのページを選択して読むようにしてください。以下でそれぞれのスキルレベルの人が読むべきページの内容を紹介しますが、「Get\nStarted」の各ページには**そこにしか記載されていない重要な知識や考え方などがあるため**、時間があれば他のページにも目を通しておくことをオススメします。\n\n#### 🧑‍💻 プログラミング初心者\n\nTypeScriptがはじめてのプログラミング言語となる方は「[TypeScript for New Programmers](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)」のページから読むことで今後どのような学習をすればよいのかの指針を得ることができます。\n\n内容としては、JavaScriptの歴史や、JavaScriptとTypeScriptの関係などについての簡単な説明があります。\n\nハンドブックの「JavaScriptの解説は専門家に任せる」という執筆の制約からJavaScriptの機能やシンタックスについての解説は基本的に無いため、このページではJavaScriptの学習リソースが提示された上で「TypeScriptを学ぶためにJavaScriptを学ぼう」という旨で締められてJavaScriptの学習を促されます。\n\n#### 🧙 JavaScriptの経験がある学習者\n\nJavaScriptについての知識や経験があるなら「[TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)」のページから読むことをオススメします。このページは非常に有用であり、次のようなTypeScriptの中枢を占める重要な機能や概念について高速で知ることが可能です。\n\n- 型推論\n- 型定義\n- 型の合成(ユニオン型とジェネリクス)\n- 構造的型システム\n\nこのページを読めばTypeScriptでの重要な概念については把握することができるため、ハンドブックではそれらの知識をさらに拡張していけばよいことになります。\n\n#### 👨‍🚀 オブジェクト指向プログラミングの経験がある学習者\n\nJavaやC#などのオブジェクト指向プログラミング(OOP)の経験がある学習者は「[TypeScript for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)」のページを読むことでTypeScriptにおいて、クラスやオブジェクト指向の考え方の違いについて学ぶことができます。\n\n公称型(nominal typing)を採用しているJavaやC#に対して、TypeScriptは構造的部分型(structural subtyping)を採用してることから知っておくべき違いや型の考え方についての重要なアイデアが提示されています。\n\n[構造的部分型(structural subtyping)](reference/values-types-variables/structural-subtyping.md)\n\n#### 🦸‍♂️ 関数型プログラミングの経験がある学習者\n\nHaskellやMLなどの関数型プログラミング(FP)の経験がある学習者は「[TypeScript for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)」のページを読むことで、それらの関数型言語との類似機能や違いなどを学びながらTypeScriptについて知ることができます。\n\n内容としてはHaskellの型システムとの相違点と類似点についての解説となっています。具体的には単位型(unit type)や、ポイントフリースタイルプログラミング(point-free programming)、高カインド型(higher-kinded types)などをTypeScriptでのどのように扱うかなどの解説があります。\n\n### ハンドブックの読み進め方\n\nハンドブックは次のようなセクション構成となっています。\n\n| ページ                                                                               | 内容                                                                             |\n| ------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |\n| [The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)   | ハンドブックの構成と目的についての説明                                           |\n| [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)        | TypeScriptにおける基本的な考え方などについての説明                               |\n| [Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) | 日常的に使用するあらゆる型についての説明                                         |\n| [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)           | 型の絞り込みについての説明                                                       |\n| [More on Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)   | 関数の型についての詳細説明                                                       |\n| [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)          | オブジェクトの型についての詳細説明                                               |\n| Type Manipulation                                                                    | 型から新しい型を作成するための方法について解説したページを収めたセクションです。 |\n| [Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)               | アクセス修飾子やクラスの型注釈の方法などの説明                                   |\n| [Modules](https://www.typescriptlang.org/docs/handbook/2/modules.html)               | モジュール解決などについての説明                                                 |\n\n「Type Manipulation」ではジェネリクスや型演算子などを利用して型から新しい型を作成するための方法について解説したページを収めたセクションです。このセクションは次のようなページ構成になっています。\n\n| ページ                                                                                               | 内容                                                                            |\n| ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\n| [Creating Types from Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)    | 他の型から型を作成するための方法についてについての説明                          |\n| [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)                             | 型をパラメータとして取るジェネリクスについての説明                              |\n| [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)               | `keyof`型演算子を利用して新しい形を作る方法についての説明                       |\n| [Typeof Type Operator](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)             | `typeof`型演算子を利用して新しい型を作る方法についての説明                      |\n| [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)     | `Type['a']`シンタックスを利用した型のサブセットにアクセスする方法についての説明 |\n| [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)           | 型システム内で文として振る舞う条件型についての説明                              |\n| [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)                     | 既存の型のプロパティをマッピングして型を作成する方法についての説明              |\n| [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) | テンプレートリテラル文字列を介してプロパティを変更するMapped typeについての説明 |\n\n「インクリメンタルに教える」という執筆の制約から、ハンドブックでは始めから終わりまで直線的に読めるように、未解説の機能についての言及をなるべく避けながら徐々に知識を積み上げていくような構成となっています。したがって、読み方の基本指針としては**頭から順番に読んでいく**ということになります。\n\nTypeScriptについてまったく知らないという方であれば「Get Started」のイントロダクションページを読み終えてから、冒頭の「[The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)」と「[Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)」だけでも読んでおくことでTypeScriptの概要を掴むことができます。\n\nそれぞれの知識はページとしてモジュール化されているため、本書を読んで知っている内容などは飛ばして知りたい箇所のページのみを都度読んでいくという読み方も有効です。ハンドブックのセクションだけでなく、特にリファレンスのセクションはそのような読み方が有効です。たとえばリファレンスに収められているユーティリティ型の紹介ページについては、ベースとしている型演算子(type operator)の知識はハンドブックの「Type Manipulation」のセクションで細分化されて解説されています。\n\nむしろ公式ドキュメントよりも本書の方が細かく知識をモジュール化しているため、逆に公式ドキュメントを読みながら日本語での分かりやすい解説を読みたいという時に本書を利用するという読み方も有効です。\n",
      "url": "https://typescriptbook.jp/learning-resources"
    },
    {
      "title": "🚧TypeScript超入門 〜10分でわかるTypeScriptの概要〜",
      "content": "# 🚧TypeScript超入門 〜10分でわかるTypeScriptの概要〜\n\nTODO: 忙しい人向けにTypeScriptのエッセンスがわかる長めのシングルページを作る。\n",
      "url": "https://typescriptbook.jp/typescript"
    },
    {
      "title": "本書のライセンス",
      "content": "# 本書のライセンス\n\n本書は[Creative Commons — 表示 - 継承 4.0 国際 — CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.ja)で公開しています。商用利用の制限がありません。\n\n## サンプルコードのライセンス\n\n本書のうち、コードブロックで表現されたプログラミングコードは、CC BY-SA 4.0またはMIT Licenseのデュアルライセンスで公開しています。読者が自身が開発するプログラムにサンプルコードを利用する際、MIT Licenseも選択していただけます。「コードブロックで表現されたプログラミングコード」とは次のような表示で、罫線や背景色により地の文と区別して表示するコードをいいます。\n\n```ts\nconst value = \"Hello World\";\n```\n\n### MIT License\n\nexport const Year = () => <>{new Date().getFullYear()}</>;\n\n<!-- markdownlint-disable MD033 -->\n\nCopyright (c) <Year /> YYTypeScript\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n## CC BY-SAの表示義務の詳細\n\nCC BY-SA 4.0では具体的な表示義務の方法に定めがないため、本書では表示ポリシーを次のように定めます。\n\n### CC BY-SAの表示ポリシー\n\n本書コンテンツを再公開・二次創作する場合は、CC BY-SAの表示について次のことを行う必要があります。\n\n1. 本書のタイトル『サバイバルTypeScript』を明記してください。\n1. ウェブサイトやHTML形式で再公開される場合、ページごとに本書の該当する元ページに直接ハイパーリンクしてください。\n   1. ハイパーリンクは直接であり、短縮URLやリダイレクトを挟んではいけません。\n   1. ハイパーリンクはJavaScriptが無効になっている場合でもリンクを辿れる必要があります。\n   1. リンクは`rel=\"nofollow\"`にしてはいけません。\n   1. リンク先はGitHubのページではなく、typescriptbook.jpのページのURLにしてください。\n   1. その他、リンクをクリックしにくくするなど辿りにくくなるような仕掛けはしてはいけません。\n1. GitHubのフォーク機能でフォークし、フォーク元のリンク先が本書のGitHubリポジトリになっている場合、GitHubリポジトリでのハイパーリンクは不要です。\n1. 印刷物や画像、映像、スライドなど読者や聴衆がクリックでリンクを辿れない媒体では、本書のURLを明記してください。\n   1. URLは目立たせる必要はありませんが、十分に読める文字サイズである必要があります。\n   1. YouTubeなどの動画配信サイトでは、概要欄にリンクを載せる形でも構いません。\n\n#### ハイパーリンクの具体例\n\n<!--prettier-ignore-->\n```html\n<a href=\"https://typescriptbook.jp/overview/features\">『サバイバルTypeScript』「TypeScriptの特徴」</a>\n```\n\n## 例外\n\n本書は基本的にCC BY-SA 4.0でライセンスされていますが、本書に掲載される企業のロゴや広告クリエイティブは、各企業などに権利が帰属し、二次利用が不可の場合がありますのでご注意ください。\n\n## Q&A\n\n### なぜサンプルコードはMIT Licenseが選べるのですか？\n\nCC BY-SA 4.0は優れたライセンスですが、プログラミングコードのライセンスにはMIT Licenseのほうが一般的です。CC BY-SA 4.0には継承の義務があるため、サンプルコードをコピペして利用するといったことがしにくいです。サンプルコードを利用していただきやすくするためにも、MIT Licenseが選択できるようにしています。\n\n### 社内の勉強会や従業員の教育に本書を使えますか？\n\nはい。お役立てください。\n",
      "url": "https://typescriptbook.jp/license"
    },
    {
      "title": "読んで学ぶTypeScript",
      "content": "---\nslug: /reference\n---\n\n# 読んで学ぶTypeScript\n\n本章では、TypeScriptの言語機能をひとつひとつ解説します。解説の範囲はTypeScriptに留まらず、JavaScriptについても必要なものを解説します。これは、TypeScript学習者がJavaScriptも並行して学ぶことが多いためです。\n\nどの機能がTypeScriptのものか、JavaScriptのものかがわかるように配慮しています。JavaScriptの機能については「JavaScriptの〜は」などと、TypeScriptの機能については「TypeScriptの〜は」などのように言語名を文中に記すようにしています。言語名が随所に出てくるため、読んでいてくどいと思われるかもしれませんが、どの機能がどちらの言語のものかを明確に理解しておくことは重要なので、ご辛抱いただければ幸いです。\n\n本章の流れは、コード上の小さいパーツから大きいパーツに行くように構成しています。値や変数から始まり、文、関数、そしてクラスなどのオブジェクト指向プログラミング要素、さらにモジュールといったように、読み進めるにしたがって粒度の大きい要素についての話になっていきます。\n",
      "url": "https://typescriptbook.jp/reference/README"
    },
    {
      "title": "インターフェースの継承 (inheritance)",
      "content": "---\nsidebar_label: インターフェースの継承\n---\n\n# インターフェースの継承 (inheritance)\n\nTypeScriptでは、`extends`キーワードを利用して定義済みのインターフェースを継承して、新たにインターフェースを定義することができます。インターフェースを継承した場合、継承元のプロパティの型情報はすべて引き継がれます。新しくプロパティを追加することもできますし、すでに宣言されているプロパティの型を部分型に指定しなおすこともできます。\n\n## プロパティを追加する\n\n```ts twoslash\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Student extends Person {\n  grade: number; // 学年\n}\n\ninterface Teacher extends Person {\n  students: Student[]; // 生徒\n}\n\nconst studentA: Student = {\n  name: \"花子\",\n  age: 10,\n  grade: 3,\n};\n\nconst teacher: Teacher = {\n  name: \"太郎\",\n  age: 30,\n  students: [studentA],\n};\n```\n\n## プロパティを部分型に宣言しなおす\n\nある型からその型のリテラル型にすることも、ユニオン型から部分的に選択することもTypeScriptではそれぞれサブタイプにしていることと同じ意味があります。もちろん他のオブジェクト指向の言語と同じようにサブクラスにすることもできます。\n\n### リテラル型に変更する\n\n```ts twoslash\ninterface WebPage {\n  path: string;\n}\n\ninterface IndexPage extends WebPage {\n  path: \"/\";\n}\n```\n\n### ユニオン型から選ぶ\n\n```ts twoslash\ninterface Person {\n  age: number | undefined;\n}\n\ninterface Student extends Person {\n  age: number;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/interface-inheritance"
    },
    {
      "title": "インターフェース (interface)",
      "content": "---\nsidebar_label: \"インターフェース\"\nslug: /reference/object-oriented/interface\n---\n\n# インターフェース (interface)\n\nインターフェースはクラスが実装すべきフィールドやメソッドを定義した型です。クラスはインターフェースを実装することで、インターフェースが求めるメソッド名や引数の型に則っているかをチェックすることができます。\n\nJavaやPHPなどの言語では、インターフェースが定義できますが、JavaScriptにはそれに相当する構文がありません。一方、TypeScriptにはインターフェースがあります。\n\nTypeScriptで定義されたインターフェースは、コンパイルチェックに活用された後、JavaScriptコードを生成する過程で消されるため、インターフェースがJavaScript実行時に影響することはありません。\n\n## インターフェースを定義する\n\nTypeScriptでは`interface`キーワードでインターフェースを定義できます。\n\n```ts twoslash\ninterface SomeInterface {\n  method1(): void;\n  method2(arg: string): void;\n}\n```\n\nTypeScriptではメソッドだけでなく、パブリックフィールドも定義できます。\n\n```ts twoslash\ninterface SomeInterface {\n  field: string;\n}\n```\n\n## インターフェースと構造的部分型\n\nJavaなどのオブジェクト指向言語ではクラスの抽象的な型定義として利用されます。そのため、インターフェース単体では利用されず、特定のクラスがインターフェースを継承し実装を追加することで初めて効果を発揮します。\n\nTypeScriptでもインターフェースをクラスに実装させることはできますが、それに加えて、TypeScriptは構造的部分型なので、インターフェースと実装関係がないオブジェクトの型注釈としても利用できます。\n\n```ts twoslash\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst taro: Person = {\n  name: \"太郎\",\n  age: 12,\n};\n```\n\n[構造的部分型 (structural subtyping)](../../values-types-variables/structural-subtyping.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/README"
    },
    {
      "title": "インターフェースとinstanceof",
      "content": "# インターフェースとinstanceof\n\n[instanceof演算子](../class/instanceof-operator.md)は、オブジェクトがクラスのインスタンスかを判定するJavaScriptの演算子です。ここでは、`instanceof`演算子がTypeScriptのインターフェースとどのような関係にあるのかを解説します。\n\n## 他言語の`instanceof`との違い\n\nJavaやPHPなど他の言語の`instanceof`演算子は、インターフェースに用いることができる言語もありますので、他言語の次にTypeScriptに学ぶ場合は注意してください。次はPHPで`instanceof`演算子をインターフェースに使っている例です。\n\n```php title=\"PHPのinstanceof演算子の例\"\ninterface MyInterface\n{\n}\n\nclass MyClass implements MyInterface\n{\n}\n\n$a = new MyClass();\nvar_dump($a instanceof MyInterface);\n//=> bool(true)\n```\n\n### `instanceof`はインターフェースに使えない\n\nTypeScriptは上のような言語とは異なり、`instanceof インターフェイス名`で型を判定することができません。もしも、`instanceof`演算子にインターフェース名を使うと、コンパイルエラーになります。\n\n```ts twoslash title=\"TypeScriptでinstanceof演算子を使うとコンパイルエラーになる例\"\n// @errors: 2693\ninterface MyInterface {}\n\nclass MyClass implements MyInterface {}\n\nconst a = new MyClass();\nconsole.log(a instanceof MyInterface);\n```\n\nなぜかというと、インターフェースがTypeScript固有の機能でコンパイル時にコードから消えるためです。インターフェースは型レベルのものです。TypeScriptはJavaScriptにコンパイルするとき、型レベルのものを消します。変数の型注釈がコンパイル時に消えるのと同じ理屈です。\n\nコンパイル時に消えるということは、JavaScript実行時にインターフェースの情報が、どこにもないということです。そのため、`instanceof`がインターフェース名を取ることができないというわけです。\n\n## インターフェースの判定には型ガード関数を使う\n\n実行時に値がインターフェースと互換しているかを判定するには、[型ガード関数](../../functions/type-guard-functions.md)を用います。型ガード関数は、型を判定したい値を引数に取り、`true`または`false`を返す関数です。たとえば、値が`Student`インターフェース型であるかを判定する関数は次のようになります。\n\n```ts twoslash\ninterface Student {\n  name: string;\n  grade: number;\n}\n\n// Student型かを判定する型ガード関数\nfunction isStudent(value: unknown): value is Student {\n  // 値がオブジェクトであるかの判定\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const { name, grade } = value as Record<keyof Student, unknown>;\n  // nameプロパティーが文字列型かを判定\n  if (typeof name !== \"string\") {\n    return false;\n  }\n  // gradeプロパティーが数値型かを判定\n  if (typeof grade !== \"number\") {\n    return false;\n  }\n  return true;\n}\n```\n\nそして、この`isStudent`関数を`instanceof`の代わりに用いると、実行時に型の判定ができるようになります。\n\n```ts twoslash\ninterface Student {\n  name: string;\n  grade: number;\n}\ndeclare function isStudent(value: unknown): value is Student;\n// ---cut---\nconst tom: object = { name: \"Tom\", grade: 2 };\n//    ^?\nif (isStudent(tom)) {\n  tom;\n  // ^?\n}\n```\n\n型ガード関数の詳細については、次のページをご覧ください。\n\n[型ガード関数](../../functions/type-guard-functions.md)\n\n## 複雑なインターフェースの判定はzodが便利\n\n型ガード関数の例として、上で`isStudent`の実装を示しましたが、中身を見てみるとプロパティーごとに型を判定するロジックが必要なのが分かります。プロパティーが少なければ、型ガード関数の実装は短く保守可能な範囲に収まりますが、プロパティーが多くなると保守困難なコードになると想像されます。\n\nそのようなケースで便利なのが[zod](https://zod.dev/)です。zodはオブジェクトの構造をチェックするライブラリで、TypeScript向けに作られています。zodでは、オブジェクトの構造を定義すると、構造をチェックする型ガード関数が得られます。次は、`isStudent`をzodで実装した例です。\n\n```ts twoslash\nimport z from \"zod\";\n\n// zodによるスキーマの定義\nconst studentSchema = z.object({\n  name: z.string(),\n  grade: z.number(),\n});\n// インターフェースの型を導出\ntype Student = z.infer<typeof studentSchema>;\n//   ^?\n// 型ガード関数\nfunction isStudent(value: unknown): value is Student {\n  return studentSchema.safeParse(value).success;\n}\n// 型の判定\nconst tom: object = { name: \"Tom\", grade: 2 };\nif (isStudent(tom)) {\n  tom;\n  //^?\n}\n```\n\nzodを用いると、宣言的なコードになることで、型ガード関数の細かい実装を自分で書かなくてよくなることがわかるかと思います。プロパティーの数が多いインターフェースや、プロパティーがネストされて構造化されたインターフェースの型ガード関数が必要になった場合は、zodの導入を検討してみるといいでしょう。\n\n## 抽象クラスと`instanceof`\n\nTypeScriptにはインターフェースの似たものに[抽象クラス](./../class/abstract-class.md)があります。抽象クラスはインターフェースと異なり、`instanceof`演算子が使えます。これは、抽象クラスはコンパイルしても、クラスとして残るためです。\n\n```ts twoslash\nabstract class AbstractClass {}\nclass ConcreteClass extends AbstractClass {}\nconst obj = new ConcreteClass();\nconsole.log(obj instanceof AbstractClass);\n// @log: true\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/instanceof-and-interfaces"
    },
    {
      "title": "インターフェースのreadonly修飾子",
      "content": "# インターフェースのreadonly修飾子\n\nTypeScriptのインターフェースでは、フィールドにreadonly修飾子をつけることで読み取り専用のフィールドが定義できます。\n\n```ts twoslash\ninterface SomeInterface {\n  readonly field: number;\n}\n```\n\n## 関連情報\n\n[クラスのreadonly修飾子](../class/readonly-modifier-in-classes.md)\n\n[オブジェクト型のreadonlyプロパティ (readonly property)](../../values-types-variables/object/readonly-property.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/readonly-modifier-in-interfaces"
    },
    {
      "title": "interfaceとtypeの違い",
      "content": "---\ndescription: interfaceでの宣言とtype aliasによる宣言の違い\n---\n\n# interfaceとtypeの違い\n\n型エイリアスを利用することで、インターフェースと同様の定義が行なえます。\n\n```ts twoslash\n// @noErrors\ninterface Animal {\n  name: string;\n  bark(): string;\n}\ntype Animal = {\n  name: string;\n  bark(): string;\n};\n```\n\nこの章では、インターフェースと型エイリアスの違いについて詳しく説明していきます。\n\n## インターフェースと型エイリアスの違い\n\n| 内容             | インターフェース   | 型エイリアス                     |\n| :--------------- | :----------------- | :------------------------------- |\n| 継承             | 可能               | 不可。ただし交差型で表現は可能   |\n| 継承による上書き | 上書きまたはエラー | フィールド毎に交差型が計算される |\n| 同名のものを宣言 | 定義がマージされる | エラー                           |\n| Mapped Types     | 使用不可           | 使用可能                         |\n\n### 継承\n\nインターフェースは、インターフェースや型エイリアスを継承できます。\n\n```ts twoslash\ninterface Animal {\n  name: string;\n}\ntype Creature = {\n  dna: string;\n};\ninterface Dog extends Animal, Creature {\n  dogType: string;\n}\n```\n\n一方、型エイリアスは継承は行えません。代わりに交差型(&)を使用することで、継承と似たことを実現できます。\n\n```ts twoslash\ntype Animal = {\n  name: string;\n};\ntype Creature = {\n  dna: string;\n};\ntype Dog = Animal &\n  Creature & {\n    dogType: string;\n  };\n```\n\n### プロパティのオーバーライド\n\nインターフェースで継承の際にプロパティをオーバーライドすると、継承元のプロパティの型が上書きされます。\n\n```ts twoslash\n// OK\ninterface Animal {\n  name: any;\n  price: {\n    yen: number;\n  };\n  legCount: number;\n}\n\ninterface Dog extends Animal {\n  name: string;\n  price: {\n    yen: number;\n    dollar: number;\n  };\n}\n\n// 最終的なDogの定義\ninterface Dog {\n  name: string;\n  price: {\n    yen: number;\n    dollar: number;\n  };\n  legCount: number;\n}\n```\n\nただし、オーバーライドするためには元の型に代入できるものでなければなりません。次の例は`number`型であるフィールドを`string`型でオーバーライドしようとしている例です。\n\n```ts twoslash\n// @errors: 2430\ninterface A {\n  numberField: number;\n  price: {\n    yen: number;\n    dollar: number;\n  };\n}\n\ninterface B extends A {\n  numberField: string;\n  price: {\n    yen: number;\n    euro: number;\n  };\n}\n```\n\n一方、型エイリアスの場合は上書きにはならず、フィールドの型の交差型が計算されます。また、交差型で矛盾があって計算できない場合もコンパイルエラーにはなりません。\n\n```ts twoslash\n// @noErrors\ntype Animal = {\n  name: number;\n  price: {\n    yen: number;\n    dollar: number;\n  };\n};\n\ntype Dog = Animal & {\n  name: string;\n  price: {\n    yen: number;\n    euro: number;\n  };\n};\n\n// 最終的なDogの定義\ntype Dog = {\n  name: never; // 交差型を作れない場合はコンパイルエラーではなくnever型になる\n  price: {\n    yen: number;\n    dollar: number;\n    euro: number;\n  };\n};\n```\n\n### 同名のものを宣言\n\n型エイリアスは同名のものを複数定義できず、コンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2300\ntype SameNameTypeWillError = {\n  message: string;\n};\ntype SameNameTypeWillError = {\n  detail: string;\n};\n```\n\n一方、インターフェースの場合は、同名のインターフェースを定義でき、同名の定義をすべて合成したインターフェースになります。\nただし、同名のフィールドだが、型の定義が違っている場合はコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2717\ninterface SameNameInterfaceIsAllowed {\n  myField: string;\n  sameNameSameTypeIsAllowed: number;\n  sameNameDifferentTypeIsNotAllowed: string;\n}\n\ninterface SameNameInterfaceIsAllowed {\n  newField: string;\n  sameNameSameTypeIsAllowed: number;\n}\n\ninterface SameNameInterfaceIsAllowed {\n  sameNameDifferentTypeIsNotAllowed: number;\n}\n```\n\n### Mapped Types\n\nMapped Typesについては別のページで詳しく説明しますので、ここでは型エイリアスとインターフェースのどちらで使えるかだけを説明します。\n\n[Mapped Types](../../type-reuse/mapped-types.md)\n\nMapped Typesは型のキーを動的に指定することができる仕組みであり、型エイリアスでのみ利用することができます。\n次の例ではユニオン型の一覧をキーとした新しい型を生成しています。\n\n```typescript twoslash\ntype SystemSupportLanguage = \"en\" | \"fr\" | \"it\" | \"es\";\ntype Butterfly = {\n  [key in SystemSupportLanguage]: string;\n};\n```\n\nインターフェースでMapped Typesを使うとエラーになります。\n\n```typescript twoslash\n// @errors: 7061\ntype SystemSupportLanguage = \"en\" | \"fr\" | \"it\" | \"es\";\n\ninterface Butterfly {\n  [key in SystemSupportLanguage]: string;\n}\n```\n\n## インターフェースと型エイリアスの使い分け\n\n実際に型を定義する時にインターフェースと型エイリアスのどちらを使うのがよいのでしょうか？残念ながら、これに関しては明確な正解はありません。\n\nインターフェースと型エイリアスのどちらでも型を定義することができますが、拡張性やMapped Typesの利用可否といった点で異なる部分が存在するので、これらのメリット・デメリットを考慮してプロジェクト内でルールを決めてそれに遵守するようにしましょう。\n\n参考例として、Googleが公開しているTypeScriptのスタイルガイドの[型エイリアスvsインターフェース](https://google.github.io/styleguide/tsguide.html#interfaces-vs-type-aliases)の項目では、プリミティブな値やユニオン型やタプルの型定義をする場合は型エイリアスを利用し、オブジェクトの型を定義する場合はインターフェースを使うことを推奨しています。\n\nインターフェースと型エイリアスの使い分けに悩む場面が多く開発スピードが落ちてしまうのであれば、型エイリアスに統一して書く方針にする考え方もあります。\n\n### インターフェースの利用例\n\nライブラリを作成する際に定義した型の構造がアプリケーション側に依存するような場合にはインターフェースを利用するのが適切です。\n\nNode.jsの`process.env`の型定義は`@types/node/process.d.ts`で次のように実装されています。\n\n```ts twoslash\ndeclare module \"process\" {\n  global {\n    namespace NodeJS {\n      interface ProcessEnv extends Dict<string> {\n        TZ?: string;\n      }\n    }\n  }\n}\n```\n\nインターフェースで型定義されていることで、パッケージを利用する側で型の拡張が自由に行えるようになっています。\n\nもし`ProcessEnv`が型エイリアスで定義されていると型の拡張が行えず、とても開発しづらい状態になってしまいます。このように不特定多数のユーザーが型を参照するような場合には、拡張性を考慮してインターフェースで型定義をするようにしましょう。\n\n```ts twoslash\n// src/types/global.d.ts\ndeclare module \"process\" {\n  global {\n    namespace NodeJS {\n      interface ProcessEnv {\n        NODE_ENV: \"development\" | \"production\";\n      }\n    }\n  }\n}\n```\n\n## 関連情報\n\n[インターフェース (interface)](./README.md)\n\n[型エイリアス (type alias)](../../values-types-variables/type-alias.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/interface-vs-type-alias"
    },
    {
      "title": "インターフェースを実装する",
      "content": "# インターフェースを実装する\n\nTypeScriptでは、クラスがインターフェースを実装できます。実装するには`implements`キーワードを用います。\n\n```ts twoslash\ninterface Human {\n  think(): void;\n}\n\nclass Developer implements Human {\n  think(): void {\n    console.log(\"どういう実装にしようかな〜\");\n  }\n}\n```\n\nインターフェースを複数指定することもできます。そのときは`,`でインターフェースを区切り列挙します。\n\n```ts twoslash\ninterface Human {\n  think(): void;\n}\n\ninterface Programmer {\n  writeCode(): void;\n}\n\nclass TypeScriptProgrammer implements Human, Programmer {\n  think(): void {\n    console.log(\"どういうコードにしようかな〜\");\n  }\n\n  writeCode(): void {\n    console.log(\"カタカタ\");\n  }\n}\n```\n\nインターフェースで定義されたフィールドをクラスで実装するには、クラス側にはフィールドを定義します。\n\n```ts twoslash\ninterface Human {\n  name: string;\n}\n\nclass Developer implements Human {\n  name: string = \"Bob\";\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/implementing-interfaces"
    },
    {
      "title": "オープンエンドと宣言マージ (open-ended and declaration merging)",
      "content": "---\nsidebar_label: \"オープンエンドと宣言マージ\"\n---\n\n# オープンエンドと宣言マージ (open-ended and declaration merging)\n\nJavaやPHPなど、他の言語にもinterface構文がある言語があります。他の言語とは異なり、TypeScriptのinterfaceには、オープンエンド(open-ended)と宣言マージ(declaration merging)という珍しい特徴があります。\n\n## オープンエンドと宣言マージとは\n\n他の言語のinterface構文は、同じ名前のインターフェースを宣言するとエラーになるものが多いです。たとえば、PHPで`Foo`インターフェースを2つ宣言すると、重複エラーになります。\n\n```php title=\"PHP\"\ninterface Foo {}\ninterface Foo {}\n// Fatal error:  Cannot declare interface Foo, because the name is already in use in...\n```\n\nTypeScriptでは、同じ名前のインターフェースを宣言してもエラーにはなりません。\n\n```ts twoslash\ninterface Foo {}\ninterface Foo {} // エラーにならない\n```\n\nこのように、複数のインターフェースを宣言してもエラーにならない仕様のことを、オープンエンドといいます。\n\n同じ名前のインターフェースを宣言した場合、それぞれのインターフェースの型がマージされます。たとえば、次のようにプロパティ`a`を持つインターフェースと、プロパティ`b`を持つインターフェースを宣言した場合を考えてみましょう。\n\n```ts twoslash\ninterface Foo {\n  a: number;\n}\ninterface Foo {\n  b: number;\n}\n```\n\nこの宣言は、次のようにプロパティ`a`とプロパティ`b`を持つインターフェースを、ひとつ定義したことと同じことになります。\n\n```ts twoslash\ninterface Foo {\n  a: number;\n  b: number;\n}\n```\n\nこのように、同じ名前のインターフェースがマージされる仕組みを宣言マージといいます。\n\n## 宣言マージの活用シーン\n\nJavaScriptがアップデートされるにつれ、既存のクラスにもメソッドが追加されることがあります。たとえば`Array`クラスはES2016で`includes()`メソッドが、ES2019で`flatMap()`メソッドが追加されました。\n\nTypeScriptの開発元は、JavaScriptのアップデートに合わせて、`Array`インターフェースの型定義も対応していく必要があります。単純に考えると、JavaScriptのバージョンごとに、`Array`インターフェースを独立して定義する方法が考えられます。\n\nこのアプローチは、一見すると良さそうです。しかし、よく考えてみると、JavaScriptがアップデートされるにつれ、インターフェースのコピペコードが増えていくという問題が出てきます。ES2015とES2016の`Array`の違いは、`includes()`メソッドがあるかないかの違いだけです。それなのに、`pop()`メソッドや`push()`メソッドといった多数のメソッドまでコピーしないといけなくなってしまいます。\n\nこれを解決するのが宣言マージです。TypeScriptの開発元が、どのように宣言マージを活用しているのか、具体例を見てみましょう。まず、もっとも古いバージョンの`Array`インターフェースを宣言した型定義ファイルを用意します。\n\n```ts twoslash title=\"最も古いバージョンのArrayインターフェース\"\ninterface Array<T> {\n  pop(): T | undefined;\n  push(...items: T[]): number;\n  concat(...items: ConcatArray<T>[]): T[];\n  // ...その他沢山のメソッドが続く...\n}\n```\n\n次に、ES2016で追加されたメソッドに対応する`Array`インターフェースを別ファイルに作ります。\n\n```ts title=\"ES2016.array.d.ts\" twoslash\ninterface Array<T> {\n  includes(searchElement: T, fromIndex?: number): boolean;\n}\n```\n\nさらに、ES2019で追加されたメソッドに対応する型定義ファイルも別に作ります。\n\n```ts title=\"ES2019.array.d.ts\" twoslash\ninterface Array<T> {\n  flatMap<U, This = undefined>(\n    callback: (\n      this: This,\n      value: T,\n      index: number,\n      array: T[]\n    ) => U | ReadonlyArray<U>,\n    thisArg?: This\n  ): U[];\n}\n```\n\nこのようにバージョン間の差分だけを、インターフェースに定義していくと、JavaScriptのバージョンが上がっていっても、コピペコードが発生しません。\n\nTypeScriptユーザーは、自分が必要なJavaScriptのバージョンに応じて、これらのファイルを読み込むことで、最適なインターフェースの型が使えるようになります。たとえば、ES2016のJavaScript環境を対象に開発しているなら、ES2016までの型定義ファイルまで読み込むようにします。ES2019の環境を対象とするなら、ES2016とES2019両方の型定義ファイルを読み込むといった具合です。\n\nこの例のように、すでに宣言したインターフェースは直せないが、インターフェースを拡張する必要がある場合に、宣言マージが活用されます。\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/interface/open-ended-and-declaration-merging"
    },
    {
      "title": "JavaScriptとTypeScriptのオブジェクト指向機能の比較",
      "content": "# JavaScriptとTypeScriptのオブジェクト指向機能の比較\n\n簡易な一覧ですが、型に関する機能が拡張されていることがわかると思います。\n\n| 機能名                     | JavaScript | TypeScript |\n| :------------------------- | :--------- | :--------- |\n| クラス構文                 | ○          | ○          |\n| クラス継承                 | ○          | ○          |\n| super                      | ○          | ○          |\n| コンストラクタ             | ○          | ○          |\n| 抽象クラス(abstract)       | ✕          | ○          |\n| 抽象メソッド               | ✕          | ○          |\n| アクセス修飾子             | △          | ○          |\n| インターフェース           | ✕          | ○          |\n| ジェネリクス               | ✕          | ○          |\n| 静的プロパティ             | △          | ○          |\n| 静的メソッド               | △          | ○          |\n| finalクラス / sealedクラス | ✕          | ✕          |\n| finalメソッド              | ✕          | ✕          |\n\nクラスにかかわらずTypeScriptの特徴となるのはコーディング中に型が不適切な場合はコンパイルエラーを教えてくれることです。JavaScriptの場合は基本的に実行を行い不正な型が発生した場合に型エラーを知ることになります。TypeScriptコードに問題がなく型安全と判断された場合に限りコンパイルを行うことができます。また出力されたJavaScriptファイルには型情報は除かれます。\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/javascript-vs-typescript-in-oop-features"
    },
    {
      "title": "クラス (class)",
      "content": "---\nsidebar_label: クラス\nslug: /reference/object-oriented/class\n---\n\n# クラス (class)\n\nクラスはオブジェクトの雛形を定義したもので、JavaScriptとTypeScriptでは`class`構文を用いてクラスが定義できます。\n\n```ts twoslash\nclass Person {}\n```\n\nクラスに対して`new`キーワードを使うと、オブジェクトを生成できます。\n\n```ts twoslash\nclass Person {}\n// ---cut---\nconst person = new Person();\n```\n\nこのように`class`でクラスを定義し、`new`でインスタンスを生成するスタイルは、JavaやPHP、Rubyなどと使用感がよく似ています。\n\n## クラスの型注釈\n\nTypeScriptでは、クラスを定義するとクラス名と同じ名前の型が同時に定義されます。インスタンスを代入する変数に型注釈するには、クラス名を使います。\n\n```ts twoslash\nclass Person {}\n// ---cut---\nconst person: Person = new Person();\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/README"
    },
    {
      "title": "公称型クラス",
      "content": "# 公称型クラス\n\nTypeScriptでは、クラスに1つでも非パブリックなプロパティがあると、そのクラスだけ構造的部分型ではなく公称型(nominal typing)になります。\n\nたとえば、`UserId`クラスと`GroupId`クラスで同名になってしまっている`id`プロパティをプライベートにするだけで、相互の代入が不可能になります。\n\n```ts twoslash\n// @errors: 2322\nclass UserId {\n  private readonly id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nclass GroupId {\n  private readonly id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nconst userId: UserId = new GroupId(\"...\");\n```\n\nこの方法はフィールドに限らず、プライベートメソッドや`protected`プロパティでも同じ効果があります。\n\n## 関連情報\n\n[構造的部分型 (structural subtyping)](../../values-types-variables/structural-subtyping.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/class-nominality"
    },
    {
      "title": "クラスはオブジェクト",
      "content": "# クラスはオブジェクト\n\nJavaScriptのクラスの特徴は、クラスもオブジェクトの一種というところです。JavaScriptのオブジェクトはプロパティの集合体です。クラスもオブジェクトなのでプロパティの集合体としての性質を持ちます。したがって、定義したクラスはプロパティを追加したり、変更したりできます。\n\n```js twoslash\nconst myObject = {};\nmyObject.key = \"value\"; // プロパティを追加\n\nclass MyClass {}\nMyClass.key = \"value\"; // プロパティを追加\n```\n\n一方、TypeScriptでは型安全のためにこうした動的な拡張ができないようになっています。\n\n```ts twoslash\n// @errors: 2339\nclass MyClass {}\nMyClass.key = \"value\";\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/class-is-an-object"
    },
    {
      "title": "クラスの継承 (inheritance)",
      "content": "---\nsidebar_label: クラスの継承\n---\n\n# クラスの継承 (inheritance)\n\nJavaScriptのクラスも他のクラスを持つ言語と同じように、`extends`キーワードで継承ができます。\n\n```js twoslash\nclass Parent {}\nclass Child extends Parent {}\n```\n\nサブクラスにコンストラクタを書く場合、スーパークラスのコンストラクタは必ず呼び出す必要があります。スーパークラスのコンストラクタは`super()`で呼び出します。\n\n```js twoslash\nclass Parent {}\nclass Child extends Parent {\n  constructor() {\n    super();\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/class-inheritance"
    },
    {
      "title": "抽象クラス (abstract class)",
      "content": "---\nsidebar_label: 抽象クラス\n---\n\n# 抽象クラス (abstract class)\n\nJavaやPHPなどの言語では、`abstract`修飾子を使って抽象クラスを定義できます。抽象クラスは、直接インスタンスを作れないクラスのことです。JavaScriptには抽象クラスを定義する構文はありません。一方、TypeScriptには`abstract`修飾子があり抽象クラスを表現できます。\n\n`abstract`は抽象クラスを作成する時に宣言します。抽象クラスとは直接インスタンス化(`new`)することができず、必ずスーパークラスとして利用することを保証するものです。抽象クラス内のメソッドにも`abstract`宣言を行うことができます。`interface`と同じようにサブクラスは抽象メソッドを実装する必要があります。\n\n`Food`クラスを抽象クラスに変更し、\"要冷蔵\"メソッド`keepRefrigerated()`を抽象メソッドとして追加すると`Meat`クラスでエラーが発生します。これは`Meat`クラスに`keepRefrigerated`メソッドが実装されていないからです。\n\n```ts twoslash\n// @errors: 18052\nabstract class Food {\n  constructor(protected name: string, protected calorie: number) {}\n  showDebug() {\n    console.log(`name = ${this.name} `);\n    console.log(`calorie = ${this.calorie}kcal `);\n  }\n  abstract keepRefrigerated(): boolean;\n}\n\nclass Meat extends Food {}\n```\n\n`keepRefrigerated()`メソッドを実装することによりエラーはなくなります。\n\n```ts twoslash\nabstract class Food {\n  constructor(protected name: string, protected calorie: number) {}\n  showDebug() {\n    console.log(`name = ${this.name} `);\n    console.log(`calorie = ${this.calorie}kcal `);\n  }\n  abstract keepRefrigerated(): boolean;\n}\n// ---cut---\nclass Meat extends Food {\n  keepRefrigerated(): boolean {\n    return true;\n  }\n}\n```\n\n## JavaScriptへのコンパイルしたときに起こること\n\nTypeScriptの抽象クラスは、JavaScriptにコンパイルしたとき、消されることなく残ります。何も中身がない抽象クラスを定義してコンパイルしてみるとどうなるでしょうか。\n\n```ts twoslash\nabstract class AbstractClass {}\n```\n\n上のTypeScriptをコンパイルすると、次のJavaScriptが生成されます。\n\n```ts twoslash title=\"コンパイル結果\"\n// @showEmit\n// @alwaysStrict: false\nabstract class AbstractClass {}\n```\n\nこのように、抽象クラスは`abstract`修飾子が外され、ただのクラスとしてコンパイルされます。\n\n抽象メソッドは、コンパイル時に消されます。たとえば、次の実装の中身がある`concreteMethod`は残りますが、抽象メソッドの`abstractMethod`は消えます。\n\n```ts twoslash\nabstract class AbstractClass {\n  concreteMethod(): void {\n    /* 実装の中身 */\n  }\n  abstract abstractMethod(): void;\n}\n```\n\n上のTypeScriptのコンパイル結果は次のようになります。\n\n```ts twoslash title=\"コンパイル結果\"\n// @showEmit\n// @alwaysStrict: false\nabstract class AbstractClass {\n  concreteMethod(): void {\n    /* 実装の中身 */\n  }\n  abstract abstractMethod(): void;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/abstract-class"
    },
    {
      "title": "フィールド (field)",
      "content": "---\nsidebar_label: フィールド\n---\n\n# フィールド (field)\n\nJavaScriptでインスタンスにフィールドを持たせるには、インスタンス化したオブジェクトのプロパティに値を代入します。\n\n```js title=\"JavaScript\" twoslash\nclass Person {}\nconst alice = new Person();\nalice.name = \"Alice\";\n```\n\nTypeScriptでは、これに加えてフィールドの型注釈を書く必要があります。\n\n```ts title=\"TypeScript\" twoslash\nclass Person {\n  name: string;\n}\nconst alice = new Person();\nalice.name = \"Alice\";\n// @noErrors\n```\n\nTypeScriptは、クラスの宣言に書かれていないフィールドへアクセスした場合、コンパイルエラーになります。\n\n```ts title=\"TypeScript\" twoslash\n// @errors: 2339\nclass Person {}\nconst person = new Person();\nconsole.log(person.age);\n```\n\nフィールドは宣言時に型を省略した場合でもコンストラクタで値が代入される場合は、代入する値で型が推論されます。下の例ではコンストラクタで`string`の型の値を代入しているため`name`は`string`型となります。\n\n```ts twoslash\nclass Person {\n  private name;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n```\n\n## 初期化なしのフィールドとチェック\n\nTypeScriptのコンパイラーオプションで`strictNullChecks`と`strictPropertyInitialization`の両方が有効になっている場合、次の例の`name: string`の部分はコンパイルエラーとして指摘されます。なぜなら、`new Person`した直後は、`name`が`undefined`になるためです。\n\n```ts twoslash\nclass Person {\n  name: string;\n}\nconst alice = new Person();\nconsole.log(alice.name);\n// @log: undefined\n// @errors: 2564\n```\n\n[strictNullChecks](../../tsconfig/strictnullchecks.md)\n\n[strictPropertyInitialization](../../tsconfig/strictpropertyinitialization.md)\n\nこの2つのコンパイラーオプションが有効な場合でもチェックを通るように書くには、nameフィールドの型注釈を`string | undefined`のようなユニオン型にする必要があります。\n\n```ts twoslash\nclass Person {\n  name: string | undefined;\n}\nconst alice = new Person();\nconsole.log(alice.name);\n// @log: undefined\n```\n\n## コンストラクタを用いたフィールドの初期化\n\nフィールドへの値代入は、コンストラクタを用いて行えます。コンストラクタの中では、`this`を用いて値を代入したいフィールドにアクセスします。\n\n```ts title=\"TypeScript\" twoslash\nclass Person {\n  name: string;\n\n  constructor() {\n    this.name = \"Alice\";\n  }\n}\n```\n\nコンストラクタに引数を持たせれば、フィールドの値を動的に指定できるようにもできます。\n\n```ts title=\"TypeScript\" twoslash\nclass Person {\n  name: string;\n\n  constructor(personName: string) {\n    this.name = personName;\n  }\n}\nconst alice = new Person(\"Alice\");\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/fields"
    },
    {
      "title": "メソッド (method)",
      "content": "---\nsidebar_label: メソッド\n---\n\n# メソッド (method)\n\nJavaScriptのクラスにメソッドを実装するには、メソッド構文を用います。\n\n```js twoslash\nclass Greeter {\n  greet(name) {\n    return `Hello, ${name}!`;\n  }\n}\n```\n\n## メソッドの型注釈\n\nTypeScriptでは、メソッドの引数と戻り値に型注釈できます。\n\n```ts twoslash\nclass Greeter {\n  greet(name: string): string {\n    return `Hello, ${name}!`;\n  }\n}\n```\n\nメソッドの型注釈は関数宣言構文の型注釈と同じです。引数や戻り値の型注釈を省略することもできます。その場合の振る舞いについては関数宣言を参照してください。\n\n[関数宣言 (function declaration)](../../functions/function-declaration.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/methods"
    },
    {
      "title": "静的フィールド (static field)",
      "content": "---\nsidebar_label: 静的フィールド\n---\n\n# 静的フィールド (static field)\n\nJavaやPHPには静的フィールド(static field)という概念があります。通常のフィールドはインスタンスのプロパティですが、静的フィールドはクラスのプロパティです。JavaやPHPではstaticキーワードで静的フィールドを宣言できます。\n\n```java title=\"Java\"\nclass SomeClass {\n    public static Integer field = 123;\n}\n\nclass Main {\n    public static void main(String[] args) {\n        System.out.println(SomeClass.field); //=> 123\n    }\n}\n```\n\n```php title=\"PHP\"\nclass SomeClass\n{\n    public static $field = 123;\n}\n\nvar_dump(SomeClass::$field); //=> int(123)\n```\n\nJavaScriptにはJavaのような静的フィールドの機能がありません。代わりに、クラスのプロパティに後から値を代入することで似たようなことができます。\n\n```js title=\"JavaScript\" twoslash\nclass SomeClass {}\nSomeClass.field = 123;\nconsole.log(SomeClass.field);\n// @log: 123\n```\n\nTypeScriptでは、Java風の静的フィールドの書き方ができるようになっています。TypeScriptで静的フィールドを宣言するにはstaticキーワードを用います。\n\n```ts title=\"TypeScript\" twoslash\nclass SomeClass {\n  static field: number = 123;\n}\n\nconsole.log(SomeClass.field);\n// @log: 123\n```\n\n## 静的フィールドの型推論\n\nTypeScriptの静的フィールドは初期値がセットされている場合、その初期値からフィールドの型が型推論されます。そのため、フィールドの型注釈が省略できます。\n\n```ts twoslash\nclass SomeClass {\n  static field = 123;\n}\n```\n\n## 静的フィールドとアクセス修飾子\n\nTypeScriptの静的フィールドはアクセス修飾子を組み合わせられます。\n\n```ts twoslash\nclass SomeClass {\n  private static field: number;\n}\n```\n\n[アクセス修飾子 (access modifier)](access-modifiers.md)\n\n## 読み取り専用の静的フィールド\n\nTypeScriptの静的フィールドはreadonly修飾子をつけると読み取り専用になります。\n\n```ts twoslash\nclass SomeClass {\n  static readonly field: number;\n}\n```\n\n[クラスのreadonly修飾子](readonly-modifier-in-classes.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/static-fields"
    },
    {
      "title": "アクセス修飾子 (access modifier)",
      "content": "---\nsidebar_label: アクセス修飾子\n---\n\n# アクセス修飾子 (access modifier)\n\nJavaやPHPなどの言語では、フィールドやメソッドに`private`, `protected`, `public`を指定できます。JavaScriptでも`private`のようなプロパティを実現するために[プライベートクラスフィールド](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes/Private_class_fields)という仕様がありますが、Javaのようなアクセス修飾子とはやや様相が異なります。TypeScriptにはJava風のアクセス修飾子があります。\n\n| アクセス修飾子 | 説明                                     |\n| :------------- | :--------------------------------------- |\n| (宣言なし)     | publicと同等                             |\n| public         | どこからもアクセス可能                   |\n| protected      | 自身のクラスとサブクラスからアクセス可能 |\n| private        | 自身のクラスのみアクセス可能             |\n\nアクセス修飾子を省略した場合は`public`になります。\n\nアクセス修飾子は、フィールド、コンストラクタ、メソッドに宣言することができます。\n\n## `public`\n\n`public`アクセス修飾子はどこからもアクセス可能です。アクセス修飾子を省略した場合も`public`を指定したものと同等として扱われます。\n\n```ts twoslash\nclass Animal {\n  public name: string; // フィールドにpublicアクセス修飾子\n\n  // コンストラクターにpublicアクセス修飾子\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  // メソッドにpublicアクセス修飾子\n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n    // publicアクセス修飾子である`this.name`を使用することが可能\n  }\n}\n```\n\n`gorilla`を実装し、動作を確認してみます。\n\n```ts twoslash\nclass Animal {\n  public name: string;\n\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\n// ---cut---\nconst gorilla = new Animal(\"ゴリラ\");\ngorilla.move(10);\n// @log: \"ゴリラ moved 10m.\"\ngorilla.name = \"ゴリラゴリラ\";\ngorilla.move(20);\n// @log: \"ゴリラゴリラ moved 20m.\"\n```\n\n`name`プロパティは`public`宣言されているため、インスタンスされた変数(`gorilla`)からの読み書きが可能になっています。「ゴリラ」から「ゴリラゴリラ」に変更することができます。\n\n## `protected`\n\n`protected`アクセス修飾子は自身のクラスとサブクラスからアクセス可能です。\n\n`Animal`クラス`move`メソッドのアクセス修飾子を`public`から`protected`に変更しエラーを出してみます。\n\n```ts twoslash\n// @errors: 2445\nclass Animal {\n  public name: string;\n\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  // `public`から`protected`に変更\n  protected move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nconst gorilla = new Animal(\"ゴリラ\");\ngorilla.move(10);\n```\n\n`gorilla.move()`メソッドは`protected`宣言されているため、自身のクラスとサブクラスのみアクセスとなります。つまりインスタンスされた`gorilla`からはアクセスが拒否され、コンパイルエラーが発生します。\n\n`protected`で保護された`move()`メソッドを新たに実装し、10倍速く動くゴリラを作ってみます。\n\n```ts twoslash\nclass Animal {\n  public name: string;\n\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  // `public`から`protected`に変更\n  protected move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Gorilla extends Animal {\n  move(distanceInMeters: number) {\n    super.move(distanceInMeters * 10);\n  }\n}\n\nconst gorilla = new Gorilla(\"速いゴリラ\");\ngorilla.move(10);\n// @log: \"速いゴリラ moved 100m.\"\n```\n\n`Animal`スーパークラスを持つ`Gorilla`クラスを定義し`move()`を実装しています。`Gorilla`クラスの`move()`メソッド内で`super`キーワードを利用してスーパークラスの`move()`メソッドを呼び出しています。\n\n## `private`\n\n`private`アクセス修飾子は自身のクラスのみアクセス可能です。\n\n`protected move()`を`private move()`に変更してみます。`private`に変更されたことにより`Gorilla`クラスの`super.move`にアクセスすることが許されずエラーとなります。\n\n```ts twoslash\n// @errors: 2415 2341\nclass Animal {\n  public name: string;\n\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n\n  // `public`から`private`に変更\n  private move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Gorilla extends Animal {\n  move(distanceInMeters: number) {\n    super.move(distanceInMeters * 10);\n  }\n}\n```\n\n`private`メソッドの多くの使い方としては、自身のクラス内の長いコードを機能別に分ける時に利用します。\n\n## アクセス修飾子を変更する\n\nクラスの継承時に、メソッドのアクセス修飾子を変更することができます。とはいえなんでも自由に変更できるのではなく、アクセス制限を緩める方向にだけ変更できます。つまり`protected` > `public`の方向への変更は可能ですがその逆はできません。\n\n```ts twoslash\nclass ProtectedClass {\n  protected doNothing(): void {\n    console.log(\"DO NOTHING\");\n  }\n}\n\nclass PublicClass extends ProtectedClass {\n  public doNothing(): void {\n    console.log(\"DO NOTHING\");\n  }\n}\n```\n\n逆の`public` > `protected`の実装はできません。\n\n```ts twoslash\n// @errors: 2415\nclass PublicClass {\n  public doNothing(): void {\n    console.log(\"DO NOTHING\");\n  }\n}\n\nclass ProtectedClass extends PublicClass {\n  protected doNothing(): void {\n    console.log(\"DO NOTHING\");\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/access-modifiers"
    },
    {
      "title": "constructor shorthand",
      "content": "# constructor shorthand\n\nメソッドの引数にはアクセス修飾子を設定することはできませんがコンストラクタは特別です。\n\n引数に対してアクセス修飾子を宣言した場合はこのような意味になります。\n\n| アクセス修飾子 | 説明                                                                             |\n| :------------- | :------------------------------------------------------------------------------- |\n| (宣言なし)     | constructorメソッド内のみアクセス可能                                            |\n| public         | 自身のクラス内、継承クラス、インスタンス化されたクラスのどれからでもアクセス可能 |\n| protected      | 自身のクラス、継承クラスからアクセス可能                                         |\n| private        | 自身のクラスのみアクセス可能                                                     |\n\n`ConstructorInAccessModifier`クラスと`ConstructorOutAccessModifier`クラスのふたつを定義しました。\n\nふたつのクラスの違いはコンストラクタにアクセス修飾子を定義しているかどうかだけで機能はまったく同じです。\n\n```ts title=\"example.ts\" twoslash\nclass ConstructorInAccessModifier {\n  constructor(\n    arg0: number,\n    public arg1: number,\n    protected arg2: number,\n    private arg3: number\n  ) {\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\n\nclass ConstructorOutAccessModifier {\n  public arg1: number;\n  protected arg2: number;\n  private arg3: number;\n  constructor(arg0: number, arg1: number, arg2: number, arg3: number) {\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n    this.arg3 = arg3;\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\n```\n\nコンパイル後のJavaScriptファイルを見てみると同一の機能を持つことが確認することができます。\n\n```js title=\"example.js\" twoslash\nclass ConstructorInAccessModifier {\n  constructor(arg0, arg1, arg2, arg3) {\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n    this.arg3 = arg3;\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\nclass ConstructorOutAccessModifier {\n  constructor(arg0, arg1, arg2, arg3) {\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n    this.arg3 = arg3;\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\n```\n\nTypeScriptで記述する際は各アクセス修飾子のスコープ機能が有効になるため、インスタンスからのアクセスが可能なプロパティは`public`宣言された`arg1`のみが有効になります。\n\n```ts title=\"example.ts\" twoslash\nclass ConstructorInAccessModifier {\n  constructor(\n    arg0: number,\n    public arg1: number,\n    protected arg2: number,\n    private arg3: number\n  ) {\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\n\nclass ConstructorOutAccessModifier {\n  public arg1: number;\n  protected arg2: number;\n  private arg3: number;\n  constructor(arg0: number, arg1: number, arg2: number, arg3: number) {\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n    this.arg3 = arg3;\n    console.log({ arg0, arg1, arg2, arg3 });\n  }\n}\n\n// ---cut---\n// @errors: 2339 2445 2341\nconst InAccess = new ConstructorInAccessModifier(1, 2, 3, 4);\nInAccess.arg0;\nInAccess.arg1;\nInAccess.arg2;\nInAccess.arg3;\n\nconst outAccess = new ConstructorOutAccessModifier(1, 2, 3, 4);\noutAccess.arg0;\noutAccess.arg1;\noutAccess.arg2;\noutAccess.arg3;\n```\n\nつまり、コンストラクタの引数のアクセス修飾子はプロパティ宣言の省略をしてくれるだけにすぎません。\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/constructor-shorthand"
    },
    {
      "title": "コンストラクタ (constructor)",
      "content": "---\nsidebar_label: コンストラクタ\n---\n\n# コンストラクタ (constructor)\n\nコンストラクタはクラスをnewしたときに実行される関数です。コンストラクタは、インスタンスプロパティの初期化する処理を実装する場所です。JavaScriptのコンストラクタは、constructor構文で書きます。\n\n```ts\nclass Person {\n  constructor(name) {\n    // ...\n  }\n}\n```\n\n## コンストラクタの型注釈\n\nTypeScriptでコンストラクタ引数の型注釈は、関数の型注釈のやり方と同じです。\n\n```ts twoslash\nclass Person {\n  constructor(name: string) {\n    // ...\n  }\n}\n```\n\nコンストラクタの戻り値は型注釈できません。コンストラクタの戻り値は、当然クラスのインスタンスなので、型注釈でコンパイラーに教える必要性がないのです。\n\n## コンストラクタに引数を渡す\n\nJavaScriptでコンストラクタに引数を渡す方法は、関数呼び出しの書き方とほぼ同じです。違いはnew演算子をつけることです。\n\n```ts twoslash\nclass Person {\n  constructor(name: string) {\n    // ...\n  }\n}\n// ---cut---\nnew Person(\"Alice\");\n```\n\n## 関連情報\n\n[constructor shorthand](constructor-shorthand.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/constructor"
    },
    {
      "title": "フィールドの初期化子 (initializer)",
      "content": "---\nsidebar_label: フィールドの初期化子\n---\n\n# フィールドの初期化子 (initializer)\n\nTypeScriptでは、初期化子(initializer)を使うとインスタンスのフィールドの初期値を指定できます。初期化子はフィールド名の右に`= 値`と書きます。初期化子は、クラスがインスタンス化されるときに自動的に実行されます。\n\n```ts twoslash\nclass Point {\n  x: number = 0;\n  y: number = 0;\n}\nconst point = new Point();\nconsole.log(point.x, point.y);\n// @log: 0 0\n```\n\n初期化子を用いた上の例は、次のコンストラクタでフィールドを初期化するのと同じ意味です。\n\n```ts twoslash\nclass Point {\n  x: number;\n  y: number;\n\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n  }\n}\n```\n\n## 初期化子と型推論\n\n初期化子で値の型が自明な場合、TypeScriptコンパイラーはフィールドの型を推論してくれます。そのため、初期化子を伴うフィールドは型注釈を省略できます。\n\n```ts twoslash\nclass Point {\n  x = 0; // number型と型推論される\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/field-initializers"
    },
    {
      "title": "メソッド戻り値のthis型とメソッドチェーン",
      "content": "# メソッド戻り値のthis型とメソッドチェーン\n\n## fluent interface\n\nfluent interfaceとは「流れるようなインターフェース」という意味で、method chaining(メソッドの連鎖)という小技を使って、可読性の高いコードを実現するメソッドの作り方のことです。よくドメイン固有言語(DSL)を提供するようなクラスを作るときに使われます。\n\n四則演算ができる変哲もないクラス`Operator`を考えます\n\n```ts twoslash\nclass Operator {\n  protected value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public sum(value: number): void {\n    this.value += value;\n  }\n\n  public subtract(value: number): void {\n    this.value -= value;\n  }\n\n  public multiply(value: number): void {\n    this.value *= value;\n  }\n\n  public divide(value: number): void {\n    this.value /= value;\n  }\n}\n\nconst op: Operator = new Operator(0);\n\nop.sum(5); // 5\nop.subtract(3); // 2\nop.multiply(6); // 12\nop.divide(3); // 4\n```\n\n演算ごとにステートメントを分ける必要があります。このような場合メソッドチェーンを使って処理を連続させることができます。\n\n```ts twoslash\nclass Operator {\n  protected value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public sum(value: number): Operator {\n    this.value += value;\n    return this;\n  }\n\n  public subtract(value: number): Operator {\n    this.value -= value;\n    return this;\n  }\n\n  public multiply(value: number): Operator {\n    this.value *= value;\n    return this;\n  }\n\n  public divide(value: number): Operator {\n    this.value /= value;\n    return this;\n  }\n}\n\nconst op: Operator = new Operator(0);\nop.sum(5).subtract(3).multiply(6).divide(3); // 4\n```\n\n`op.sum(), op.subtract(), op.multiply(). op.divide()`の戻り値の型を`Operator`に変更しました。これによりメソッドチェーンが可能になりました。\n\nここで、このクラス`Operator`を拡張して累乗の計算を追加したいとします。すると新しいクラス`NewOperator`は次のようになるでしょう。\n\n```ts twoslash\nclass Operator {\n  protected value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n}\n// ---cut---\n// @errors: 2304\nclass NewOperator extends Operator {\n  public constructor(value: number) {\n    super(value);\n  }\n\n  public power(value: number): NewOperator {\n    this.value **= value;\n    return this;\n  }\n}\n```\n\nですが、このクラスでは次の演算ができません。\n\n```ts twoslash\nclass Operator {\n  protected value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public sum(value: number): Operator {\n    this.value += value;\n    return this;\n  }\n\n  public subtract(value: number): Operator {\n    this.value -= value;\n    return this;\n  }\n\n  public multiply(value: number): Operator {\n    this.value *= value;\n    return this;\n  }\n\n  public divide(value: number): Operator {\n    this.value /= value;\n    return this;\n  }\n}\n\nclass NewOperator extends Operator {\n  public constructor(value: number) {\n    super(value);\n  }\n\n  public power(value: number): NewOperator {\n    this.value **= value;\n    return this;\n  }\n}\n// ---cut---\n// @errors: 2339\nconst op: NewOperator = new NewOperator(2);\nop.power(3).multiply(2).power(3);\n```\n\nこれは`op.multiply()`の戻り値が`Operator`だからです。`Operator`には`power()`というメソッドがないためこのような問題が発生します。\n\nこのようなとき、戻り値に`this`を設定することができます。上記クラスの戻り値の`Operator, NewOperator`をすべて`this`に置き換えると問題が解消されます。\n\n```ts twoslash\nclass Operator {\n  protected value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public sum(value: number): this {\n    this.value += value;\n    return this;\n  }\n\n  public subtract(value: number): this {\n    this.value -= value;\n    return this;\n  }\n\n  public multiply(value: number): this {\n    this.value *= value;\n    return this;\n  }\n\n  public divide(value: number): this {\n    this.value /= value;\n    return this;\n  }\n}\n\nclass NewOperator extends Operator {\n  public constructor(value: number) {\n    super(value);\n  }\n\n  public power(value: number): this {\n    this.value **= value;\n    return this;\n  }\n}\n\nconst op: NewOperator = new NewOperator(2);\nop.power(3).multiply(2).power(3); // 4096\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/return-this-type"
    },
    {
      "title": "finalクラス・sealedクラス",
      "content": "# finalクラス・sealedクラス\n\nJavaやPHPなどの他の言語には、finalクラスという機能があります。finalクラスは継承できないクラスです。finalクラスは意図しないサブクラスが生まれるのを抑制できる機能です。こうした機能はJavaScriptにはありません。TypeScriptにもありません。同様にfinalメソッドもJavaScript、TypeScript両方にありません。\n\nsealedクラスはScalaやKotlinなどの言語に見られる機能で、継承を制限する面ではfinalクラスと似ています。sealedクラスは同じモジュール内(ファイルの単位など)であれば継承できますが、他のモジュールでは継承できないクラスです。sealedクラスのようなものは、JavaScriptにもTypeScriptにもありません。\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/final-sealed-class"
    },
    {
      "title": "静的メソッド (static method)",
      "content": "---\nsidebar_label: 静的メソッド\n---\n\n# 静的メソッド (static method)\n\nJavaやPHPには静的メソッド(static method)という概念があります。Rubyではクラスメソッドに相当します。通常のメソッドはインスタンスに属しますが、静的メソッドはクラスに属します。JavaやPHPではstaticキーワードで静的フィールドを宣言できます。\n\n```java title=\"Java\"\nclass SomeClass {\n    static public void doSomething() {\n        // ...\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        SomeClass.doSomething();\n    }\n}\n```\n\n```php title=\"PHP\"\nclass SomeClass\n{\n    public static function doSomething()\n    {\n        // ...\n    }\n}\n\nSomeClass::doSomething();\n```\n\nJavaScriptにはJavaのような静的メソッドの機能がありません。代わりに、クラスのプロパティに後から関数を代入することで似たようなことができます。\n\n```js title=\"JavaScript\" twoslash\nclass SomeClass {}\nSomeClass.doSomething = function () {\n  // ...\n};\nSomeClass.doSomething();\n```\n\nTypeScriptでは、Java風の静的メソッドの書き方ができるようになっています。TypeScriptで静的メソッドを宣言するにはstaticキーワードを用います。\n\n```ts title=\"TypeScript\" twoslash\nclass SomeClass {\n  static doSomething() {\n    // ...\n  }\n}\n\nSomeClass.doSomething();\n```\n\n## 静的メソッドとアクセス修飾子\n\nTypeScriptの静的メソッドはアクセス修飾子を組み合わせられます。\n\n```ts twoslash\nclass SomeClass {\n  private static doSomething() {\n    // ...\n  }\n}\n```\n\n[アクセス修飾子 (access modifier)](access-modifiers.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/static-methods"
    },
    {
      "title": "クラスのreadonly修飾子",
      "content": "# クラスのreadonly修飾子\n\nTypeScriptでは、フィールドにreadonly修飾子をつけると、そのフィールドを読み取り専用にできます。\n\n読み取り専用フィールドは、コンストラクタかフィールド初期化子でのみ値を代入できます。\n\n```ts twoslash\nclass Octopus {\n  readonly name: string;\n  readonly legs = 8; // フィールド初期化子での代入はOK\n\n  constructor() {\n    this.name = \"たこちゃん\"; // コンストラクターでの代入はOK\n  }\n}\n```\n\n読み取り専用フィールドは、再代入しようとするとコンパイルエラーになります。\n\n```ts twoslash\nclass Octopus {\n  readonly name: string;\n  readonly legs = 8; // フィールド初期化子での代入はOK\n\n  constructor() {\n    this.name = \"たこちゃん\"; // コンストラクターでの代入はOK\n  }\n}\n// ---cut---\n// @errors: 2540\nconst octopus = new Octopus();\noctopus.legs = 16;\n```\n\nメソッド内の処理であっても、読み取り専用フィールドへの再代入は許されません。\n\n```ts twoslash\n// @errors: 2540\nclass Octopus {\n  readonly name = \"たこちゃん\";\n\n  setName(newName: string): void {\n    this.name = newName;\n  }\n}\n```\n\n## 関連情報\n\n[オブジェクト型のreadonlyプロパティ (readonly property)](../../values-types-variables/object/readonly-property.md)\n\n[インターフェースのreadonly修飾子](../interface/readonly-modifier-in-interfaces.md)\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/readonly-modifier-in-classes"
    },
    {
      "title": "instanceof演算子",
      "content": "# instanceof演算子\n\n`instanceof`演算子は、特定のオブジェクトがクラスのインスタンスかをチェックするJavaScriptの演算子です。\n\n## 構文\n\n```js twoslash\n// prettier-ignore\nオブジェクト instanceof クラス\n```\n\n### 引数\n\n- オブジェクト: 検査するオブジェクトです。\n- クラス: 検査対象のクラス名です。\n\n## 例\n\n```ts twoslash\nclass ClassA {}\nclass ClassB {}\nconst a = new ClassA();\nconsole.log(a instanceof ClassA);\n// @log: true\nconsole.log(a instanceof ClassB);\n// @log: false\n```\n\n## 継承と`instanceof`\n\n`instanceof`は継承関係をチェックすることもできます。たとえば、次のように`Child`クラスのインスタンスが`Parent`クラスのインスタンスかをチェックすることができます。\n\n```ts twoslash\nclass Parent {}\nclass Child extends Parent {}\nconst child = new Child();\nconsole.log(child instanceof Parent);\n// @log: true\n```\n\n## `instanceof`の反転\n\n`instanceof`演算子の結果を反転させる場合は、`値 instanceof クラス名`の句全体をカッコで囲った上で、否定演算子`!`を先頭につける必要があります。\n\n```ts twoslash\nclass MyClass {}\nconst myInstance = new MyClass();\n// ---cut---\nif (!(myInstance instanceof MyClass)) {\n  // myInstanceがMyClassではないときの処理\n}\n```\n\n## 抽象クラスと`instanceof`\n\nTypeScriptには[抽象クラス](./abstract-class.md)があります。`instanceof`演算子は抽象クラスについても使うことができます。\n\n```ts twoslash\nabstract class AbstractClass {}\nclass ConcreteClass extends AbstractClass {}\nconst obj = new ConcreteClass();\nconsole.log(obj instanceof AbstractClass);\n// @log: true\n```\n",
      "url": "https://typescriptbook.jp/reference/object-oriented/class/instanceof-operator"
    },
    {
      "title": "JavaScriptにおける非同期処理",
      "content": "---\ntitle: 非同期処理\nslug: /reference/asynchronous\n---\n\nもしJavaScriptで本格的に何かを作りたいのであれば、非同期処理とは切っても切れない関係になるでしょう。初めのうちは理解に苦しむことが多いですが今では非同期処理を直観的に操作できる機能が実装されたのでハードルは大きく下がりました。\n\n## JavaScriptにおける非同期処理\n\nJavaScriptはシングルプロセス、シングルスレッドで動作する言語です。この特徴については別のページにもありますが、これはすべてのプログラムは直列に処理されるということを意味します。\n\n[シングルプロセス・シングルスレッドとコールバック](../single-process-and-callback.md)\n\nこれだけ聞けばすべてのJavaScriptのプログラムは上から下に同期的に処理されるようにも聞こえます。\nですがこの特徴には弱点があります。直列に処理されるため時間のかかる処理があるとその間は他の処理が実行されません。たとえばAPIリクエストの場合処理の大部分は待ち時間ですが、この待ち時間も直列に処理されるとその間は何もできないことになってしまいます。これをブロッキングといいます。\nこの問題を回避するためにJavaScriptではノンブロッキングを扱います。ノンブロッキングでは処理を受けたあと即座に処理を返し、あとで別の方法で結果を伝えます。この方法をコールバックと呼ぶこともあります。コールバックの言葉は折り返しの電話を意味します。\n\n## Promiseの誕生\n\nJavaScriptにおける非同期処理にはコードの見通しが悪くなる(コールバック地獄)という弊害があります。ES2015から追加されたPromiseはその打開策ともいえ、JavaScriptのコードをコールバック地獄から解き放ちました。\nそしてそのPromiseをさらに使いやすくするためにasync/awaitがES2017で追加されました。\n\n## 本章で取り上げる内容について\n\n本章ではこれらPromise/async/awaitの使いかたや特徴をそれぞれのページに分けて取り上げていきます。\n",
      "url": "https://typescriptbook.jp/reference/asynchronous/README"
    },
    {
      "title": "`await`",
      "content": "---\ntitle: await\nslug: /reference/asynchronous/await\n---\n\n`Promise`を利用した非同期処理をより簡単に書ける構文として`async`/`await`が存在します。\nこの構文を利用することで、非同期処理をより同期処理と同じような文脈で書くことができるようになります。\n`async`/`await`は基本セットで使いますが、本ページでは`await`を主に取り上げます。\n\n### `await`\n\n`await`は`Promise`の値が解決されるまで実行を待機して、解決された値を返します。\n\n`await`の注意点として**基本的に`await`は`async`関数の中でしか使えません。**\n\n```ts twoslash\n// 1秒後に値を返す\nfunction request(): Promise<string> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(\"hello\");\n    }, 1000);\n  });\n}\n\n// この書き方はできない\n// const result = await request();\n// console.log(result);\n\nasync function main() {\n  const result = await request();\n  console.log(result);\n  // @log: \"hello\"\n}\n\nmain();\n```\n\nこの例では`await request()`の行で`request()`が`Promise`を解決するまで1秒待機し、コンソールに`\"hello\"`と表示します。\n\n### `async`/`await`で書き直す\n\n最後に３つのAPI呼び出しのコードを`async`/`await`を利用して書き直してみます。\n\nこのように`async`/`await`を利用することで、非同期の処理を同期処理のようにスッキリ書くことができるようになります。\n\n```ts twoslash\n// 非同期でAPIにリクエストを投げて値を取得する処理\nfunction request1(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\n}\n\n// 受け取った値を別のAPIにリクエストを投げて値を取得する処理\nfunction request2(result1: number): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result1 + 1);\n    }, 1000);\n  });\n}\n\n// 受け取った値を別のAPIにリクエストを投げて値を取得する処理\nfunction request3(result2: number): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result2 + 2);\n    }, 1000);\n  });\n}\n\nasync function main() {\n  const result1 = await request1();\n  const result2 = await request2(result1);\n  const result3 = await request3(result2);\n  console.log(result3);\n  // @log: 4\n}\n\nmain();\n```\n\n### `Promise`を直接`await`する\n\n関数を作らずに`Promise`を直接`await`することもできます。\n\n```ts twoslash\nasync function main() {\n  // 1秒後に値を返す\n  await new Promise((resolve) => {\n    setTimeout(() => resolve, 1000);\n  });\n}\n```\n\n### `async`関数を`await`する\n\n`async`関数を`await`することもできます。\n\n```ts twoslash\nasync function request(): Promise<string> {\n  return \"hello\";\n}\n\nasync function main() {\n  const result = await request();\n  console.log(result);\n  // @log: \"hello\"\n}\n```\n\n### `await`したときの型注釈\n\n`Promise`, `async`関数の戻り値の型注釈は`Promise<T>`の`T`になります。\n\n```ts twoslash\nasync function request(): Promise<string> {\n  return \"hello\";\n}\n\nasync function main() {\n  const result: string = await request();\n  // stringになる\n  console.log(result);\n  // @log: \"hello\"\n}\n```\n\n### `then-catch`を`try-catch`に書き換える\n\n`Promise`の`then`と`catch`を`try-catch`に書き換えることができます。次の`main2`関数は`main1`関数を`try-catch`で書き換えたものです。\n\n```ts twoslash\nasync function request(): Promise<string> {\n  return \"hello\";\n}\n\nfunction main1() {\n  request()\n    .then((result: string) => {\n      console.log(result);\n      // @log: \"hello\"\n    })\n    .catch((error: unknown) => {\n      console.log(error);\n    });\n}\n\nasync function main2() {\n  try {\n    const result: string = await request();\n    console.log(result);\n    // @log: \"hello\"\n  } catch (error: unknown) {\n    console.log(error);\n  }\n}\n```\n\n### 拒否された`Promise`を`return`するとき\n\n#### `return`の前に`await`する\n\n拒否された`Promise`を`return`する前に`await`したときは、その関数内で例外が発生します。\n\n```ts twoslash\nasync function request(): Promise<unknown> {\n  throw new Error(\"error\");\n}\n\nasync function main(): Promise<unknown> {\n  try {\n    // return await とすることでcatchで例外を捕捉できる\n    return await request();\n  } catch {\n    console.log(\"error\");\n    // @log: error\n  } finally {\n    console.log(\"finally\");\n    // @log: finally\n  }\n}\n\nmain()\n  .then(() => {\n    console.log(\"then\");\n    // @log: then\n  })\n  .catch(() => {\n    console.log(\"catch\");\n  });\n```\n\nこのような例であれば表示されるものは`error`と`finally`、そして`then`が表示されます。\n\n#### `return`の前に`await`しない (ただ`return`する)\n\n拒否された`Promise`をそのまま関数の戻り値にしてしまうと拒否されたまま呼び出し元に戻されます。\n\n```ts twoslash\nfunction request(): Promise<unknown> {\n  throw new Error(\"error\");\n}\n\n// try -> finally -> return -> catch()\nasync function main(): Promise<unknown> {\n  try {\n    return request();\n  } catch {\n    console.log(\"error\");\n  } finally {\n    console.log(\"finally\");\n    // @log: finally\n  }\n}\n\nmain()\n  .then(() => {\n    console.log(\"then\");\n  })\n  .catch(() => {\n    console.log(\"catch\");\n    // @log: catch\n  });\n```\n\nこのような例であれば表示されるものは`finally`と`catch`が表示されます。\n",
      "url": "https://typescriptbook.jp/reference/asynchronous/await"
    },
    {
      "title": "`async`関数、`async`メソッド",
      "content": "---\ntitle: async\nslug: /reference/asynchronous/async\n---\n\n`Promise`を利用した非同期処理をより簡単に書ける構文として`async`/`await`が存在します。\nこの構文を利用することで、非同期処理をより同期処理と同じような文脈で書くことができるようになります。\n`async`/`await`は基本セットで使いますが、本ページでは`async`を主に取り上げます。\n\n### `async`関数、`async`メソッド\n\n関数、メソッドの前に`async`キーワードをつけると、たとえその関数内で`Promise`が返されていなくても、戻り値の型を`Promise`で包んで返します。`async`関数、メソッドの中では`await`キーワードを使うことができます。`await`については`await`のページをご参照ください。\n\n[await](./await.md)\n\n```ts twoslash\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n};\n\ndeclare function findById(id: string): Promise<any>;\n// ---cut---\nasync function requestAsync(): Promise<number> {\n  return 1;\n}\n\nconst fetchAsync = async (): Promise<number> => {\n  return 1;\n};\n\nclass UserRepository {\n  async find(id: string): Promise<User> {\n    const { name, age } = await findById(id);\n\n    return {\n      id,\n      name,\n      age,\n    };\n  }\n}\n```\n\nこの例では`Promise`ではない定数を返していますが`async`関数はその戻り値を`Promise`で包んでいます。\n\n```ts twoslash\nasync function requestAsync(): Promise<number> {\n  return 1;\n}\n\n// requestAsyncはこれと同じ\nfunction request(): Promise<number> {\n  return new Promise((resolve) => {\n    resolve(1);\n  });\n}\n\nrequestAsync().then((result) => {\n  console.log(result);\n  // @log: 1\n});\n```\n\n### `async`関数の宣言\n\nJavaScriptには３つの関数の宣言方法がありますが、それらを`async`関数として宣言することもできます。\n\n```ts twoslash\nasync function requestAsync1(): Promise<number> {\n  return 1;\n}\n\nconst requestAsync2 = async function (): Promise<number> {\n  return 1;\n};\n\nconst requestAsync3 = async (): Promise<number> => {\n  return 1;\n};\n```\n\n### `async`メソッドとアクセス修飾子\n\nメソッドでアクセス修飾子をつけたい場合は`async`の前につけます。\n\n```ts twoslash\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n};\n\ndeclare function findById(id: string): Promise<any>;\n// ---cut---\nclass UserRepository {\n  public async find(id: string): Promise<User> {\n    const { name, age } = await findById(id);\n\n    return {\n      id,\n      name,\n      age,\n    };\n  }\n}\n```\n\n### `async`関数、メソッドの戻り値\n\n`async`関数は`Promise`を戻り値として返すことも可能です。このとき`Promise<Promise<T>>`のように`Promise`が二重に包まれることはなく、`Promise<T>`となります。\n\n```ts twoslash\nasync function requestAsync(): Promise<number> {\n  return new Promise((resolve) => {\n    resolve(1);\n  });\n}\n\nrequestAsync().then((result) => {\n  console.log(result);\n  // @log: 1\n});\n```\n\n### `async`関数、メソッドをreject(拒否)する\n\n`async`関数、メソッドを拒否するためには`async`関数、メソッド内で`throw`を使うだけです。\n\n```ts twoslash\nasync function requestAsync(): Promise<number> {\n  throw new Error(\"error\");\n}\n```\n\nこれで`requestAsync`が返す`Promise`はreject(拒否)されます。\n",
      "url": "https://typescriptbook.jp/reference/asynchronous/async"
    },
    {
      "title": "`Promise`がなかった時代のこと",
      "content": "---\ntitle: Promise<T>\nslug: /reference/asynchronous/promise\n---\n\n`Promise`はES2015から追加された機能で、非同期処理を見通しよく書くことができます。ES2017で導入された`async`/`await`を使うことで`Promise`で書いたコードをさらに見通しよく書くことができます。\n\n## `Promise`がなかった時代のこと\n\n次の３つのAPIがあるとしてこれらで得た結果を表示する処理を考えてみます。\n\n1. API1: リクエストを送り、結果を受け取る\n1. API2: API1の結果を使ってリクエストを送り、結果を受け取る\n1. API3: API2の結果を使ってリクエストを送り、結果を受け取る\n\nAPI1, API2, API3の通信をする関数`request1()`, `request2()`, `request3()`は次のようになります。各関数の`setTimeout()`はAPI通信をしている部分の遅延を意味している程度に考えてください。\n\n```js twoslash\n// API1. 非同期でAPIにリクエストを送って値を取得する処理\nfunction request1(callback) {\n  setTimeout(() => {\n    // 1 は適当な例、なんでもいいです\n    callback(1);\n  }, 1000);\n}\n\n// API2. 受け取った値を別のAPIにリクエストを送って値を取得する処理\nfunction request2(result1, callback) {\n  setTimeout(() => {\n    callback(result1 + 1);\n  }, 1000);\n}\n\n// API3. 受け取った値を別のAPIにリクエストを送って値を取得する処理\nfunction request3(result2, callback) {\n  setTimeout(() => {\n    callback(result2 + 2);\n  }, 1000);\n}\n```\n\nこれらの関数を組み合わせて３つのAPIリクエストを順次実装すると次のようになります。\n\n```js twoslash\nrequest1((result1) => {\n  request2(result1, (result2) => {\n    request3(result2, (result3) => {\n      console.log(result3);\n      // @log: 4\n    });\n  });\n});\n```\n\n次のAPIにリクエストを投げるためにひとつ前の非同期なAPIリクエストの結果を待つ必要があり、関数の呼び出しが入れ子になってしまいます。\nこれを**コールバック地獄**と呼び、ネストが深くコードの記述が非常に複雑になってしまう問題があります。ちなみにコールバック地獄は英語でもCallback hellと呼びます。どの世界でも地獄は地獄です。\n\n## `Promise`が解決してくれること\n\n先ほどの例を`Promise`を使って書き直してみます。\n\n```js twoslash\n// 非同期でAPIにリクエストを投げて値を取得する処理\nfunction request1() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 1000);\n  });\n}\n\n// 受け取った値を別のAPIにリクエストを投げて値を取得する処理\nfunction request2(result1) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result1 + 1);\n    }, 1000);\n  });\n}\n\n// 受け取った値を別のAPIにリクエストを投げて値を取得する処理\nfunction request3(result2) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result2 + 2);\n    }, 1000);\n  });\n}\n```\n\n戻り値が`Promise`になり、コールバック関数を示す引数がなくなりました。`Promise`を返す関数を使うと次のように３つのAPIリクエストを実装できます。\n\n```js twoslash\nrequest1()\n  .then((result1) => {\n    return request2(result1);\n  })\n  .then((result2) => {\n    return request3(result2);\n  })\n  .then((result3) => {\n    console.log(result3);\n    // @log: 4\n  });\n```\n\n先ほどのコールバックの例と比べると非常にスッキリ書けるようになりました。\n\n## `Promise`とジェネリクス\n\nTypeScriptで`Promise`の型を指定する場合はジェネリクスを伴い`Promise<T>`と書きます。`T`には`Promise`が履行された(fulfilled)ときに返す値の型を指定します。今回の例では`resolve(1)`と履行する値として数値を渡しているので`Promise<number>`を指定しています。\nたとえば、独自で定義した型の値を履行する場合は次のように記述します。\n\n```ts twoslash\ntype User = {\n  name: string;\n  age: number;\n};\n\nfunction getUser(): Promise<User> {\n  return new Promise((resolve) => {\n    const user: User = {\n      name: \"太郎\",\n      age: 10,\n    };\n    resolve(user);\n  });\n}\n\ngetUser().then((user: User) => {\n  console.log(user);\n  // @log: { \"name\": \"太郎\", \"age\": 10 }\n});\n```\n\n`Promise`のジェネリクスの型`T`は必須なので、省略した場合はコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2314\nfunction request(): Promise {\n  return new Promise((resolve) => {\n    resolve(1);\n  });\n}\n```\n\nジェネリクスの型`T`と返す値の型が合わない場合もコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2345\nfunction request(): Promise<string> {\n  return new Promise((resolve) => {\n    // string型を期待しているが、number型を返しているのでコンパイルエラー\n    resolve(1);\n  });\n}\n```\n\n## `Promise`のメソッド\n\n`Promise<T>`には覚えておくべきメソッドが３つあります。\n\n### 待ち受けた非同期処理の結果をコールバックで実行する - `Promise.prototype.then()`\n\n`Promise<T>`が履行された(fulfilled)ときに呼び出されます。引数に使われるコールバックの第1引数は`T`型の値です。\nコールバックの戻り値として`S`型または`Promise<S>`型の値を返すと`Promise<S>`型を返します。\n\n```ts twoslash\nconst promise1: Promise<number> = Promise.resolve(1);\nconst promise2: Promise<string> = promise1.then((value) => `${value}`);\n```\n\n上記例は`Promise.prototype.then()`のたびに新しく定数を定義していますが。上述のとおり`Promise.prototype.then()`でメソッドチェーンできます。\n\n```ts twoslash\nconst promise: Promise<boolean> = Promise.resolve(\"1\")\n  .then((value) => Number(value)) // Promise<number>型になる\n  .then((value) => value > 0); // Promise<boolean>型になる\n```\n\nコールバック内で例外を投げるとそのPromiseは拒否されます。\n\n```ts twoslash\nPromise.resolve(1)\n  .then(() => {\n    throw new Error();\n  })\n  .then(() => {\n    console.log(\"fulilled\");\n  })\n  .catch(() => {\n    console.log(\"rejected\");\n  });\n// @log: 'rejected'\n```\n\n同様に、コールバック内で拒否された`Promise`を返すとそのPromiseは拒否されます。\n\n```ts twoslash\nPromise.resolve(1)\n  .then(() => {\n    return Promise.reject(new Error());\n  })\n  .then(() => {\n    console.log(\"fulilled\");\n  })\n  .catch(() => {\n    console.log(\"rejected\");\n  });\n// @log: 'rejected'\n```\n\n### 待ち受けた非同期処理の拒否の結果をコールバックで実行する - `Promise.prototype.catch()`\n\n`Promise<T>`が拒否された(rejected)ときに呼び出されます。引数に使われるコールバックの第1引数は`any`型の値です。\nこれもコールバックの戻り値として`S`型または`Promise<S>`型の値を返すと`Promise<S>`型を返します。\n\n```ts twoslash\nconst promise1: Promise<number> = Promise.reject(new Error());\nconst promise2: Promise<string> = promise1.catch((e) => e.message);\n```\n\n`Promise.prototype.catch()`は`Promise`が履行されている状態だと実行されません。そのため`Promise.prototype.catch()`のあとに`Promise.prototype.then()`をつなげると実行されたときの型と実行されなかったときの型の両方を考える必要があります。\n\n```ts twoslash\nPromise.resolve(1)\n  .catch(() => {\n    return \"1\";\n  })\n  // string | number型になる\n  .then((value: string | number) => {\n    console.log(value);\n  });\n```\n\nただし`Promise.prototype.catch()`のあとに`Promise.prototype.then()`を書くというより、`Promise.prototype.then()`のあとに`Promise.prototype.catch()`を書くほうが多いでしょう。\n\n```ts twoslash\nPromise.resolve(1)\n  .then((num: number) => {\n    return `${num}`;\n  })\n  .then((str: string) => {\n    return str.length > 1;\n  })\n  .catch((e: any) => {\n    console.log(e.message);\n  });\n```\n\n### 待ち受けた非同期処理が終了次第コールバックを実行する - `Promise.prototype.finally()`\n\n`Promise<T>`が決定された(settled)ときに呼び出されます。コールバックに引数はありません。\nこのメソッドは戻り値を設定することはできません。\n`Promise.prototype.finally()`はES2018になって追加されました。\n\n## `Promise`の静的メソッド\n\n静的メソッドでも覚えておくべき大事なメソッドがあります。\n\n### すべての非同期処理の結果を待ち受ける - `Promise.all()`\n\n第1引数に要素が`Promise`の配列を取り、それらの実行結果を非同期で待ち受けます。戻り値は`Promise`が解決される時間にかかわらず配列に与えられた順番どおりにPromiseの結果が返ります。\n\n```ts twoslash\nfunction request1(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 4000);\n  });\n}\n\nfunction request2(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 2000);\n  });\n}\n\nfunction request3(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(3);\n    }, 1000);\n  });\n}\n\nPromise.all([request1(), request2(), request3()]).then(([num1, num2, num3]) => {\n  // request1が一番終了するまで遅いが結果の順番は保持され、num1がrequest1の結果になる\n  console.log(num1, num2, num3);\n  // @log: 1, 2, 3\n});\n```\n\n与えられた`Promise`のうちひとつでも拒否された場合`Promise.all()`は拒否されます。\n\n```ts twoslash\nfunction request1(): Promise<number> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"failed1\"));\n    }, 4000);\n  });\n}\n\nfunction request2(): Promise<number> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"failed2\"));\n    }, 2000);\n  });\n}\n\nfunction request3(): Promise<number> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"failed3\"));\n    }, 1000);\n  });\n}\n\nPromise.all([request1(), request2(), request3()])\n  .then(([num1, num2, num3]) => {\n    console.log(num1, num2, num3);\n  })\n  .catch((e) => {\n    // 最も早く終わった例外が返る\n    console.log(e.message);\n    // @log: 'failed3'\n  });\n```\n\n### 履行された`Promise`を返す - `Promise.resolve()`\n\n履行された`Promise`を返します。\n\n```ts twoslash\nconst promise: Promise<number> = Promise.resolve(4);\n```\n\n### 拒否された`Promise`を返す - `Promise.reject()`\n\n拒否された`Promise`を返します。\n\n```ts twoslash\nconst promise: Promise<string> = Promise.reject(new Error(\"failed\"));\n```\n\n### `Promise`を履行、拒否にかかわらずすべて待ち受ける - `Promise.allSettled()`\n\n第1引数に与えられたすべての`Promise`が決定される(settled)まで実行します。決定とは履行か拒否のことであり、ひとつでも拒否されると終了する`Promise.all()`と異なり、すべてが履行されるか拒否されるまで処理を待ちます。\n戻り値は判別可能なユニオン型として返ります。\n\n[判別可能なユニオン型](../../reference/values-types-variables/discriminated-union.md)\n\n`Promise.allSettled()`はES2020になって追加されました。\n\n```ts twoslash\nfunction request1(): Promise<number> {\n  return Promise.resolve(1);\n}\n\nfunction request2(): Promise<number> {\n  return Promise.reject(new Error(\"failed\"));\n}\n\nPromise.allSettled([request1(), request2()]).then((values) => {\n  console.log(values);\n  // @log: { status: \"fulfilled\", value: 1}, { status: \"rejected\", reason: {}}\n  // reason はエラーのオブジェクト\n});\n```\n\n### いちばん初めに決定された`Promise`を返す - `Promise.race()`\n\n`Promise.all()`のように第1引数に要素が`Promise`の配列を取り、それらをすべて非同期で実行しますが、その中のうちもっとも早く決定された`Promise`の結果を履行、拒否に関係なく返します。\n\n```ts twoslash\nfunction request1(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 4000);\n  });\n}\n\nfunction request2(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 2000);\n  });\n}\n\nfunction request3(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(3);\n    }, 1000);\n  });\n}\n\nPromise.race([request1(), request2(), request3()]).then((num) => {\n  console.log(num);\n  // @log: 3\n});\n```\n\n次の例は一番初めに決定される`Promise`が拒否される場合の例です。\n\n```ts twoslash\nfunction request1(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 4000);\n  });\n}\n\nfunction request2(): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 2000);\n  });\n}\n\nfunction request3(): Promise<number> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"failed\"));\n    }, 1000);\n  });\n}\n\nPromise.race([request1(), request2(), request3()])\n  .then((num) => {\n    console.log(num);\n  })\n  .catch((e) => {\n    console.log(e.message);\n    // @log: 'failed\n  });\n```\n\n## `Promise`ふかぼり\n\n### `Promise`の状態\n\n文章中にも何度も出てきましたが、`Promise`には３つの状態があります。\n\n- pending\n- fulfilled\n- rejected\n\npendingは待機中という意味で、まだ待ち受けている非同期処理が完了していないときの状態を示します。fulfilledは履行という意味で、待ち受けている非同期処理が完了し、意図している状態（例外が発生しなかった）になったことを示します。rejectedは拒否という意味で、待ち受けている非同期処理が例外とともに完了したことを示します。\nfulfilledとrejectedを合わせてsettledということがあります。このsettledは決定という意味です。\n",
      "url": "https://typescriptbook.jp/reference/asynchronous/promise"
    },
    {
      "title": "import、export、require",
      "content": "# import、export、require\n\n実務でアプリケーションを作る場合、複数のJavaScriptファイルを組み合わせて、ひとつのアプリケーションを成すことが多いです。いわゆるモジュール指向の開発です。ここではJavaScriptとTypeScriptでのモジュールと、モジュール同士を組み合わせるための`import`、`export`、`require`について説明します。\n\n## スクリプトとモジュール\n\nJavaScriptのファイルは大きく分けて、スクリプトとモジュールに分類されます。スクリプトは普通のJavaScriptファイルです。\n\n```js twoslash title=\"スクリプト\"\nconst foo = \"foo\";\n```\n\nモジュールは、`import`または`export`を1つ以上含むJavaScriptファイルを言います。`import`は他のモジュールから変数、関数、クラスなどインポートするキーワードです。`export`は他のモジュールに変数、関数、クラスなどを公開するためのキーワードです。\n\n```js twoslash title=\"モジュール\"\nexport const foo = \"foo\";\n```\n\nしたがって、`import`や`export`が無かったスクリプトファイルでも、後から`import`や`export`を追加すると、それはモジュールファイルになります。\n\n## 値の公開と非公開\n\nJavaScriptのモジュールは、明示的に`export`をつけた値だけが公開され、他のモジュールから参照できます。たとえば、次の例の`publicValue`は他のモジュールから利用できます。一方、`privateValue`は外部からは利用できません。\n\n```js twoslash\nexport const publicValue = 1;\nconst privateValue = 2;\n```\n\nJavaScriptのモジュールでは、デフォルトで変数や関数などは非公開になるわけです。Javaなどの他の言語では、モジュール(パッケージ)のメンバーがデフォルトで公開になり、非公開にしたいものには`private`修飾子をつける言語があります。そういった言語と比べると、JavaScriptは基本方針が真逆なので注意が必要です。\n\n## モジュールは常にstrict mode\n\nモジュールのJavaScriptは常にstrict modeになります。strict modeでは、さまざまな危険なコードの書き方が禁止されます。たとえば、未定義の変数への代入はエラーになります。\n\n```js twoslash\nfoo = 1; // 未定義の変数fooへの代入\n// @error: ReferenceError: foo is not defined\nexport const bar = foo;\n```\n\n## モジュールは`import`時に一度だけ評価される\n\nモジュールのコードが評価されるのは、1回目の`import`のときだけです。2回目以降の`import`では、最初に評価した内容が使われます。言い換えると、モジュールは初回`import`でキャッシュされるとも言えますし、モジュールはいわゆるシングルトン(singleton)的なものとも言えます。\n\nたとえば、`module.js`というモジュールを3回読み込んだとしても、この`module.js`が評価されるのは最初の1回目だけです。\n\n```js twoslash title=\"module.js\"\nconsole.log(\"モジュールを評価しています\");\n// このログが出力されるのは1回だけ\nexport const value = 1;\n```\n\n```js title=\"main.js\" twoslash\nimport \"./module.js\";\n// @log: \"モジュールを評価しています\"\nimport \"./module.js\";\nimport \"./module.js\";\n```\n\n## モジュールの歴史的経緯\n\n### かつてのJavaScript\n\nかつてJavaScriptがブラウザでのみ動いていた時代は、モジュール分割と言う考え自体はあったもののそれはあくまでもブラウザ上、さらには`html`での管理となっていました。よく使われていた`jQuery`というパッケージがあるとすれば、それは次のように`html`に書く必要がありました。\n\n```markup\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/x.y.z/jquery.min.js\"></script>\n```\n\nもし`jQuery`に依存するパッケージがあるとすれば、`jQuery`の宣言より下に書く必要があります。\n\n```markup\n<script src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/x.y.z/jquery-ui.min.js\"></script>\n```\n\nパッケージが少なければまだしも、増えてくると依存関係が複雑になります。もしも読み込む順番を間違えるとその`html`では動作しなくなるでしょう。\n\n### Node.jsが登場してから\n\n`npm`が登場してから、使いたいパッケージを持ってきてそのまま使うことが主流になりました。\n\n## `CommonJS`\n\n### `require()`\n\nNode.jsでは現在でも主流の他の`.js`ファイル(TypeScriptでは`.ts`も)を読み込む機能です。基本は次の構文です。\n\n```ts twoslash\nconst package1 = require(\"package1\");\n```\n\nこれは、パッケージの`package1`の内容を定数`package1`に持ってくることを意味しています。このとき`package1`は(組み込みライブラリでなければ)現在のプロジェクトの`node_modules`というディレクトリに存在する必要があります。\n\n自分で作った他の`.js, .ts`ファイルを読み込むこともできます。呼び出すファイルから見た、読み込みたいファイルの位置を**相対パス**で書きます。たとえ同じ階層にあっても相対パスで書く必要があります。このとき`.js, .json`とTypeScriptなら加えて`.ts`を省略することができます。TypeScriptでの開発においては最終的にJavaScriptにコンパイルされることを考慮すると書かないほうが無難です。\n\n```ts twoslash\nconst myPackage = require(\"./MyPackage\");\n```\n\n`.js`を`.ts`と同じ場所に出力するようにしているとTypeScriptにとって同じ名前の読み込ことができるファイルがふたつ存在することになります。このときTypeScriptは`.js`を優先して読み込むので注意してください。いくらTypeScriptのコードを変更しても変更が適用されていないようであればこの問題の可能性があります。\n\nまた指定したパスがディレクトリで、その中に`index.js(index.ts)`があれば、ディレクトリの名前まで書けば`index.js(index.ts)`を読み込んでくれます。\n\n### `module.exports`\n\n他のファイルを読む込むためにはそのファイルは何かを出力している必要があります。そのために使うのがこの構文です。\n\n```ts title=\"increment.js\" twoslash\n// @noErrors\nmodule.exports = (i) => i + 1;\n```\n\nこのような`.js`のファイルがあれば同じ階層で読み込みたい時は次のようになります。\n\n```ts title=\"index.js\" twoslash\n// @errors: 2580\nconst increment = require(\"./increment\");\n\nconsole.log(increment(3));\n// @log: 4\n```\n\nこのとき、読み込んだ内容を受ける定数`increment`はこの名前である必要はなく変更が可能です。\n\nこの`module.exports`はひとつのファイルでいくらでも書くことができますが、適用されるのは最後のもののみです。\n\n```ts title=\"dayOfWeek.js\" twoslash\nmodule.exports = \"Monday\";\nmodule.exports = \"Tuesday\";\nmodule.exports = \"Wednesday\";\nmodule.exports = \"Thursday\";\nmodule.exports = \"Friday\";\nmodule.exports = \"Saturday\";\nmodule.exports = \"Sunday\";\n```\n\n```ts title=\"index.js\" twoslash\nconst day = require(\"./dayOfWeek\");\n\nconsole.log(day);\n// @log: 'Sunday'\n```\n\n### `exports`\n\n`module.exports`だと良くも悪くも出力しているものの名前を変更できてしまいます。それを避けたい時はこの`exports`を使用します。\n\n```ts title=\"util.js\" twoslash\n// @noErrors\nexports.increment = (i) => i + 1;\n```\n\n読み込み側では次のようになります。\n\n```ts title=\"index.js\" twoslash\nconst util = require(\"./util\");\n\nconsole.log(util.increment(3));\n// @log: 4\n```\n\n分割代入を使うこともできます。\n\n```ts title=\"index.js\" twoslash\nconst { increment } = require(\"./util\");\n\nconsole.log(increment(3));\n// @log: 4\n```\n\nこちらは`increment`という名前で使用する必要があります。他のファイルに同じ名前のものがあり、名前を変更する必要がある時は、分割代入のときと同じように名前を変更することができます。\n\n```ts title=\"index.js\" twoslash\nconst { increment } = require(\"./other\");\nconst { increment: inc } = require(\"./util\");\n\nconsole.log(inc(3));\n// @log: 4\n```\n\n## `ES Module`\n\n主にフロントエンド(ブラウザ)で採用されているファイルの読み込み方法です。`ES6`で追加された機能のため、あまりにも古いブラウザでは動作しません。\n\n### `import`\n\n`require()`と同じく他の`.js, .ts`ファイルを読み込む機能ですが、`require()`はファイル内のどこにでも書くことができる一方で`import`は**必ずファイルの一番上に書く必要があります**。\nなお、書き方が2通りあります。\n\n```ts twoslash\n// @filename: package1\n// @filename: package2\n// ---cut---\nimport * as package1 from \"package1\";\nimport package2 from \"package2\";\n```\n\n使い方に若干差がありますので以下で説明します。\n\n### `export default`\n\n`module.exports`に対応するものです。`module.exports`と異なりひとつのファイルはひとつの`export default`しか許されていなく複数書くと動作しません。\n\n```ts title=\"increment.js\" twoslash\n// @noErrors\nexport default (i) => i + 1;\n```\n\nこの`.js`のファイルは次のようにして読み込みます。\n\n```ts title=\"index.js\" twoslash\n// @filename: increment.ts\nexport default (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport increment from \"./increment\";\n\nconsole.log(increment(3));\n// @log: 4\n```\n\n```ts title=\"index.js\" twoslash\n// @filename: increment.ts\nexport default (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport * as increment from \"./increment\";\n\nconsole.log(increment.default(3));\n// @log: 4\n```\n\n### `export`\n\n`exports`に相当するものです。書き方が2通りあります。\n\n```ts title=\"util.js\" twoslash\n// @noErrors\nexport const increment = (i) => i + 1;\n```\n\n```ts title=\"util.js\" twoslash\n// @noErrors\nconst increment = (i) => i + 1;\n\nexport { increment };\n```\n\nなお1番目の表記は定数宣言の`const`を使っていますが`let`を使っても読み込み側から定義されている`increment`を書き換えることはできません。\n\n次のようにして読み込みます。\n\n```ts title=\"index.js\" twoslash\n// @filename: util.ts\nexport const increment = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport { increment } from \"./util\";\n\nconsole.log(increment(3));\n// @log: 4\n```\n\n```ts title=\"index.js\" twoslash\n// @filename: util.ts\nexport const increment = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport * as util from \"./util\";\n\nconsole.log(util.increment(3));\n// @log: 4\n```\n\n1番目の場合の`import`で名前を変更するときは、`require`のとき(分割代入)と異なり`as`という表記を使って変更します。\n\n```ts title=\"index.js\" twoslash\n// @filename: util.ts\nexport const increment = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport { increment as inc } from \"./util\";\n\nconsole.log(inc(3));\n// @log: 4\n```\n\n### `import()`\n\n`ES Module`では`import`をファイルの先頭に書く必要があります。これは動的に読み込むファイルを切り替えられないことを意味します。この`import()`はその代替手段にあたります。\n\n`require()`と異なる点としては`import()`はモジュールの読み込みを非同期で行います。つまり`Promise`を返します。\n\n```ts title=\"index.js\" twoslash\n// @filename: util.ts\nexport const increment = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport(\"./util\").then(({ increment }) => {\n  console.log(increment(3));\n  // @log: 4\n});\n```\n\n## Node.jsで`ES Module`を使う\n\n先述のとおりNode.jsでは`CommonJS`が長く使われていますが、`13.2.0`でついに正式に`ES Module`もサポートされました。\n\nしかしながら、あくまでもNode.jsは`CommonJS`で動作することが前提なので`ES Module`を使いたい時はすこし準備が必要になります。\n\n### `.mjs`\n\n`ES Module`として動作させたいJavaScriptのファイルをすべて`.mjs`の拡張子に変更します。\n\n```ts title=\"increment.mjs\" twoslash\n// @noErrors\nexport const increment = (i) => i + 1;\n```\n\n読み込み側は以下です。\n\n```ts title=\"index.mjs\" twoslash\n// @filename: increment.mjs\nexport const increment = (i: number) => i + 1;\n// @filename: index.js\n// ---cut---\nimport { increment } from \"./increment.mjs\";\n\nconsole.log(increment(3));\n// @log: 4\n```\n\n`import`で使うファイルの**拡張子が省略できない**ことに注意してください。\n\n### `\"type\": \"module\"`\n\n`package.json`にこの記述を追加するとパッケージ全体が`ES Module`をサポートします。\n\n```json\n{\n  \"name\": \"YYTS\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"type\": \"module\",\n  \"license\": \"Apache-2.0\"\n}\n```\n\nこのようにすることで拡張子を`.mjs`に変更しなくてもそのまま`.js`で`ES Module`を使えるようになります。なお`\"type\": \"module\"`の省略時は`\"type\": \"commonjs\"`と指定されたとみなされます。これは今までどおりのNode.jsです。\n\n```ts title=\"increment.js\" twoslash\n// @noErrors\nexport const increment = (i) => i + 1;\n```\n\n```ts title=\"index.js\" twoslash\n// @filename: increment.js\nexport const increment = (i) => i + 1;\n// @filename: index.js\n// ---cut---\nimport { increment } from \"./increment.js\";\n\nconsole.log(increment(3));\n// @log: 4\n```\n\n`.js`ではありますが**読み込む時は拡張子を省略できなくなる**ことに注意してください。\n\n#### `.cjs`\n\n`CommonJS`で書かれたJavaScriptを読み込みたくなったときは`CommonJS`で書かれているファイルをすべて`.cjs`に変更する必要があります。\n\n```ts title=\"increment.cjs\" twoslash\n// @noErrors\nexports.increment = (i) => i + 1;\n```\n\n読み込み側は次のようになります。\n\n```ts title=\"index.js\" twoslash\nimport { createRequire } from \"module\";\nconst require = createRequire(import.meta.url);\n\nconst { increment } = require(\"./increment.cjs\");\n\nconsole.log(increment(3));\n// @log: 4\n```\n\n`ES Module`には`require()`がなく、一手間加えて作り出す必要があります。\n\n### `\"type\": \"module\"`の問題点\n\nすべてを`ES Module`として読み込むこの設定は、多くのパッケージがまだ`\"type\": \"module\"`に対応していない現状としては非常に使いづらいです。\n\nたとえば`linter`やテストといった各種開発補助のパッケージの設定ファイルを`.js`で書いていると動作しなくなってしまいます。かといってこれらを`.cjs`に書き換えても、パッケージが設定ファイルの読み込み規則に`.cjs`が含んでいなければそれらのパッケージは設定ファイルがないと見なします。そのため`\"type\": \"module\"`は現段階では扱いづらいものとなっています。\n\n## TypeScriptでは\n\nTypeScriptでは一般的に`ES Module`方式に則った記法で書きます。これは`CommonJS`を使用しないというわけではなく、コンパイル時の設定で`CommonJS, ES Module`のどちらにも対応した形式で出力できるのであまり問題はありません。ここまでの経緯などはTypeScriptでは意識することがあまりないでしょう。\n\nまた、執筆時(2021/01)ではTypeScriptのコンパイルは`.js`のみを出力でき`.cjs, .mjs`を出力する設定はありません。ブラウザでもサーバーでも使えるJavaScriptを出力したい場合は一手間加える必要があります。\n\n出力の方法に関してはtsconfig.jsonのページに説明がありますのでそちらをご覧ください。\n\n[tsconfig.jsonを設定する](./tsconfig/tsconfig.json-settings.md)\n\n## `require? import?`\n\nブラウザ用、サーバー用の用途で使い分けてください。ブラウザ用であれば`ES Module`を、サーバー用であれば`CommonJS`が無難な選択肢になります。どちらでも使えるユニバーサルなパッケージであればDual Packageを目指すのもよいでしょう。\n\n[デュアルパッケージ開発者のためのtsconfig (Dual Package)](advanced-topics/tsconfig-for-dual-package-developers.md)\n\n## `default export? named export?`\n\n`module.exports`と`export default`はdefault exportと呼ばれ、`exports`と`export`はnamed exportと呼ばれています。どちらも長所と短所があり、たびたび議論になる話題です。どちらか一方を使うように統一するコーディングガイドを持っている企業もあるようですが、どちらかが極端に多いというわけでもないので好みの範疇です。\n\n### default export\n\n#### default exportのPros\n\n- `import`する時に名前を変えることができる\n- そのファイルが他の`export`に比べ何をもっとも提供したいのかがわかる\n\n#### default exportのCons\n\n- エディター、IDEによっては入力補完が効きづらい\n- 再エクスポートの際に名前をつける必要がある\n\n### named export\n\n#### named exportのPros\n\n- エディター、IDEによる入力補完が効く\n- ひとつのファイルから複数`export`できる\n\n#### named exportのCons\n\n- (名前の変更はできるものの)基本的に決まった名前で`import`して使う必要がある\n- `export`しているファイルが名前を変更すると動作しなくなる\n\nここで挙がっている**名前を変えることができる**についてはいろいろな意見があります。\n\n### ファイルが提供したいもの\n\nたとえばある国の会計ソフトウェアを作っていたとして、その国の消費税が8%だったとします。そのときのあるファイルの`export`はこのようになっていました。\n\n```ts title=\"taxIncluded.ts\" twoslash\n// @noErrors\nexport default (price) => price * 1.08;\n```\n\nもちろん呼び出し側はそのまま使うことができます。\n\n```ts title=\"index.ts\" twoslash\n// @filename: taxIncluded.ts\nexport default (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport taxIncluded from \"./taxIncluded\";\n\nconsole.log(taxIncluded(100));\n// @log: 108\n```\n\nここで、ある国が消費税を10%に変更したとします。このときこのシステムでは`taxIncluded.ts`を変更すればこと足ります。\n\n```ts title=\"taxIncluded.ts\" twoslash\n// @noErrors\nexport default (price) => price * 1.1;\n```\n\nこの変更をこのファイル以外は知る必要がありませんし、知ることができません。\n\n### 今回の問題点\n\nシステムが**ある年月日当時の消税率**を元に金額の計算を多用するようなものだとこの暗黙の税率変更は問題になります。過去の金額もすべて現在の消費税率である10%で計算されてしまうからです。\n\n### named exportだと\n\nnamed exportであれば`export`する名称を変更することで呼び出し側の変更を強制させることができます。\n\n```ts title=\"taxIncluded.ts\" twoslash\n// @noErrors\nexport const taxIncludedAsOf2014 = (price) => price * 1.08;\n```\n\n```ts title=\"index.ts\" twoslash\n// @filename: taxIncluded.ts\nexport const taxIncludedAsOf2014 = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport { taxIncludedAsOf2014 } from \"./taxIncluded\";\n\nconsole.log(taxIncludedAsOf2014(100));\n// @log: 108\n```\n\n税率が10%に変われば次のようにします。\n\n```ts title=\"taxIncluded.ts\" twoslash\n// @noErrors\nexport const taxIncludedAsOf2019 = (price) => price * 1.1;\n```\n\n```ts title=\"index.ts\" twoslash\n// @filename: taxIncluded.ts\nexport const taxIncludedAsOf2019 = (i: number) => i + 1;\n// @filename: index.ts\n// ---cut---\nimport { taxIncludedAsOf2019 } from \"./taxIncluded\";\n\n// this is no longer available.\n// console.log(taxIncludedAsOf2014(100));\nconsole.log(taxIncludedAsOf2019(100));\n// @log: 110\n```\n\n名前を変更したため、呼び出し元も名前の変更が強制されます。これはたとえ`as`を使って名前を変更していたとしても同じく変更する必要があります。\n\nロジックが変わったこととそれによる修正を強制したいのであればnamed exportを使う方がわかりやすく、そしてエディター、IDEを通して見つけやすくなる利点があります。逆に、公開するパッケージのようにAPIが一貫して明瞭ならばdefault exportも価値があります。\n",
      "url": "https://typescriptbook.jp/reference/import-export-require"
    },
    {
      "title": "型定義ファイル (.d.ts)",
      "content": "---\nsidebar_label: 型定義ファイル\n---\n\n# 型定義ファイル (.d.ts)\n\n自身のプロジェクトでTypeScriptでコーディングする場合は型を宣言することにより、IDEやエディターの補完機能やコードチェックを行えます。しかし外部のパッケージ(npm)を利用する場合は型定義ファイルが含まれているとは限りません。\n\n## 型定義ファイルとは\n\n型定義ファイルとはアクセス可能な宣言を記述したファイルです。拡張子は`.d.ts`です。\n\n型定義ファイルは主にパッケージを配布するために作成されます。TypeScriptはJavaScriptにコンパイルされるときに型情報は無くなってしまいます。そのままJavaScriptパッケージを利用すると型定義の恩恵を得ることができません。しかし型定義ファイルを同梱することにより補完やコードチェックとして利用することができます。\n\n残念なことにnpmに公開されているすべてのパッケージに必ずしも定義ファイルが存在するとは限りません。こちらに関しては**型定義ファイルの有無**にて説明します。\n\n### 型定義ファイル出力例\n\ntscコマンドに`-d`オプションをつけてコンパイルを行うとJavaScriptと型定義ファイルを出力することができます。\n\n#### TypeScriptファイル\n\n次のTypeScriptファイル(sample.ts)を`-d`オプションを付けてコンパイルしてみます。\n\n```ts title=\"sample.ts\" twoslash\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n\nfunction greeter(person: Person): string {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n```\n\ntscコマンドに`-d`オプションを付けコンパイルを実行する。\n\n```bash\ntsc -d\n```\n\n#### JavaScriptファイル\n\nsample.tsではInterfaceを使っていますが、JavaScriptにはInterfaceの概念がないため関数のみになりました。また引数の型情報もなくなります。\n\n```js title=\"sample.js\" twoslash\nfunction greeter(person) {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n//# sourceMappingURL=sample.js.map\n```\n\n#### `d.ts`ファイル\n\n定義情報のみ記載されたファイルが出力されます。\n\n```ts title=\"sample.d.ts\" twoslash\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\ndeclare function greeter(person: Person): string;\n```\n\n## 型定義ファイルの有無\n\n型定義ファイルはパッケージ開発者またはボランティアにより作成されています。\n\n- 型定義ファイル有り\n  - TypeScriptで書かれたパッケージ\n  - JavaScriptで書かれたパッケージだが`.d.ts`ファイルを同梱している\n- 型定義ファイル有りだが別途インストールが必要\n  - JavaScriptで書かれたパッケージだが、 DefinitelyTypedに登録されている\n- 型定義ファイル無し\n  - JavaScriptで書かれたパッケージで型定義ファイルが存在しない\n\n### 型定義ファイル有り\n\nNPMのパッケージの紹介ページを見るとパッケージ名称の右にTSのアイコンが表示されている場合があります。これは型定義ファイルが存在することを示しています。\nこれは、パッケージ開発者がTypeScriptで開発しているか、JavaScriptで開発しているが型定義ファイルを同梱していることを示しています。型定義ファイルが含まれているパッケージの場合は特別な作業は必要ありません。\n\n例としてdate libraryの[date-fns](https://date-fns.org/)はJavaScriptで構築されていますが、`typings.d.ts`を同封しています。そのままinstallを行うだけで定義ファイルの恩恵を受けられます。\n\n```bash\nnpm install date-fns\n```\n\n型定義ファイル有りの場合は、設定なく型情報を参照することができます。\n\n### 型定義ファイル有りだが別途インストールが必要\n\nNPMのパッケージの紹介ページを見るとパッケージ名称の右にDTのアイコンが表示されている場合があります。これは型定義ファイルがこのパッケージ自身には含まれていないが、[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)に登録されていることを示しています。\nこの場合は、パッケージをインストールした後に別途型定義ファイルをインストールする必要があります。定義ファイルのインストールも`npm`コマンドを利用します。\n\n例として[Express](https://expressjs.com/)はJavaScriptで構築されていますが、型定義ファイルは`@types/express`というパッケージとして別途インストールする必要があります。\n\n[Express](https://expressjs.com/)本体と定義ファイルのインストール例は次のようになります。\n\n```bash\nnpm install express --save # express本体のインストール\nnpm install @types/express --save-dev # 型定義ファイルのインストール\n```\n\n### 型定義ファイル無し\n\n型定義ファイルがないライブラリも存在します。その場合は\n\n1. `any`で妥協する\n2. 型定義ファイルを作る\n\n型定義ファイルの存在しないライブラリも利用することが可能ですが暗黙的に`any`型になります。また自身で作成しDefinitelyTypedに公開することもできます。\n\n[コントリビュート（貢献）する方法 | Definitely Typed](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/README.ja.md#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%83%88%E8%B2%A2%E7%8C%AE%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95)\n\n## 型定義ファイルで登場するキーワード\n\nここでは型定義ファイルを読めるようになるために、型定義ファイルでよく利用されるキーワードを紹介します。\n\n### declare\n\n`declare`キーワードを使うことでTypeScriptに変数、関数、クラスなどがJavaScript内に「存在する」ことを伝えることができます。これを「アンビエント宣言」と呼びます。\n\n次のファイルがJavaScriptライブラリとして読み込まれており、グローバル関数として`hello`が使える状態だとします。\n\n```js twoslash\nfunction hello(name) {\n  return \"Hello, \" + name;\n}\n```\n\nこの状態でTypeScriptで`hello`関数を呼び出すと型エラーが発生します。これは、TypeScriptが`hello`関数が存在することを知らないためです。\n\n```ts twoslash\n// @errors: 2304\nhello(\"taro\");\n```\n\n`declare`を利用してアンビエント宣言をすることで、TypeScriptにJavaScript内のどこかに`hello`関数が「存在する」ことを宣言することができます。これによりTypeScriptが`hello`関数を認識できるようになります。\n\n```ts twoslash\ndeclare function hello(name: string): string;\n\nhello(\"taro\");\n// @log: \"hello, taro\"\n```\n\n実際のモジュールの型定義ファイルの例として`jest`の型定義ファイルを見てみましょう。`beforeAll`などの関数が型定義ファイル内でアンビエント宣言されているのが確認できます。これによりモジュールの読み込みをしなくても、TypeScriptが`beforeAll`を関数として認識することができます。\n\n```ts title=\"node_modules/@types/jest/index.d.ts\" twoslash\n// @noErrors\ndeclare var beforeAll: jest.Lifecycle;\n\ndeclare namespace jest {\n  type Lifecycle = (fn: ProvidesHookCallback, timeout?: number) => any;\n}\n```\n\n### namespace\n\n`namespace`キーワードを使うことで名前空間を定義することができます。\n名前空間を定義することで、型名の衝突を避けることができます。\n\n`Element`という型をライブラリの型として定義してライブラリ利用者が参照できるようにしたいと考えみます。この型はTypeScriptの`lib.dom.d.ts`にすでに定義されているため、そのまま同じグローバルな空間に定義をすると名前が衝突してしまいます。\n\n```ts title=\"node_modules/typescript/lib/lib.dom.d.ts\" twoslash\ninterface Element\n  extends Node,\n    ARIAMixin,\n    Animatable,\n    ChildNode,\n    InnerHTML,\n    NonDocumentTypeChildNode,\n    ParentNode,\n    Slottable {\n  readonly attributes: NamedNodeMap;\n  /** Allows for manipulation of element's class content attribute as a set of whitespace-separated tokens through a DOMTokenList object. */\n  readonly classList: DOMTokenList;\n\n  // 省略\n}\n```\n\n次のコードは`namespace`を使わずにライブラリ独自の型として`Element`を定義している例です。TypeScriptでは同じインターフェースが定義された場合は宣言のマージが発生するため、`lib.dom.d.ts`で定義されている型とマージされるため、`attributes`プロパティなど複数プロパティの指定を求められてしまいます。\n\n```ts twoslash\n// hello.d.ts\n// @showEmittedFile: index.d.ts\ninterface Element {\n  id: string;\n}\n\n// index.ts\n// @errors: 2740\nconst e: Element = {\n  id: \"1\",\n};\n```\n\n名前空間を定義することで衝突を避けてライブラリ独自の型を定義をすることができます。\n\n```ts twoslash\n// @filename: hello.d.ts\nnamespace Hello {\n  interface Element {\n    id: number;\n  }\n}\n\n// @filename: index.ts\n// @errors: 2740\nconst e: Hello.Element = {\n  id: 1,\n};\n```\n\nReactの型定義ファイルでは、次のように`namespace JSX`で名前空間が定義されて`Element`の型が定義がされています。\n\n`declare global` と `declare namespace`の違いについて\n型定義ファイルでは同じ振る舞いをするため違いはない。`declare global`と記述をすることで、グローバルスコープに名前空間を定義するということを開発者の意図として明示できる？\n\n```ts twoslash\n// @filename: node_modules/@types/react/index.d.ts\ndeclare global {\n  namespace JSX {\n    interface Element extends React.ReactElement<any, any> {}\n\n    // 省略\n  }\n}\n```\n\n### module\n\nTypeScript1.5以前では、`module`キーワードが「内部モジュール（名前空間）」を定義するために使用されていました。これは現在の`namespace`の機能と同等です。しかし、この名前がESModuleの「外部モジュール」の定義とキーワード名が重複し、混乱を招いてしまう可能性があったため、TypeScript1.5から「内部モジュール」は「名前空間」と呼ばれるように変更され、`namespace`キーワードが新たに導入されました。\n\n現在では、`module`キーワードは非推奨となっているため、`namespace`キーワードの使用をするようにしてください。\n\n### トリプルスラッシュ・ディレクティブ\n\n型定義ファイルの先頭で見かける3つのスラッシュ(`///`)ではじめるコメント行をトリプルスラッシュ・ディレクティブと呼びます。これは、TypeScript独自の形式でコンパイラに対して指示を出す機能を持っています。\n\nトリプルスラッシュ・ディレクティブにはいくつかの種類が存在しており、ここでは多くの型定義ファイルで目にする代表的なディレクティブを2つ紹介します。\n\n#### `/// <reference path=\"...\" />` (参照ディレクティブ)\n\n参照ディレクティブはコンパイラに型定義ファイル間の依存関係を宣言でき、`path`で指定された型定義ファイルを追加でコンパイル時に読み込むように指示を与えることができます。たとえば、次の例では`index.d.ts`をコンパイラが読み込む際に追加で`global.d.ts`を読み込みます。\n\n```ts title=\"node_modules/@types/react/index.d.ts\" twoslash\n// @noErrors\n/// <reference path=\"global.d.ts\" />\n```\n\n#### `/// <reference types=\"...\" />` (型ディレクティブ)\n\n型ディレクティブはnpmパッケージへの依存関係を宣言できます。宣言されたパッケージの依存を解決する処理はimport文でのパッケージの解決と似た処理のため、型ディレクティブは型のimportのようなものとも考えられます。\n\n次の例はexpressの型定義ファイルの一部です。型ディレクティブで`serve-static`パッケージの型定義ファイルに依存していることが示されています。\n\n```ts title=\"node_modules/@types/express/index.d.ts\" twoslash\n// @noErrors\n/// <reference types=\"express-serve-static-core\" />\n/// <reference types=\"serve-static\" />\n```\n",
      "url": "https://typescriptbook.jp/reference/declaration-file"
    },
    {
      "title": "🚧モジュール",
      "content": "# 🚧モジュール\n\n:::caution\n**Experimental!** このページは執筆途中の草稿です。構成が大きく変わることがありえますので、リンクなどをする場合はリンク切れが起こる可能性がある点をご留意ください。このページの内容は、[import、export、require](./import-export-require.md)をもとに再構成・加筆しています。\n:::\n\n## モジュールの基礎\n\n### モジュールの目的\n\nプログラムは大きさがさまざまです。行数で見ると、数行のものから数万行のものまであります。\n\n小さいプログラムなら、1つのファイルでも十分ですが、大きなプログラムは1つのファイルだけで作るのは大変です。\n\n想像してみてください。何千行もあるプログラムが1つのファイルに詰め込まれている状態は、読みにくく、修正もしにくくなります。\n\n1. **保守性の問題** ─ 保守性が低いことです。大量のコードが1つのファイルに詰め込まれているため、変更がしにくいです。コードの見通しが悪いため、1行の変更が他の数千行にどのような影響を与えるのか、予想もつかないことがあります。これは、変更に対して臆病になってしまう原因にもなります。\n2. **変数名の衝突** ─ コードが長いと、変数名が衝突する危険性が高まります。これにより、関係のない変数を上書きしてしまう恐れがあります。これを避けるために変数名を長くすることもありますが、それは可読性を損ねる原因になります。\n3. **再利用の問題** ─ たとえば、数千行のコードの中から特定の部分だけを別のプロジェクトで使用したい場合、それらが1つの大きな塊にまとめられているため、必要な部分だけを抜き出せません。無理に読み込むと、不要なコードも一緒に読み込んでしまい、それがどう悪さをするかは予想がつきません。\n\nこのような問題を解決するのが、**モジュール**(module)と呼ばれる仕組みです。モジュールは1つのファイルを複数のファイルに分割し、関連付けて、ひとつのプログラムとして動かすことができます。\n\n大規模なプログラムを作る場合、それぞれの機能ごとにモジュールを分けることで、各モジュールを読みやすく、保守性も高く、再利用もしやすくなります。\n\n### JavaScriptのモジュール\n\nJavaScriptのモジュールは、`export`または`import`を1つ以上含むJavaScriptファイルを言います。\n\n- `export`は他のモジュールに変数を公開するためのキーワードです。\n- `import`は他のモジュールから変数をインポートするキーワードです。\n\n`export`と`import`を使うと、モジュール間で変数を受け渡しできるようになります。\n\nたとえば、次は変数`world`をエクスポートしているモジュールです。\n\n```ts twoslash title=\"world.js\"\nexport const world = \"World\";\n```\n\n別のファイルでこれをインポートして使います。\n\n```ts twoslash title=\"hello.js\"\n// @filename: world.js\nexport const world = \"World\";\n// @filename: hello.js\n// ---cut---\nimport { world } from \"./world\";\nconsole.log(`Hello ${world}`);\n// @log: Hello World\n```\n\n### 値の公開と非公開\n\nJavaScriptのモジュールは、明示的に`export`をつけた値だけが公開され、他のモジュールから参照できます。たとえば、次の例の`publicValue`は他のモジュールから利用できます。一方、`privateValue`は外部からは利用できません。\n\n```js twoslash\nexport const publicValue = 1;\nconst privateValue = 2;\n```\n\nJavaScriptのモジュールでは、デフォルトで変数や関数などは非公開になるわけです。Javaなどの他の言語では、モジュール(パッケージ)のメンバーがデフォルトで公開になり、非公開にしたいものには`private`修飾子をつける言語があります。そういった言語と比べると、JavaScriptは基本方針が真逆なので注意が必要です。\n\n### パッケージとモジュールの違い\n\nモジュールと似た用語に、パッケージ(package)という言葉があります。プログラミング言語によって、モジュールとパッケージの定義は異なります。JavaScriptでは、これらはどのように捉えられているでしょうか。\n\nモジュールは、基本的にひとつひとつのJavaScript/TypeScriptファイルを指します。詳細は「[スクリプトとモジュール](https://typescriptbook.jp/reference/import-export-require#%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB)」のセクションで説明しますが、JavaScript/TypeScriptファイルのうち、`export`または`import`を1つ以上含んだものがモジュールに当たります。\n\nパッケージは、package.jsonとJavaScriptファイル群を持つディレクトリを指します。package.jsonは、パッケージの名前、バージョン、ライセンスなどのメタデータを記載したファイルです。\n\nモジュールとパッケージには、利用用途の違いがあります。一般的なアプリケーション開発では、複数のJavaScript/TypeScriptファイルに分けて開発します。この際に作られるファイルひとつひとつがモジュールになります。アプリケーションの保守性の担保、コードの再利用性の確保、変数名衝突の回避のために用いられるのがモジュールです。\n\n一方、パッケージの典型的な目的は配布です。ライブラリ製作者が、プログラムを他者に配布する際に用いられるのがパッケージです。そして、アプリケーション開発者は、自己のアプリケーションにパッケージを組み込む形で、パッケージは利用されていきます。\n\n## モジュールとエコシステム\n\n### バンドラー\n\nJavaScriptでは、複数のJavaScriptファイルを1つのファイルに繋ぎ合わせることをバンドル(bundle)と言います。バンドルを、自動的に行なう開発ツールを、バンドラー(bundler)と呼びます。バンドラーは「モジュールバンドラー」と呼ばれることもあります。\n\nJavaScriptには、さまざまなバンドラーがあります。たとえば、有名なものとしては次のようなバンドラーがあります。\n\n- webpack\n- rollup\n- parcel\n- esbuild\n- vite\n\nこれらのバンドラーは、JavaScriptだけではなく、TypeScriptやCSS、画像などさまざまな種類のファイルをバンドルできます。\n\n#### バンドラーが必要な理由\n\nJavaScriptのバンドラーを使わないと、Webアプリケーションを実行するために、複数のJavaScriptファイルを個別に読み込む必要があります。これは、いくつかの問題を生みます。\n\n第一に、ウェブブラウザーがJavaScriptのコードを読み込む際に、多くの時間がかかるようになります。\n\n第二に、JavaScriptファイル同士の依存関係が整理されないことに起因して、コードが壊れ、バグが起こることがあります。\n\n第三に、JavaScriptコードが最適化された書き方になっていない場合、アプリケーションの実行パフォーマンスが悪くなることがあります。\n\nこのような問題を解決するがバンドラーの役割です。\n\n#### サーバーサイドJSではバンドラーの利点は少ない\n\nJavaScriptはウェブブラウザーで実行するために作られた言語ですが、サーバーサイドでも使えます。サーバーサイドのJavaScript実行環境のひとつにNode.jsがあります。Node.jsは、古くからモジュールシステムを内部で実装しているため、JavaScriptにESモジュールのようなモジュールシステムがまだ無い時代から、モジュールが使えていました。そのため、サーバーサイドJavaScriptの環境では、バンドラーの必要性が生まれませんでした。\n\n昨今のJavaScriptはモジュールシステムを持っているため、バンドラーを使わなくともモジュールを実現できます。これはフロントエンドでも同様です。しかしながら、フロントエンドでは数百、数千のモジュールをバラバラにダウンロードして実行するのは時間がかかるため、ひとつのJavaScriptファイルにまとめるバンドラーの役割というのは、依然として重要です。\n\n一方で、サーバーサイドでは、モジュールが数百、数千とあったとしても、モジュールをロードするのはサーバー起動時だけです。そのため、バンドラーの利点はほぼありません。\n\n## モジュールシステム\n\n### CommonJSとESモジュール\n\n### CommonJSとESモジュールが混在している理由\n\nこれをお読みの皆さんの中には、JavaScriptやTypeScript以外のプログラミング言語を経験したことがある人もいるかと思います。他の言語で、複数のモジュールシステムが共存している言語を使ったことはありますでしょうか。\n\nJavaScriptには、系統が異なるモジュールシステムが、少なくとも2つ存在しています。ESモジュールとCommonJSです。こうした状況は、プログラミング言語としては、珍しいことです。JavaScriptのモジュールまわりを理解するのを難しくしている要因でもあります。\n\nでは、どうしてJavaScriptは2系統もモジュールシステムを持つようになったのでしょうか？ ここでは、JavaScriptの現状に至る流れを歴史からひも解いていきます。\n\n#### ひとつめのモジュールシステム\n\nJavaScriptのモジュールシステムは、ブラウザよりも先んじて、サーバーサイドJavaScript、とりわけNode.jsの文脈で発展してきた経緯があります。\n\nJavaScriptで広く普及しているモジュールシステムのひとつがCommonJSです。CommonJSの歴史をさかのぼると、2009年のServerJS発足に至ります。ServerJSはJavaScriptをサーバーサイドで使えるようにすることを目指し、サーバーサイドJavaScriptの共通APIを策定する標準化プロジェクトでした。のちに、CommonJSに改名されます。\n\nサーバーサイドにJavaScriptを持ってくると一言で言っても、ブラウザのJavaScriptをそのまま持ち込んでもうまくいきません。たとえば、ブラウザには`<script>`タグがあるので、ひとつのページに複数の`<script>`タグを書くことで、複数のJavaScriptが実行できます。一方、サーバーサイドにはページという概念がありません。\n\nまた、当時のJavaScriptにはESモジュールのようなモジュールシステムもありませんでした。そのため、JavaScriptファイルを複数ロードできる仕組みを考えるところから始めなければなりませんでした。\n\nそこで考え出された仕様がCommonJSのモジュールです。おなじみの`require()`や`module.exports`です。CommonJSは、モジュールシステムが存在しない当時のJavaScriptの文法や機能の枠を超えずに、関数や変数で工夫することで、モジュール的なものを成立させるものでした。\n\nNode.jsはCommonJSと同時期にリリースされましたが、Node.jsに採用されたモジュールシステムがこのCommonJSでした。このおかげで、Node.jsにおいてはサーバーサイドJavaScriptでもファイルの分割と、複数ファイルのロードができるようになっていました。このモジュールシステムは、Node.jsユーザーに受け入れられはじめ、ライブラリを公開できるnpmなど、モジュールまわりのエコシステムも発展していきました。\n\nちなみに、CommonJSやNode.jsがスタートした2009年の前年には、ECMAScript 4草案破棄というショッキングな出来ごとがありました。ES4には、モジュールシステムをJavaScriptに追加する仕様も盛り込まれていました。もし、ES4が実現していたら、CommonJSは必要無かったかも知れません。現実はESの仕様を決めるブラウザベンダー間での意見と対立があり、JavaScriptを改善する動きは仲たがいで終わってしまいました。\n\nNode.jsの登場時期がそんなバッドタイミングだったこともあり、JavaScript自体がモジュールシステムを改善するのはなかなか期待できない状況でした。そのため、Node.jsは既存のJavaScriptでできる範囲内の解決策として、モジュールシステムにCommonJSを採用したという見方もできます。\n\nCommonJSはサーバーサイドで生まれ、発展してきました。CommonJSの土台に乗ったライブラリも数多く作られました。こうしたライブラリは、クライアントサイドでも需要がありました。そのため、webpackを筆頭にモジュールバンドラーはCommonJSをサポートしてきました。CommonJSの生い立ちはサーバーサイドではあったものの、モジュールバンドラーの対応によって、フロントエンドもCommonJSに頼る状況が醸成されました。\n\n#### ふたつめのモジュールシステム\n\nCommonJSの誕生から歴史は流れ、2015年になると、ES6という新しいJavaScriptの標準仕様が確定します。これはJavaScriptの10年数ぶりの大型アップデートです。そこには、ES6 Modulesというモジュールシステムを実現するための仕様も盛り込まれていました。皆さんご存知の`import`文と`export`文です。これは、JavaScript初のJavaScriptネイティブのモジュールシステムです。CommonJSが草の根活動で規格化されたモジュールシステムだとすると、ESモジュールは本家が発表した公式的・標準的なモジュールシステムだとも言えます。\n\nJavaScript界は、サーバーサイドもクライアントサイドも関係なく、ES6に対応する中で、ES6 Modulesも導入する方向になり、2016年頃からESモジュール導入に向けて議論が始まりました。議論の中心は、やはり、在来のモジュールシステムであるCommonJSと新システムのESモジュールの共存についてです。\n\nESモジュールの仕様が確定する頃には、JavaScriptはCommonJS前提とした環境ができあがっていて、CommonJSに準拠したNPMパッケージも沢山あったため、CommonJSを切り捨てる選択肢はありませんでした。もしも、CommonJSを切り捨ててしまうと、過去の資産をほぼすべて失うことになるわけで、CommonJSとESモジュールの共存はNode.jsにとって重要なテーマだったのです。\n\nたとえば、サーバーサイドJavaScriptのNode.jsひとつとっても、長い議論のすえ、2017年にNode.js v8.5.0にて、ESモジュールが実験的な機能としてリリースされます。その後、2019年にv13.2.0にて、ESモジュールから「実験的な機能」というラベルが外れ、プロダクションで使われることを想定した機能に昇格しました。そして2020年には、CommonJSの名前付きエクスポートがESモジュールの名前付きインポートでロードできるようになり、次第にNode.jsでESモジュールを動かす環境が整ってきています。\n\nESモジュール環境が整備されてきたとは言っても、CommonJSは10年以上、JavaScriptを支えてきており、もはや切っても切れない関係になっています。そのため、今日現在においては、2つのモジュールシステムがJavaScriptに生きているわけです。\n\n#### まとめ\n\n- JavaScriptにはCommonJSとESモジュールの2つのモジュールシステムがある。\n- CommonJSはJSと10年以上に及ぶ長く深いつながりがある。\n- JS界はCommonJSとESモジュールが共存する道を選んだ。\n\n### CommonJSとESモジュールの違い\n\n#### `import`と`require`の違い\n\nJavaScriptでは、モジュールから変数などの値をインポートする際に、`import`と`require`を用います。この2つはよく似ていますが、それぞれ異なるモジュールシステムの書き方です。\n\nJavaScriptのモジュールシステムはいくつかありますが、代表的なものが次の2つです。\n\n- ESモジュール\n- CommonJS\n\nこの2つのモジュールシステムの違いの詳細は、**(TODO参照先記事記載)** で解説していますので、そちらをご覧ください。\n\n##### import\n\n`import`は、JavaScriptのモジュールシステムのひとつであるESモジュールで用いる構文です。`import`は他のモジュールでエクスポートされた変数や関数をインポートするのに用いられます。たとえば、次のような使い方ができます。\n\n```js\nimport { myVariable, myFunction } from \"./myModule\";\n```\n\n##### require\n\n一方で、`require`は、CommonJSというモジュールシステムで用いる関数です。`require`関数は、他のモジュールから変数や関数をインポートするのに使われます。たとえば、次のような使い方になります。\n\n```js\nconst { myVariable, myFunction } = require(\"./myModule\");\n```\n\n#### `export`と`module.exports`の違い\n\n`import`と`require`は、他のモジュールから値をインポートするためのものでした。これと対をなすものとして、`export`と`module.export`があります。これらは、他のモジュールに値をエクスポートするためのものです。`export`と`module.export`も、それぞれ異なるモジュールシステムで使われます。\n\n##### export\n\nJavaScriptの`export`は、ESモジュールというモジュールシステムで用いる構文です。`export`を使うと、モジュール内で定義した変数や関数などを、エクスポートすることができます。たとえば、次のような使い方ができます。\n\n```js\nexport const myVariable = \"foo\";\nexport const myFunction = () => {\n  /* 関数の処理 */\n};\n```\n\n##### module.exports\n\n一方で、`module.exports`は、CommonJSというモジュールシステムで用いる変数です。CommonJSでは、モジュール内で定義された変数や関数を、`module.exports`に代入することで、エクスポートできます。たとえば、次のような書き方になります。\n\n```js\nmodule.exports.myVariable = \"foo\";\nmodule.exports.myFunction = () => {\n  /* 関数の処理 */\n};\n```\n\n## ESモジュールの構文\n\n## モジュール解決\n\n## ESモジュールの仕様\n\n## CommonJSのAPI\n\n## TypeScriptとモジュール\n\n## ESモジュールのベストプラクティス\n",
      "url": "https://typescriptbook.jp/reference/modules"
    },
    {
      "title": "文字列リテラル",
      "content": "---\nsidebar_label: string型\ntitle: string型 (文字列型)\n---\n\n## 文字列リテラル\n\n<!-- textlint-disable prh -->\n\nJavaなどの言語では、ダブルクォートで文字列リテラル(String型)を表現し、シングルクォートで文字リテラル(char型)を表現するといったように、使うクォートで型が変わります。\n\n<!-- textlint-enable prh -->\n\n一方JavaScriptでは、ダブルクォートでもシングルクォートでもまったく同じstring型になります。この点はPHPと同様です。またバッククォート(`` ` ``)を使ってもstring型になります。\n\n<!--prettier-ignore-->\n```ts twoslash\n\"Hello\"; \n'Hello'; \n`Hello`;\n```\n\n文字列中に同じ引用符が含まれている場合は、バックスラッシュ`\\`でエスケープしなければなりません。\n\n<!--prettier-ignore-->\n```ts twoslash\n'He said \"madam, I\\'m Adam.\"'\n\"He said \\\"madam, I'm Adam.\\\"\"\n```\n\nダブルクォートとシングルクォートを使った文字列リテラルは、文字列の途中で改行できません。改行を入れたい場合は、`\\n`などの改行シーケンスを入れる必要があります。\n\n### テンプレートリテラル\n\nJavaScriptで、バッククォート`` ` ``で囲んだ文字列はテンプレートリテラル（template literal）と言います。テンプレートリテラルは、改行と式の挿入(expression interpolation)ができます。\n\n改行の挿入はテンプレートリテラルの中で実際に改行をすれば、そのとおりに反映されます。\n\n```ts twoslash\nconsole.log(`実際に改行を\nしてみる`);\n// @log: 実際に改行を<br />してみる\n```\n\n式の挿入は`${式}`のように書きます。\n\n```ts twoslash\nconst count = 10;\nconsole.log(`現在、${count}名が見ています。`);\n// @log: 現在、10名が見ています。\n```\n\n式の部分は変数だけでなく、計算式や関数を使った式も書けます。\n\n<!--prettier-ignore-->\n```ts twoslash\n`税込み${Math.floor(100 * 1.1)}円`\n```\n\n### 文字列リテラルは`'`、`\"`、`` ` ``のどれを使うべきか？\n\n前述のとおりJavaScriptでは文字列を表すときに3種類のクォートがありますが、どれを使えばいいのでしょうか。ここではJavaScriptのコードフォーマッターであるPrettierに倣い使い分けを紹介します。\nなおこれは正解でもなければデファクトスタンダードというわけでもないので開発チームの基準があるならばそちらに従うことが望ましいです。\n\n1. 基本的に`\"`を使用する\n1. 文字列の中に`\"`が含まれる場合は`'`を使用する\n1. 文字列展開する必要があるときは`` ` ``を使用する\n\n#### 基本的に`\"`を使用する\n\nただの文字列で内部で変数展開をしていないのであれば`\"`を使用します。\n\n#### 文字列の中に`\"`が含まれる場合は`'`を使用する\n\n文字列の中に`\"`が含まれる場合はエスケープするのではなく`'`を使用します。\n\n#### 文字列展開する必要があるときは`` ` ``を使用する\n\n式を計算する必要があるときはテンプレートリテラル`` ` ``を使用します。\n\n## 文字列の型注釈\n\nTypeScriptのstring型の型注釈は`string`を用います。\n\n```ts twoslash\nconst message: string = \"Hello\";\n```\n\n名前がよく似た型に`String`型がありますが、`string`とは異なるので注意してください。\n\n## 文字列結合\n\nJavaScriptの文字列結合は文字列結合演算子(`+`)を用います。number型の加算でも同じ演算子が使われます。\n\n<!--prettier-ignore-->\n```ts twoslash\n\"hello\" + \"world\"\n```\n\nPHPでは文字列結合演算子(`.`)と、数値の加算演算子(`+`)の2つに分かれていますが、JavaScriptでは文字列結合と加算は同じプラス記号で表現するので、PHPからJavaScriptに来た人は注意してください。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/string"
    },
    {
      "title": "truthyな値、falsyな値",
      "content": "---\nsidebar_label: truthyな値、falsyな値\n---\n\n# truthyな値、falsyな値\n\n## 特定の条件で処理を変えたい\n\nどのような言語でも、ある条件のときは別の処理をさせたいということがあります。むしろ、ない言語はないでしょう。当然、JavaScriptでもそのような機能はあり、`if`を使います。\n\n```ts twoslash\nclass Employee {\n  isPartTime(): boolean {\n    return false;\n  }\n}\n\nconst employee = new Employee();\n\n// ---cut---\nif (employee.isPartTime()) {\n  // ...\n}\n```\n\nこのときメソッドの`isPartTime()`は真偽値、つまりboolean型を返すとは誰もが見てもそう思います。\n\n## JavaScriptでは、真偽値でなくてもifの対象にできる\n\nところが、JavaScriptではその限りではありません。JavaScriptではその値(や演算結果)がboolean型である必要はありません。では、どのような値の場合は`if`ブロックを実行し、逆に実行しないのでしょうか。\n\n## true, false「のような」値\n\nこのようなとき、条件を満たすとされる値のことをtruthyと、また満たさないとされる値のことをfalsyと呼びます。これは英語の真と偽を意味するtruthとfalseにそれぞれ「のような」というニュアンスを表す接尾語のyをつけたものです。\n\n## falsyな値\n\nfalsyな値から説明します。というのはfalsyな値というのは限られており、それ以外のすべての値がtruthyとなるのでこれだけ覚えてしまえばいいということでもあります。\n\n| 値        | 型        | 意味         |\n| --------- | --------- | ------------ |\n| false     | boolean   | 疑値         |\n| 0         | number    | 数値の0      |\n| -0        | number    | 数値の-0     |\n| NaN       | number    | Not a Number |\n| 0n        | bigint    | 整数値の0    |\n| \"\"        | string    | 空文字列     |\n| null      | null      | null         |\n| undefined | undefined | undefined    |\n\nこれらの値が`if`の条件式に入った場合、その`if`ブロックは実行されません。\n\n## truthy, falsyな値で条件分岐することの問題点\n\nこれらの値を使って`if`の条件式にすること自体は可能なのですが、同時に意図しない挙動を含むことがあるので使う際は注意したほうがよいでしょう。たとえば、次の例は配列にある`null`を取り除くつもりでコードを書きましたが、意図しない結果になります。\n\n```ts twoslash\nconst array = [null, 3, 0, null, 1, 2];\n\nconsole.log(array.filter((n) => n));\n// @log: [3, 1, 2]\n```\n\n`array.filter()`でfalsyな値を取り除いた結果、`null`はともかくnumber型でfalsyな値である`0`までもが取り除かれてしまいました。\n\n### このような事態にならないために\n\n意図しない分岐を避けるためには、truthy, falsyの値を直接boolean型として使うのではなく、ちゃんとtrue, falseの値を返すようにします。\n\n```ts twoslash\nconst array = [null, 3, 0, null, 1, 2];\n\nconsole.log(array.filter((n) => n !== null));\n// @log: [3, 0, 1, 2]\n```\n\n## TypeScript ESLintにもこの問題のためのオプションがある\n\nTypeScriptのeslintにも`if`ブロックでboolean型以外が与えられると警告を発するオプションがあります。\n\n[strict-boolean-expression](https://typescript-eslint.io/rules/strict-boolean-expressions/)\n\nしかしながら、このオプションでも`array.filter()`の例では警告を発しないので気をつける必要があります。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/truthy-falsy-values"
    },
    {
      "title": "明確な割り当てアサーション(definite assignment assertion)",
      "content": "---\nsidebar_label: 明確な割り当てアサーション\n---\n\n# 明確な割り当てアサーション(definite assignment assertion)\n\n明確な割り当てアサーションは、変数やプロパティが確実に初期化されていることをTypeScriptのコンパイラに伝える演算子です。\n\n## `strictNullChecks`と変数の初期化エラー\n\nTypeScriptはコンパイラオプション[`strictNullChecks`](../tsconfig/strictnullchecks.md)が`true`のとき、初期化されていない変数を参照した際にエラーを出します。\n\n```ts twoslash\n// @strictNullChecks: true\n// @errors: 2454\nlet num: number;\nconsole.log(num * 2);\n```\n\n変数の初期化が明らかに関数内で行われている場合でも、コンパイラは変数が初期化されていないとエラーを出します。\n\n```ts twoslash\n// @strictNullChecks: true\n// @errors: 2454\nlet num: number;\ninitNum(); // 関数内でnumを初期化しているが…\nconsole.log(num * 2);\nfunction initNum() {\n  num = 2;\n}\n```\n\n## `strictPropertyInitialization`とプロパティの初期化エラー\n\nTypeScriptでは次のコンパイラオプションの両方が`true`のとき、クラスのプロパティが初期化されていないとエラーを出します。\n\n- [`strictNullChecks`](../tsconfig/strictnullchecks.md)\n- [`strictPropertyInitialization`](../tsconfig/strictpropertyinitialization.md)\n\n```ts twoslash\n// @strictPropertyInitialization: true\n// @strictNullChecks: true\n// @errors: 2564\nclass Foo {\n  num: number;\n}\n```\n\nTypeScriptコンパイラは、プロパティ定義または`constructor`でプロパティが初期化されるかを見ています。しかし、`constructor`以外のメソッドで初期化されるところまでは追いかけません。たとえば、次例の`num3`は実際は初期化されるものの、コンパイラは初期化がされていないと警告を出します。\n\n```ts twoslash\n// @strictPropertyInitialization: true\n// @strictNullChecks: true\n// @errors: 2564\nclass Foo {\n  num1: number = 1; // 初期化している\n  num2: number;\n  num3: number;\n\n  constructor() {\n    this.num2 = 1; // 初期化している\n    this.initNum3(); // num3を初期化している\n  }\n\n  initNum3() {\n    this.num3 = 1;\n  }\n}\n```\n\n## 明確な割り当てアサーションを使う\n\n変数やプロパティの初期化が確実に行われていることをコンパイラに伝えるには、明確な割り当てアサーションを使います。変数宣言の変数名やプロパティ名のあとに`!`を書きます。\n\n```ts twoslash\n// @strictNullChecks: true\n// @errors: 2454\nlet num!: number;\n//     ^明確な割り当てアサーション\ninitNum();\nconsole.log(num * 2); // エラーにならない\nfunction initNum() {\n  num = 2;\n}\n```\n\n```ts twoslash\n// @strictPropertyInitialization: true\n// @strictNullChecks: true\nclass Foo {\n  num!: number;\n  // ^明確な割り当てアサーション\n}\n```\n\n## 非Nullアサーション\n\n別の方法として、非Nullアサーション(non-null assertion)を使う方法もあります。この場合は、変数を参照するコードにて、変数のあとに`!`を書きます。\n\n```ts twoslash\n// @strictNullChecks: true\n// @errors: 2454\nlet num: number;\ninitNum();\nconsole.log(num! * 2); // エラーにならない\n//             ^非Nullアサーション\nfunction initNum() {\n  num = 2;\n}\n```\n\n## より安全なコードを書くには\n\n明確な割り当てアサーションと非Nullアサーションは、型の安全性を保証する責任をコンパイラからプログラマに移すものです。そして、型に関してはコンパイラより人間のほうがミスをしやすいです。なので、こうしたアサーションはできる限り使わないほうが安全性は高いです。\n\nたとえば、上の例であれば`initNum`の戻り値を`num`に代入するほうが、より安全なコードになります。\n\n```ts twoslash\n// @strictNullChecks: true\nlet num: number;\nnum = initNum();\nconsole.log(num * 2);\nfunction initNum() {\n  return 2;\n}\n```\n\n他にも、`num`がnumber型であるかを型ガードでチェックする方法もあります。\n\n```ts twoslash\n// @strictNullChecks: true\nlet num: number | undefined;\ninitNum();\n// 型ガード\nif (typeof num === \"number\") {\n  console.log(num * 2);\n}\nfunction initNum() {\n  num = 2;\n}\n```\n\nこのようにアサーションに頼らない方法はないかを先に検討することをお勧めします。その上で、どうしてもというときにアサーションを使うようにしましょう。フレームワークやライブラリの都合で、やむを得ない場合もあります。\n\n<PostILearned>\n\n・明確な割り当てアサーションは、変数初期化が確実であるとTypeScriptのコンパイラに伝える\n・変数名のあとに!を書く\n・型安全の責任をコンパイラからプログラマに移すものなので、使わない方法を先に検討する\n・どうしようもないときに使う\n\n</PostILearned>\n\n## 関連情報\n\n[strictNullChecks](../tsconfig/strictnullchecks.md)\n\n[strictPropertyInitialization](../tsconfig/strictpropertyinitialization.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/definite-assignment-assertion"
    },
    {
      "title": "変数宣言の型注釈 (type annotation)",
      "content": "---\nsidebar_label: 変数宣言の型注釈\n---\n\n# 変数宣言の型注釈 (type annotation)\n\nTypeScriptでは変数宣言するときに、その変数にどんな値が代入可能かを指定できます。その指定のことを型注釈(type annotation; 型アノテーション)と言います。変数宣言の型注釈は、次のように変数名の右に型を書きます。\n\n```ts twoslash\nconst num: number = 123;\n//       ^^^^^^^^ 型注釈\n```\n\nJavaやPHPなどの言語も変数に対して型を宣言できますが、変数名と型を書く位置は左右逆です。それらの言語に慣れている方は注意しましょう。\n\n```java\nInt num = 123; // Java\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/type-annotation"
    },
    {
      "title": "リテラル型 (literal type)",
      "content": "---\nsidebar_label: リテラル型\n---\n\n# リテラル型 (literal type)\n\nTypeScriptではプリミティブ型の特定の値だけを代入可能にする型を表現できます。そのような型をリテラル型と呼びます。\n\nたとえば、次の例は数値が代入可能な型注釈です。数値であれば、1でも100でも何でも代入できます。\n\n```ts twoslash\nlet x: number;\nx = 1;\n```\n\nリテラル型を用いると、1だけが代入可能な型が作れます。\n\n```ts twoslash\n// @errors: 2322\nlet x: 1;\nx = 1;\nx = 100;\n```\n\n## リテラル型として表現できるもの\n\nリテラル型として表現できるプリミティブ型は次のとおりです。\n\n- boolean型のtrueとfalse\n- number型の値\n- string型の文字列\n\n```ts twoslash\nconst isTrue: true = true;\nconst num: 123 = 123;\nconst str: \"foo\" = \"foo\";\n```\n\n## リテラル型の用途\n\n一般的にリテラル型はマジックナンバーやステートの表現に用いられます。その際、ユニオン型と組み合わせることが多いです。\n\n```ts twoslash\nlet num: 1 | 2 | 3 = 1;\n```\n\n[ユニオン型 (union type)](union.md)\n\n[判別可能なユニオン (discriminated union)](discriminated-union.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/literal-types"
    },
    {
      "title": "変数宣言の型推論",
      "content": "# 変数宣言の型推論\n\nTypeScriptには型推論(type inference)と呼ばれる機能があります。型推論は、**コンパイラが型を自動で判別する機能**です。プログラマーは型推論を活用すると、型注釈を省略できるので、コードの記述量を減らせる利点があります。\n\n```ts twoslash\n// @errors: 2322\nlet x = 1; // let x: number = 1;と同じ意味になる\nx = \"hello\";\n```\n\n上の例では変数`x`に`1`の値コードを代入しています。この時点でコンパイラは代入された値から、変数`x`の型を`number`型と自動で判別します。型注釈`x: number`を書くことを省略できます。\n\n型注釈が書かれていないものの`x`は`number`型を推論されているため、`x`に`hello`のstring型を再代入する記述は、型の不一致によりコンパイルエラーとなります。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/type-inference"
    },
    {
      "title": "型エイリアス (type alias)",
      "content": "---\nsidebar_label: 型エイリアス\n---\n\n# 型エイリアス (type alias)\n\nTypeScriptでは、型に名前をつけられます。名前のついた型を型エイリアス(タイプエイリアス; type alias)と呼びます。\n\n## 型エイリアスの宣言\n\n型エイリアスを宣言するには`type`キーワードを使います。次の例は、`string | number`型に`StringOrNumber`という型名を名付けたものです。\n\n```ts twoslash\ntype StringOrNumber = string | number;\n```\n\n型エイリアスは、`string`などのビルトインの型と同様に、変数や引数、戻り値の型注釈などで使えます。\n\n```ts twoslash\ntype StringOrNumber = string | number;\n// ---cut---\nconst value: StringOrNumber = 123;\n```\n\n## 型エイリアスの使用例\n\n型エイリアスはさまざまな型に名前をつけられます。型エイリアスの一例を次に示します。\n\n```ts twoslash\n// プリミティブ型\ntype Str = string;\n// リテラル型\ntype OK = 200;\n// 配列型\ntype Numbers = number[];\n// オブジェクト型\ntype UserObject = { id: number; name: string };\n// ユニオン型\ntype NumberOrNull = number | null;\n// 関数型\ntype CallbackFunction = (value: string) => boolean;\n```\n\n## 型エイリアスの使い道\n\n型エイリアスは同じ型を再利用したいときに使うと便利です。型の定義が一箇所になるため、保守性が向上します。\n\nまた、型に名前を与えることで可読性が上がる場合があります。型に名前があると、その型が何を意味しているのかがコードの読み手に伝わりやすくなります。\n\n## 関連情報\n\n[🚧interfaceとtypeの違い](../object-oriented/interface/interface-vs-type-alias.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/type-alias"
    },
    {
      "title": "TypeScriptと構造的型付け",
      "content": "---\nsidebar_label: 構造的型付け\n---\n\n# TypeScriptと構造的型付け\n\nプログラミング言語にとって、型システムは大事なトピックです。型システムとは、プログラム内のさまざまな値や変数に「型」を割り当てる決まりを指します。この決まりによってデータの性質や扱い方が決まります。特に、**どのように型と型を区別するのか**、逆に、**どのように型同士が互換性ありと判断するか**は、言語の使いやすさや安全性に直結するテーマです。\n\n考えてみましょう。`string`型と`boolean`型は同じものと見なせるでしょうか？これらは明らかに異なるデータ型であり、たとえば`boolean`型の変数に文字列を代入することは、型の安全性を守る上で望ましくありません。このような型の区別は、プログラムを正しく動作させるために欠かせません。\n\nさらに、型の「互換性」も重要な概念です。たとえば、次のふたつのクラスを考えます。\n\n```ts twoslash\nclass Person {\n  walk() {}\n}\n\nclass Dog {\n  walk() {}\n}\n```\n\nこれらのクラスは、`walk`メソッドを持つ点で似ています。このようなとき、`Person`型と`Dog`型は「互換性がある」とみなすことができるでしょうか。それとも、まったく異なる型として扱うべきでしょうか。\n\nこうした問題を扱うために、プログラミング言語はさまざまな型システムを採用しています。どのように型を区別すべきか、また、どのように型同士の互換性を判断するべきか、このような観点から型システムの仕様を考える必要があります。TypeScriptでは、「構造的型付け」という型システムが採用されています。構造的型付けがどのように型を区別し、逆にどのように型同士に互換性があると判断するのか、こうした言語仕様を知ることは、よいコードを書くために役立ちます。\n\n## 型の区別に関する2つのアプローチ\n\nプログラミング言語における型の区別や互換性の判定には、主に次の2つのアプローチが存在します。\n\n- 名前的型付け\n- 構造的型付け\n\nここからは、TypeScriptだけでなく他の言語も含めて、それぞれのアプローチについて見ていきましょう。\n\n### 名前的型付け\n\n名前的型付け(nominal typing)は、型の名前に基づいて型の区別を行う方法です。このアプローチでは、型同士が同一かどうかを判断する際に、その型の名前が重要な役割を果たします。たとえば、`string`型と`number`型は名前が異なるため、異なる型として扱います。同様に、型が同じ名前を持つ場合（例：`string`と`string`）は、同じ型と判断します。このアプローチでは、`Person`型と`Dog`型は名前が異なるため、異なる型として扱い、互換性もなしと判断します。\n\n名前的型付けを採用している言語の例としては、Java、PHP、C#、Swiftなどが挙げられます。これらの言語では、型の互換性は型の名前によって制御されます。たとえばJavaでは、次のように`Person`インスタンスを`Dog`型の変数に代入しようとすると、型の不一致がコンパイルエラーとして報告されます。\n\n```java\nclass Person {}\n\nclass Dog {}\n\nclass Main {\n    public static void main(String[] args) {\n        Person person = new Person();\n        Dog dog = person; // コンパイルエラー: 不適合な型\n    }\n}\n```\n\nこの例では、`Person`型と`Dog`型は名前が異なるため、Javaの型システムはこれらを異なる型として扱い、互換性がないと判断します。このように、名前的型付けでは型の名前が型の同一性および互換性を判断するための基準となります。\n\n### 構造的型付け\n\n構造的型付け(structural typing)は、型の名前ではなく、その「構造」に着目して型の区別や互換性を判定するアプローチです。この方法では、型が持つプロパティやメソッドの構造が同一であれば、異なる名前を持つ型同士でも互換性があると見なします。TypeScriptはこの構造的型付けを型システムとして採用しています。\n\n構造的型付けの考え方を、`Person`クラスと`Dog`クラスの例で具体的に見てみましょう。\n\n```ts twoslash\nclass Person {\n  walk() {}\n}\n\nclass Dog {\n  walk() {}\n}\n```\n\nこれらのクラスは、名前は異なりますが、構造が同じです。両クラスとも`walk`メソッドをひとつ持っています。このメソッドは引数を取らず、戻り値も持ちません。構造的型付けの観点からは、この共通の構造により`Person`と`Dog`は互換性があると判断されます。\n\nTypeScriptのコード例を見てみましょう。\n\n```ts twoslash\nclass Person {\n  walk() {}\n}\n\nclass Dog {\n  walk() {}\n}\n// ---cut---\nconst person = new Person();\nconst dog: Dog = person; // コンパイルエラーにならない\n```\n\nこのコードでは、`Person`インスタンスを`Dog`型の変数に代入していますが、コンパイルエラーになりません。これは、`Person`と`Dog`が構造的に互換性があるためです。\n\n一方で、構造が異なる場合は互換性が認められません。\n\n```ts twoslash\n// @errors: 2741\nclass Person {\n  speak() {}\n}\nclass Dog {\n  bark() {}\n}\nconst person = new Person();\nconst dog: Dog = person; // コンパイルエラーになる\n```\n\nこの場合、`Person`と`Dog`は異なるメソッドを持っているため、構造的に互換性がないと見なされ、代入しようとするとコンパイルエラーが発生します。\n\n構造的型付けを採用している他の言語には、Go言語があります。このように構造的型付けは、型の名前よりもその「構造」に重点を置いた型システムを提供し、柔軟かつ直感的なプログラミングを可能にします。\n\n次の表は、名前的型付けと構造的型付けの特徴をまとめたものです。\n\n|              | 名前的型付け                 | 構造的型付け                 |\n| ------------ | ---------------------------- | ---------------------------- |\n| 型の区別基準 | 型の名前                     | 型の構造                     |\n| 互換性の判断 | 名前が同じであれば互換性あり | 構造が同じであれば互換性あり |\n| 主な採用言語 | Java, C#, Swift, PHPなど     | TypeScript, Goなど           |\n\n## 部分型\n\n多くのプログラミング言語では、型と型の関係性を階層関係で捉えることができます。階層構造において、頂点に位置するのはもっとも抽象的な型です。階層を下に進むほど具体的な型に分化していきます。階層構造の上位に位置する型を**基本型**(supertype)と言います。下層の型と比べると、基本型は抽象的な型です。階層構造の下位に位置する型を**部分型**(subtype)と呼びます。部分型は、基本型が持つすべての性質や振る舞い(メソッドやプロパティ)を持ちつつ、加えて新たな性質や振る舞いも持つ型です。\n\nたとえば、図形と面積に関する型を考えたとき、図形(`Shape`)という基本型の下に、円(`Circle`)や長方形(`Rectangle`)という部分型が定義できます。`Shape`は下位の型に比べて抽象的な型で、面積を求められる能力(`area`メソッド)を持っています。一方で、`Circle`はより具体的な型で、`Shape`の能力を引き継ぎつつ、半径(`radius`)という新たな属性を持っています。同様に、`Rectangle`も`Shape`の能力を引き継ぎつつ、幅(`width`)と高さ(`height`)という新たな属性を持っています。\n\nimport ClassDiagramShapeCircleRectangle from '@site/static/img/reference/values-types-variables/structural-subtyping/class-diagram-shape-circle-rectangle.svg';\n\n<!-- 画像ソース: https://www.figma.com/file/E22NH0kgcl5xhVCtn1HCfz/%E3%82%B5%E3%83%90%E3%82%A4%E3%83%90%E3%83%ABTypeScript%E7%94%BB%E5%83%8F%E3%82%A2%E3%82%BB%E3%83%83%E3%83%88?type=design&node-id=558-127&mode=design&t=Mw06bZx3zqMd92aa-4 -->\n\n<figure class=\"themed\">\n    <figcaption>階層構造</figcaption>\n    <ClassDiagramShapeCircleRectangle />\n</figure>\n\n部分型は基本型と互換性があります。基本型の変数に部分型の値を代入することが可能です。たとえば、`Circle`と`Rectangle`は異なる型ですが、同じ`Shape`として扱うことができます。より抽象的な階層レベルで扱えると利便性が高まります。たとえば、異なる図形同士の面積を合計するケースです。`Shape`型の変数に`Circle`や`Rectangle`の値を代入して、それらの合計面積を求めることができます。\n\n```ts twoslash\ndeclare class Shape {\n  area(): number;\n}\ndeclare class Circle extends Shape {\n  radius: number;\n  constructor(options: { radius: number });\n  area(): number;\n}\ndeclare class Rectangle extends Shape {\n  width: number;\n  height: number;\n  constructor(options: { width: number; height: number });\n  area(): number;\n}\n// ---cut---\nfunction totalArea(shape1: Shape, shape2: Shape): number {\n  return shape1.area() + shape2.area();\n}\n\nconst circle = new Circle({ radius: 10 });\nconst rectangle = new Rectangle({ width: 10, height: 20 });\ntotalArea(circle, rectangle); // CircleとRectangleをShapeとして扱える\n```\n\nある型とある型が、基本型と部分型の関係になるかどうかを判断する基準は、名前的型付けと構造的型付けでも異なります。たとえば、`Circle`が`Shape`の部分型かどうかは、名前的型付けと構造的型付けで判断基準が異なるということです。それぞれどのような判断基準があるのか、次の節で見ていきましょう。\n\n### 名前的部分型\n\n名前的型付けを採用しているプログラミング言語では、型の階層関係を定義する際に、型の名前とその関係性に重点を置きます。このアプローチでは、クラスやインターフェースの継承を通じて、型間の親子関係（基本型と部分型の関係）が形成されます。名前的型付けのアプローチで扱われる部分型のことを**名前的部分型**(nominal subtype)と呼びます。\n\nたとえば、Javaでは`extends`キーワードを使用して、基本型と部分型の関係性を宣言します。この宣言により、特定のクラスが別のクラスの部分型であることをJavaコンパイラに知らせます。\n\n```java\nclass Shape {}\n\nclass Circle extends Shape {}\n```\n\nこのコード例では、`Circle`クラスが`Shape`クラスを継承しています。この継承により、`Circle`は`Shape`の部分型となります。この階層関係により、`Shape`型の変数に`Circle`型のインスタンスを代入することが可能になります。この代入は、`Circle`が`Shape`の部分型であるために、型の互換性が保証されているからです。\n\n```java\nShape shape = new Circle();\n```\n\n一方で、`Circle`と`Shape`間に`extends`キーワードによる継承関係が宣言されていない場合、両者の間に階層関係は存在しません。\n\n```java\nclass Shape {}\n\nclass Circle {}\n```\n\nこの状況では、`Shape`型の変数に`Circle`型のインスタンスを代入しようとすると、型不一致のエラーが発生します。このエラーは、`Circle`と`Shape`が互換性のない独立した型であるとJavaコンパイラに判断されたために起きます。\n\n```java\nShape shape = new Circle();\n// エラー: 不適合な型: CircleをShapeに変換できません\n```\n\n### 構造的部分型\n\n構造的型付けを採用しているTypeScriptでは、型間の階層関係もその構造に基づいて判断されます。このアプローチでは、型の名前ではなく、型が持つプロパティやメソッドの構造に着目して、基本型と部分型の関係性を判断します。このような部分型のことを**構造的部分型**(structural subtype)と呼びます。\n\n次のTypeScriptのコード例を考えてみましょう。\n\n```ts twoslash\nclass Shape {\n  area(): number {\n    return 0;\n  }\n}\n\nclass Circle {\n  radius: number;\n\n  constructor(radius: number) {\n    this.radius = radius;\n  }\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n}\n```\n\nこの例では、`Circle`クラスは`Shape`クラスの`area`メソッドを持っており、追加で`radius`プロパティを定義しています。`extends`キーワードを使用していないにもかかわらず、`Circle`は`Shape`の部分型として扱われます。これは、`Circle`が`Shape`の持つ構造（ここでは`area`メソッド）を含んでいるためです。その結果、`Shape`型の変数に`Circle`型のインスタンスを代入することが可能になります。\n\n```ts twoslash\ndeclare class Shape {\n  area(): number;\n}\ndeclare class Circle {\n  constructor(radius: number);\n  area(): number;\n}\n// ---cut---\nconst shape: Shape = new Circle(10);\n```\n\nTypeScriptでも`extends`キーワードを用いてクラス間の継承関係を宣言できます。しかし、これは部分型かどうかを判定するための基準には用いられません。これはJavaのような名前的部分型の言語とは異なる点です。`extends`キーワードが持つ効果は、親クラスの機能を継承すること、そして、子クラスが親クラスのインターフェースを守ることです。\n\n```ts twoslash\nclass Animal {\n  walk() {}\n}\n\nclass Dog extends Animal {\n  walk() {}\n}\n```\n\nこのコードでは、`Dog`が`Animal`を継承しています。この例では、`Dog`の`walk`メソッドが`Animal`の`walk`メソッドと同じ引数と戻り値を持っているため、`Dog`は`Animal`のインターフェースを守っているということになります。`Dog`が`Animal`のインターフェースを守っているため、`Dog`についてコンパイルエラーは発生しません。\n\n一方で、子クラスが親クラスのインターフェースを守らない場合、TypeScriptはエラーを報告します。次のコード例では、`Dog`クラスの`walk`メソッドが`Animal`クラスのそれと異なる引数を持っています。`Dog`クラスは`Animal`クラスのインターフェースを守っていないということです。この例では、`walk`メソッドに対して、その旨の警告がなされます。これが`extends`キーワードの効果です。\n\n```ts twoslash\n// @errors: 2416\nclass Animal {\n  walk() {}\n}\n\nclass Dog extends Animal {\n  walk(speed: number) {} // コンパイルエラーになる\n}\n```\n\n## 構造的型付けの採用理由\n\nTypeScriptが構造的型付けを採用した背景には、JavaScriptの特性が深く関わっています。ここでは、なぜTypeScriptが構造的型付けを選んだのかについて考えてみましょう。\n\n### ダックタイピング\n\nダックタイピングは、オブジェクトの型よりもオブジェクトの持つメソッドやプロパティが何であるかによってオブジェクトを判断するプログラミングスタイルです。ダックタイピングの世界では、特定のインターフェースを`implements`キーワードを使うなどして明示的に実装する必要はありません。代わりに、オブジェクトが特定の規約にしたがっているか、たとえば、特定のメソッドを持っているかという基準で、そのオブジェクトの型を判断します。ダックタイピングでは、型を判断するために型の名前を使わないのが一般的です。ちなみに、ダックタイピングという用語は、「もし鳥がアヒルのように歩き、アヒルのように鳴くなら、それはアヒルだ」という言葉に由来しています。\n\nダックタイピングは、動的型付け言語によく見られます。JavaScriptも動的型付け言語であり、ダックタイピングとともに歩んできた歴史があります。TypeScriptはJavaScriptの延長線上にある言語です。そのため、ダックタイピングが行えるような型システムが求められました。構造的型付けは、ダックタイピングに適した型システムです。こうした背景もTypeScriptが構造的型付けを採用した理由のひとつと考えられます。\n\n### オブジェクトリテラル\n\nJavaScriptの特徴のひとつには[オブジェクトリテラル]があります。オブジェクトリテラルは、クラスやインターフェースなどの型を定義することなく、その場でオブジェクトを生成する機能です。\n\n[オブジェクトリテラル]: ./object/object-literal.md\n\n```ts twoslash\nconst circle = {\n  radius: 10,\n  area() {\n    return Math.PI * this.radius ** 2;\n  },\n};\n```\n\n上の例のように、`circle`オブジェクトには型の名前がありません。型に名前がない以上、名前的型付けのように型名を使って型を判断することができません。こうしたJavaScriptコードを扱えるようにするためにも、TypeScriptは構造的型付けを採用したと考えられます。\n\n## 構造的型システムの利点\n\n構造的型付けの柔軟性や便利さは注目に値するところがあります。ここでは、具体例を交えて構造的型付けの利点について見ていきましょう。\n\n### モックテストの簡略化\n\n構造的型付けは、モックテストや依存性の注入を簡単に行えるようにします。特に、外部のAPIやサービスに依存するコンポーネントをテストする際に、その依存関係を模倣したモックオブジェクトを簡単に作成できます。名前的型付けでは、モック化したいオブジェクトをまずインターフェース化する必要があります。その上で、インターフェースを実装するモッククラスを用意します。構造的型付けでは、必要なメソッドやプロパティを持つオブジェクトリテラルを直接提供するだけで、テスト用のモックを簡単に用意できます。インターフェースの定義が省けるため、構造がシンプルになり、テストの準備も省力化されます。\n\n次の例では、`UserService`クラスが`UserApi`に依存しています。この依存関係をテストするために、`UserApi`のメソッド`getUser`を模倣したモックを作成し、`UserService`の動作をテストします。\n\n```ts twoslash\n// @noErrors: 2355\ntype User = { id: number; name: string };\n\nclass UserApi {\n  async getUser(id: number): Promise<User | undefined> {\n    // 実装は割愛しますが、fetchなどを使って実際のAPIを呼び出す実装をイメージしてください。\n  }\n}\n\nclass UserService {\n  private api: UserApi;\n\n  constructor(api: UserApi) {\n    this.api = api;\n  }\n\n  async userExists(id: number): Promise<boolean> {\n    const user = await this.api.getUser(id);\n    return user !== undefined;\n  }\n}\n```\n\nテストケースでは、`UserApi`の構造を満たすオブジェクトを直接作成し、`UserService`のインスタンスに渡すだけで単体テストを行えます。\n\n```ts twoslash\ndeclare const test: any;\ndeclare const expect: any;\ndeclare type User = { id: number; name: string };\ndeclare class UserApi {\n  getUser(id: number): Promise<User | undefined>;\n}\ndeclare class UserService {\n  private api;\n  constructor(api: UserApi);\n  userExists(id: number): Promise<boolean>;\n}\n// ---cut---\ntest(\"ユーザーがいるときはtrueを返す\", async () => {\n  // モックオブジェクトを直接作成\n  const api: UserApi = {\n    async getUser(id) {\n      return { id, name: \"Alice\" };\n    },\n  };\n  // モックオブジェクトをUserServiceに渡してテスト\n  const service = new UserService(api);\n  const result = await service.userExists(123);\n  expect(result).toBe(true);\n});\n```\n\nこのように、構造的型付けを利用することで、テスト対象の依存物の注入がより簡単になります。\n\n## 構造的型付けの注意点\n\n構造的型付けは、その柔軟性により多くの利点を提供しますが、注意が必要な点もあります。特に、意図せず型に互換性が生じる可能性があることがそのひとつです。\n\n構造的型付けシステムでは、型の互換性はその構造に基づいて判断されます。このため、異なる目的や意味合いを持つ型が、偶然同じ構造を持っている場合に、意図せずに互換性があると判断されることがあります。\n\n```ts\nclass UserId {\n  id: string;\n}\n\nclass ProductId {\n  id: string;\n}\n\nconst userId: UserId = new UserId();\nconst productId: ProductId = userId; // 代入できるが、意図した設計ではない\n```\n\nこの例では、`UserId`クラスと`ProductId`クラスがあり、どちらも`id`プロパティを持つ同じ構造になっています。TypeScriptはこれらの型を互換性があるとみなします。なぜなら構造が同じだからです。しかし、データモデルやドメインモデルの観点からは、ユーザーのIDと商品のIDはまったく異なる概念であり、型システムで区別したい場合がほとんどです。値オブジェクト(value object)のようなデザインパターンをTypeScriptで用いる場合は、このような問題に注意が必要です。型としてどうしても区別したい場合は、後述の「名前的型付けを実現する方法」で紹介するテクニックを検討してみてください。\n\n## 名前的型付けを実現する方法\n\nTypeScriptは基本的に構造的型付けを採用していますが、名前的型付けになる場合や、名前的型付けを模倣するデザインパターンもあります。これは、TypeScriptの型システムの柔軟性を利用したテクニックであり、プログラムの正当性を強化するために用いられることがあります。\n\n### privateメンバーを持つクラス\n\nTypeScriptでは、`private`メンバーを持つクラスは、他のクラスと区別されます。これは、`private`メンバーがそのクラス固有のものであるため、異なるクラスのインスタンス同士は、構造が同じであっても互換性がないと見なされるからです。\n\n```ts twoslash\n// @errors: 2322\nclass UserId {\n  private id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  getId(): string {\n    return this.id;\n  }\n}\n\nclass ProductId {\n  private id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  getId(): string {\n    return this.id;\n  }\n}\n\nconst userId: UserId = new UserId(\"1\");\nconst productId: ProductId = userId; // 代入エラー\n```\n\nこの例では、`UserId`と`ProductId`は、内部的に`private`メンバー`id`を持っていますが、互いに別の型として扱われます。つまり、名前的型付けのように、名前によって型が区別されるようになります。\n\n[公称型クラス](../object-oriented/class/class-nominality.md)\n\n### ブランド型\n\nブランド型(または幽霊型(phantom type)、opaque type)は、型を区別するためのプロパティを型に持たせることで、その型を明確に区別するデザインパターンです。これは、型にメタデータのようなタグをつけることで、構造的には同じであっても型と型を区別できるようにします。\n\n```ts twoslash\ninterface UserId {\n  __brand: \"UserId\";\n  id: number;\n}\n\ninterface ProductId {\n  __brand: \"ProductId\";\n  id: number;\n}\n```\n\nこの例では、`__brand`プロパティを使って`UserId`型と`ProductId`型を区別しています。これにより、両者が構造的に同じ`id`プロパティを持っていても、型システム上では異なる型として扱われます。これは、構造的型付けの特徴をうまく利用したテクニックです。構造的型付けでは、構造が異なる場合は互換性がないと見なすわけですから、`__brand`のような構造を意図的に違えるものを使うことで、型を区別することができるのです。\n\nブランド型で用いられる`__brand`プロパティは、型を区別するためのものであり、実行時のデータとして持たせる必要はありません。このため、`__brand`プロパティは、実際のデータには含まれないようにすることが一般的です。これを達成するために、`__brand`プロパティは`as`キーワードを使って[型アサーション]を行う手法がよく使われます。\n\n[型アサーション]: ./type-assertion-as.md\n\n```ts twoslash\ninterface UserId {\n  __brand: \"UserId\";\n  id: number;\n}\n// ---cut---\nconst userId = { id: 1 } as UserId;\n```\n\nブランド型を用いて作られた値は、あたかも名前的型付けのように、名前によって型が区別されるようになります。\n\n```ts twoslash\n// @errors: 2322\ninterface UserId {\n  __brand: \"UserId\";\n  id: number;\n}\n\ninterface ProductId {\n  __brand: \"ProductId\";\n  id: number;\n}\n// ---cut---\nconst userId = { id: 1 } as UserId;\nconst productId: ProductId = userId; // 代入不可\n```\n\nこれらのテクニックを利用することで、構造的型付けのTypeScriptでも、名前に依存した型の区別が行えます。名前による型の区別が必要な場合は、これらのテクニックを検討してみるとよいでしょう。\n\n## まとめ\n\n|                        | 名前的型付け                                                                                   | 構造的型付け                                                                         |\n| ---------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |\n| 型の区別基準           | 型の名前                                                                                       | 型の構造（プロパティやメソッドなど）                                                 |\n| 互換性の判断基準       | 名前が同じであれば互換性あり                                                                   | 構造が同じであれば互換性あり                                                         |\n| 基本型と部分型の明示性 | 明示的（`extends`などのキーワードによる継承を使用）                                            | 暗黙的（型の構造が一致する場合、自動的に部分型とみなされる）                         |\n| 主な採用言語           | Java, C#, Swift, PHP                                                                           | TypeScript, Go                                                                       |\n| 利点                   | - 型の名前に基づく明確な区別が可能<br />- 明示的な型の階層関係により、設計の意図を明確にできる | - ダックタイピングにより、アドホックにオブジェクトを作れる                           |\n| 欠点                   | - 型間の互換性が名前に依存し、柔軟性に欠ける場合がある                                         | - 意図しない型間の互換性が生じる可能性がある<br />- 型の区別が直感的でない場合がある |\n\n構造的型付けはTypeScriptの型システムの核心を成す概念であり、型の互換性をその構造に基づいて判断します。これは、型の名前ではなく、型が持つプロパティやメソッドの構造を見て型の同一性や互換性を判断するというものです。このアプローチは、JavaScriptの動的で柔軟な特性に対応するために採用されており、ダックタイピングやオブジェクトリテラルといったJavaScriptの特徴と良く合います。\n\n構造的型付けは柔軟性が高く、モックテストなどを容易にしますが、意図せず互換性が生じる可能性もあるという注意点があります。しかし、`private`メンバーやブランド型といったテクニックを用いることで、構造的型付けのシステム内で名前的型付けの振る舞いを模倣し、型の明確な区別を実現することも可能です。\n\n構造的型付けを理解し、適切に活用することで、より安全で保守しやすいコードを書くことができるでしょう。\n\n<PostILearned>\n\n・TypeScriptは構造的型付け\n・構造的型付けは型名より構造を重視\n・構造的型付けは型の構造で互換性判断\n・privateやブランド型で名前的型付けを模倣できる\n・構造的型付けは意図しない互換性に注意\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/structural-subtyping"
    },
    {
      "title": "bigint型リテラル",
      "content": "---\nsidebar_label: bigint型\ntitle: bigint型(長整数型)\n---\n\nJavaScriptのbigint型は、number型よりも大きな整数を扱えるプリミティブ型です。\n\n## bigint型リテラル\n\nJavaScriptのbigint型のリテラルは整数値の末尾に`n`をつけて書きます。\n\n```ts twoslash\nconst x = 100n;\n```\n\nbigintリテラルをTypeScriptで用いるには、コンパイラーオプションのtargetをes2020以上にする必要があります。\n\n## bigint型の型注釈\n\nTypeScriptでbigint型を型注釈するには、`bigint`を用います。\n\n```ts twoslash\nconst x: bigint = 100n;\n```\n\n## BigInt関数\n\nbigint型はBigInt関数を使って作ることができます。BigInt関数は第1引数に数値もしくは文字列を渡します。\n\n```ts twoslash\nconst x = BigInt(100);\nconst y = BigInt(\"9007199254740991\");\n```\n\nTypeScriptでBigInt関数を用いるには、コンパイラーオプションのlibをes2020以上にする必要があります。\n\n## bigint型をnumber型と計算する\n\nbigint型とnumber型はそのままでは一緒に演算をすることはできません。どちらかに型を合わせる必要があります。\n\n```ts twoslash\n// @errors: 2365\n2n + 3;\n```\n\nnumber型が小数部を持っていない限り、より表現幅の広いbigint型に合わせる方が無難です。\n\n```ts twoslash\nconst i = 2n + BigInt(3);\nconsole.log(i);\n// @log: 5n\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/bigint"
    },
    {
      "title": "等価であるということ",
      "content": "---\nsidebar_label: 等価であるということ\n---\n\n# 等価であるということ\n\nどの言語でも、値を比較することがあります。JavaScriptにおいて等価の演算子は等価演算子(`==`)と厳密等価演算子(`===`)のふたつがあります。等しいことを判定するための演算子がふたつ存在するのは、必ずしも同じものを等しいとはしないためです。\n\n## `===`で等価であるということ\n\n厳密と名がついているとおり、この演算子での等価は**型が等しく、かつ値が等しい**ことを指します。この動作は等価演算子がひとつしかない言語の`==`と同じものです。\n\n次の例は同然ではないかと思うかもしれません。\n\n```js twoslash\n// JavaScript\n\nconsole.log(null === undefined);\n// @log: false\nconsole.log(0 === 0n);\n// @log: false\nconsole.log(0 === \"0\");\n// @log: false\n```\n\n`0n`はnumber型ではなくbigint型のことです。\n\n[bigint型](./bigint.md)\n\n## `==`で等価であるということ\n\nただの等価演算子という名ですが、こちらは**型が異なっていても同じと見なす**ことがあります。厳密には、値の型が異なる場合は型の変換ができないか試みてから値が等しいかを比較します。\n\n```ts twoslash\nconsole.log(null == undefined);\n// @log: true\nconsole.log(0 == 0n);\n// @log: true\nconsole.log(0 == \"0\");\n// @log: true\nconsole.log(0 == \"\");\n// @log: true\nconsole.log(0 == false);\n// @log: true\nconsole.log(\"0\" == false);\n// @log: true\nconsole.log(\"\" == false);\n// @log: true\n// @noErrors\n```\n\n`\"0\" == false`, `\"\" == false`は戻り値が`true`ですが、だからとはいえ`\"\" == \"0\"`は`false`となるので注意が必要です。\n\n## いつ`==`と`===`を使うのか、使い分けるのか\n\n意図しない動作を避けるという観点においては、厳密等価演算子(`===`)を常用し、必要なタイミングで等価演算子を使うといいでしょう。とはいえその必要なタイミングの多くは`x == null`です。これは変数xが`null`か`undefined`のときに`true`を返します。\n\n## 等価であることを気をつける値\n\n安易に等値比較をすると`false`になってしまい、注意が必要な値があります。\n\n- `NaN`\n- symbol型の値\n- object型の値\n\n### `NaN`\n\n`NaN`はnumber型の値ですが、どの値と比較をしても`false`を返します。たとえそれが`NaN`同士の比較であっても`false`を返します。\n\n```js twoslash\n// JavaScript\n\nconsole.log(NaN == NaN);\n// @log: false\nconsole.log(NaN === NaN);\n// @log: false\n```\n\nこの性質を使うとその値が`NaN`であるかどうかを判定することができます。\n\n```ts twoslash\nfunction isNaN(value: unknown): boolean {\n  return value !== value;\n}\n\nconsole.log(isNaN(1));\n// @log: false\nconsole.log(isNaN(NaN));\n// @log: true\n```\n\n### symbol型の値\n\nsymbol型は、たとえ同じdescription(第1引数)が同じ値同士を比較しても、まったく同じ変数名を参照しない限り`false`を返します。\n\n```ts twoslash\nconsole.log(Symbol(\"piano\") == Symbol(\"piano\"));\n// @log: false\nconsole.log(Symbol(\"piano\") === Symbol(\"piano\"));\n// @log: false\nconst sym = Symbol(2);\nconsole.log(sym === sym);\n// @log: true\n```\n\n### object型の値\n\nobject型は、同じプロパティと値のペアの比較をしても、まったく同じ変数名を参照しない限り`false`を返します。これはオブジェクトについて理解がある人にとっては当然の挙動です。\n\n```js twoslash\n// JavaScript\n\nconsole.log({} == {});\n// @log: false\nconsole.log({} === {});\n// @log: false\nconsole.log({ age: 18 } == { age: 18 });\n// @log: false\nconsole.log({ equipment: \"glasses\" } === { equipment: \"glasses\" });\n// @log: false\nconst obj = { hair: \"blond\" };\nconsole.log(obj === obj);\n// @log: true\n// @noErrors\n```\n\n## まとめ\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/equality"
    },
    {
      "title": "ボックス化 (boxing)",
      "content": "---\nsidebar_label: \"ボックス化\"\n---\n\n# ボックス化 (boxing)\n\n多くの言語では、プリミティブは一般的にフィールドやメソッドを持ちません。プリミティブをオブジェクトのように扱うには、プリミティブをオブジェクトに変換する必要があります。プリミティブからオブジェクトへの変換をボックス化(boxing)と言います。\n\n```ts twoslash\n// プリミティブ型\nconst str = \"abc\";\n// ラッパーオブジェクトに入れる\nconst strObject = new String(str);\n// オブジェクトのように扱う\nstrObject.length; // フィールドの参照\nstrObject.toUpperCase(); // メソッド呼び出し\n```\n\n上の例は、JavaScriptでボックス化のイメージを書いたものです。実際のコードでは、プリミティブ型を`String`のようなラッパーオブジェクトにわざわざ入れる必要はありません。JavaScriptには自動ボックス化という仕組みがあるからです。\n\n## 自動ボックス化\n\nJavaScriptでは、プリミティブ型の値でもフィールドを参照できたり、メソッドが呼び出せます。\n\n```ts twoslash\nconst str = \"abc\";\n// オブジェクトのように扱う\nstr.length; // フィールドの参照\nstr.toUpperCase(); // メソッド呼び出し\n```\n\nプリミティブ型の値はオブジェクトではないため、このような操作ができるのは変です。ボックス化する必要があるように思えます。しかし、このようなことができるのは、JavaScriptが内部的にプリミティブ型の値をオブジェクトに変換しているからです。この暗黙の変換を自動ボックス化(auto-boxing)と呼びます。\n\n## ラッパーオブジェクト\n\nJavaScriptの自動ボックス化で変換先となるオブジェクトをラッパーオブジェクト(wrapper object)と呼びます。プリミティブ型とラッパーオブジェクトの対応は次の表のとおりです。\n\n| プリミティブ型 | ラッパーオブジェクト |\n| -------------- | -------------------- |\n| `boolean`      | `Boolean`            |\n| `number`       | `Number`             |\n| `string`       | `String`             |\n| `symbol`       | `Symbol`             |\n| `bigint`       | `BigInt`             |\n\nプリミティブ型の`undefined`と`null`にはラッパーオブジェクトがありません。したがって、メソッドやフィールドの参照は常にエラーが発生します。\n\n```ts twoslash\n// @errors: 18050\nnull.toString();\nundefined.toString();\n```\n\n## MDNの読み方\n\nJavaScriptを学ぶ過程で一度はお世話になるドキュメントが[MDN Web Docs](https://developer.mozilla.org/ja/docs/Web/JavaScript)です。自動ボックス化とラッパーオブジェクトを意識すると、MDNのドキュメントが理解しやすくなります。\n\nたとえば、数値の`toString`メソッドの説明は、MDNでは[「Number.prototype.toString()」というタイトルのページ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)に書かれています。`toString`がプリミティブ型の`number`に生えているものだと思っていると、「Number.prototypeは何だろう」「number型を調べているはずなのに、なぜNumberオブジェクトのページに書いてあるんだろう」などといった疑問を持つかもしれません。\n\n自動ボックス化とラッパーオブジェクトを知っていると、この疑問が解消します。`number`にはメソッドもフィールドもありません。メソッドなどがあるように見えるのは、自動ボックス化で`number`が`Number`オブジェクトに変換されるためです。したがって、`toString`の説明が`Number`オブジェクトのページに書いてあることが腑に落ちます。また、`Number.prototype`が表す意味は「`Number`オブジェクトのインスタンスに生えている」ということも理解できます。\n\n## ラッパーオブジェクトとTypeScriptの型\n\n<!-- textlint-disable prh -->\n\nTypeScriptでは、ラッパーオブジェクトの型も定義されています。次のように、ラッパーオブジェクトの型を使って、型注釈を書くこともできます。ラッパーオブジェクト型の変数にプリミティブ型の値を代入するのも可能です。\n\n```ts twoslash\nconst bool: Boolean = false;\nconst num: Number = 0;\nconst str: String = \"\";\nconst sym: Symbol = Symbol();\nconst big: BigInt = 10n;\n```\n\nしかし、ラッパーオブジェクト型はプリミティブ型に代入できません。\n\n```ts twoslash\n// @errors: 2322\nconst n1: Number = 0;\nconst n2: number = n1;\n```\n\nラッパーオブジェクト型は演算子が使えません。\n\n```ts twoslash\n// @errors: 2362\nconst num: Number = 1;\nnum * 2;\n```\n\nラッパーオブジェクト型は、そのインターフェースを満たしたオブジェクトであれば、プリミティブ型の値以外も代入できます。\n\n```ts twoslash\nconst boolLike = {\n  valueOf(): boolean {\n    return true;\n  },\n};\nconst bool: Boolean = boolLike;\n```\n\nプリミティブ型の代わりに、ラッパーオブジェクト型を型注釈に使う利点はありません。型注釈にはプリミティブ型を使いましょう。\n\n```ts twoslash\n// ❌間違い\nconst num1: Number = 0;\n// ✅正しい\nconst num2: number = 0;\n```\n\n<!-- textlint-enable prh -->\n\n<PostILearned>\n\n・ボックス化とはプリミティブをオブジェクトに変換すること\n・JavaScriptでプリミティブがオブジェクトのように扱えるのは、自動ボックス化のおかげ\n・TypeScriptではラッパーオブジェクト(例:String)よりもプリミティブ型(例:string)で型注釈すべし\n\n</PostILearned>\n\n## 関連情報\n\n[プリミティブ型 (primitive types)](primitive-types.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/boxing"
    },
    {
      "title": "配列のスプレッド構文「...」(spread syntax)",
      "content": "---\nsidebar_label: \"配列のスプレッド構文「...」\"\n---\n\n# 配列のスプレッド構文「...」(spread syntax)\n\nJavaScript の配列ではスプレッド構文「...」を使うことで、要素を展開することができます。\n\n## 配列の作成\n\nある配列に要素を追加して新しい配列を作成する場合に、スプレッド構文を使わない場合は次のようなコードを書く必要があります。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst arr2 = [];\nfor (const item of arr) {\n  arr2.push(item);\n}\narr2.push(4);\n```\n\nスプレッド構文を使用することで、上の実装は次のように簡単に書き直すことができます。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst arr2 = [...arr, 4];\n```\n\nスプレッド構文は配列リテラルの好きな位置に記述できるので、要素と要素の間に他の配列を挿入することもできます。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst arr2 = [0, ...arr, 4];\n```\n\n## 配列のコピー\n\n配列のコピーを作る際に、スプレッド構文が便利な場合があります。スプレッド構文で作成されたコピーは、元の配列とは異なる実体を持ちます。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst backup = [...arr];\narr.push(4); // 変更を加える\nconsole.log(arr);\n// @log: (4) [1, 2, 3, 4]\nconsole.log(backup); // コピーには影響なし\n// @log: (3) [1, 2, 3]\n```\n\n注意点として、この方法は浅いコピー(shallow copy)です。深いコピー(deep copy)ではない点に注意してください。浅いコピーで複製できるのは、1層目の要素だけです。配列の中に配列が入っている場合は、2層目より深くにある配列は、元の配列のものと値を共有します。\n\n```js twoslash\nconst arr = [1, [2, 3]];\nconst backup = [...arr];\narr[1].push(4);\nconsole.log(arr[1]);\n// @log: (3) [2, 3, 4]\nconsole.log(backup[1]); // 変更の影響あり\n// @log: (3) [2, 3, 4]\n```\n\n上記のような浅いコピーの挙動についての詳しい解説はこちらにあります。\n\n[オブジェクトを浅くコピーする](../../../tips/shallow-copy-object.md)\n\nスプレッド演算子と同等の手段として、[配列の`concat()メソッド`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)を用いる方法もあります。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst backup = arr.concat();\narr.push(4); // 変更を加える\nconsole.log(arr);\n// @log: (4) [1, 2, 3, 4]\nconsole.log(backup); // コピーには影響なし\n// @log: (3) [1, 2, 3]\n```\n\n## 配列の連結\n\n配列の連結もスプレッド構文を使用して簡単に書けます。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst concated = [...arr, ...arr2];\n```\n\n## 分割代入と残余パターン\n\n似たシンタックスとして分割代入で使われる残余パターンの構文がありますが、異なる構文なので注意が必要です。\n\n[配列の分割代入](./destructuring-assignment-from-array.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/spread-syntax-for-array"
    },
    {
      "title": "配列をループする方法",
      "content": "---\nimage: /img/how-to-loop-an-array.png\n---\n\n# 配列をループする方法\n\nJavaScript/TypeScriptで配列をループするには、主にfor文、for-of文、配列のメソッドの3つの方法があります。\n\n## for文\n\nfor文は古くからある配列をループする方法です。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(i, arr[i]);\n  // 0 a\n  // 1 b\n  // 2 c の順で出力される\n}\n```\n\n`break`でループを中断できます。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n  if (arr[i] === \"b\") {\n    break;\n  }\n}\n// a b が順に出力されて終了する\n```\n\n`continue`で次のループにスキップできます。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i++) {\n  if (arr[i] === \"a\") {\n    continue;\n  }\n  console.log(arr[i]);\n  // b c が順に出力される\n}\n```\n\n## for-of文\n\nfor-of文は、配列の要素をひとつひとつ処理する場合、for文よりもシンプルに書けるのが特徴です。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\nfor (const value of arr) {\n  console.log(value);\n  // a b cの順で出力される\n}\n```\n\nfor-of文もfor文と同様に、`break`や`continue`が使えます。\n\n[for-of文](../../statements/for-of.md)\n\n## Arrayのメソッド\n\n`Array`には要素ごとに処理を行うメソッドがいくつかあります。\n\n`forEach`メソッドに渡したコールバック関数が、要素ごとに実行されます。`forEach`には戻り値がありません。for文などと異なり、`break`や`continue`は使えません。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\narr.forEach((value, i) => {\n  console.log(value, i);\n  // a 0\n  // b 1\n  // c 2 の順で出力される\n});\n```\n\n`map`メソッドも要素ごとにコールバック関数を実行します。コールバック関数の戻り値が、`map`には戻り値になります。配列要素の値を加工して、別の配列を作るときに便利です。`map`では`break`や`continue`は使えません。\n\n```ts twoslash\nconst arr = [\"a\", \"b\", \"c\"];\nconst arr2 = arr.map((value) => value + value);\nconsole.log(arr2);\n// @log: [ 'aa', 'bb', 'cc' ]\n```\n\n## for-in文は使わない\n\nfor-in文で配列をループすることもできます。しかし、for-in文は配列をループするのには使わないほうがよいです。配列は順番が重要なことが多いですが、for-in文は順番どおりになる保証がないためです。\n\nまた、配列オブジェクトに追加のプロパティがある場合、for-in文はそれも反復処理に含めます。これが予期しない不具合につながる危険性もあります。\n\n```js twoslash\nconst arr = [\"a\", \"b\", \"c\"];\narr.foo = \"bar\"; // 追加のプロパティ\nfor (const x in arr) {\n  console.log(x, arr[x]);\n  // 0 a\n  // 1 b\n  // 2 c\n  // foo bar が順に出力される\n}\n```\n\n<PostILearned>\n\n・TypeScript/JavaScriptで配列をループするには主に3つの方法がある。\n① for文\n② for-of文\n③ 配列のメソッド\n・for文は古くからある構文\n・for-of文はfor文よりもループをシンプルに書ける\n・配列にはforEachやmapメソッドがある\n\n</PostILearned>\n\n## 関連情報\n\n[オブジェクトをループする方法](../object/how-to-loop-an-object.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/how-to-loop-an-array"
    },
    {
      "title": "配列の破壊的操作",
      "content": "# 配列の破壊的操作\n\nJavaScriptの配列メソッドには、破壊的なメソッドと非破壊的なメソッドの2種類があります。特に、破壊的なメソッドは注意深く使う必要があります。\n\n## 非破壊的なメソッド\n\n**非**破壊的なメソッドは、操作に配列の変更をともなわないメソッドです。たとえば、`concat`は非破壊的なメソッドです。これは複数の配列を結合するメソッドです。もとの配列は書き換えず、新しい配列を返します。\n\n```ts twoslash\nconst nums1 = [1, 2];\nconst nums2 = [3, 4];\nconst all = nums1.concat(nums2);\nconsole.log(nums1);\n// @log: [ 1, 2 ]\nconsole.log(nums2);\n// @log: [ 3, 4 ]\nconsole.log(all);\n// @log: [ 1, 2, 3, 4 ]\n```\n\n## 非破壊的なメソッドの一覧\n\n非破壊的なメソッドには次のものがあります。\n\n| メソッド                                                                                                       | 操作                                                                                           |\n| -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |\n| [concat](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)           | 2つ以上の配列を結合した配列を返す                                                              |\n| [find](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/find)               | 提供されたテスト関数を満たす配列内の最初の要素を返す                                           |\n| [findIndex](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)     | 配列内の指定されたテスト関数を満たす最初の要素の位置を返す                                     |\n| [lastIndexOf](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf) | 配列中で与えられた要素が見つかった最後のインデックスを返す                                     |\n| [slice](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)             | 配列の一部を切り出して返す                                                                     |\n| [includes](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)       | 配列に任意の要素が含まれているかを`true`か`false`で返す                                        |\n| [indexOf](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)         | 引数に与えられた内容と同じ内容を持つ最初の配列要素のインデックスを返す                         |\n| [join](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/join)               | 全要素を連結した文字列を返す                                                                   |\n| [keys](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)               | 配列のインデックスをArray Iteratorオブジェクトで返す                                           |\n| [entries](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)         | 配列のインデックスと値のペアをArray Iteratorオブジェクトで返す                                 |\n| [values](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/values)           | 配列の値をArray Iteratorオブジェクトで返す                                                     |\n| [forEach](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)         | 与えられた関数を、配列の各要素に対して一度ずつ実行する                                         |\n| [filter](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)           | 与えられた関数によって実装されたテストに合格したすべての配列からなる新しい配列を返す           |\n| [flat](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)               | すべてのサブ配列の要素を指定した深さで再帰的に結合した新しい配列を返す                         |\n| [flatMap](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)         | 最初にマッピング関数を使用してそれぞれの要素をマップした後、結果を新しい配列内にフラット化する |\n| [map](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map)                 | 与えられた関数を配列のすべての要素に対して呼び出し、その結果からなる新しい配列を返す           |\n| [every](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/every)             | 列内のすべての要素が指定された関数で実装されたテストに合格するかどうかをテストする             |\n| [some](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/some)               | 配列の少なくともひとつの要素が、指定された関数で実装されたテストに合格するかどうかをテストする |\n| [reduce](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)           | 配列のそれぞれの要素に対してユーザーが提供した「縮小」コールバック関数を呼び出す               |\n| [reduceRight](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) | アキュームレーターと配列のそれぞれの値に対して (右から左へ) 関数を適用して、単一の値にする     |\n\n## 破壊的なメソッド\n\n破壊的なメソッドは、配列の内容や配列の要素の順番を変更する操作をともなうメソッドです。たとえば、`push`は破壊的メソッドの1つです。これは、配列末尾に要素を追加します。\n\n```ts twoslash\nconst nums = [1, 2];\nnums.push(3);\nconsole.log(nums);\n// @log: [ 1, 2, 3 ]\n```\n\n## 破壊的なメソッドの一覧\n\n破壊的なメソッドには次のものがあります。\n\n| メソッド                                                                                                     | 操作                                                                                   |\n| ------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- |\n| [push](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)             | 配列の末尾に要素を追加する                                                             |\n| [unshift](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)       | 配列の最初に要素を追加する                                                             |\n| [pop](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)               | 配列から最後の要素を取り除き、その要素を返す                                           |\n| [shift](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)           | 配列から最初の要素を取り除き、その要素を返す                                           |\n| [splice](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)         | 要素を取り除いたり、置き換えたり、新しい要素を追加する                                 |\n| [sort](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)             | 配列の要素をソートする                                                                 |\n| [reverse](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)       | 配列の要素を逆順に並び替える                                                           |\n| [fill](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)             | 開始インデックスから終了インデックスまでのすべての要素を、静的な値に変更した配列を返す |\n| [copyWithin](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin) | サイズを変更せずに、配列の一部を同じ配列内の別の場所にシャローコピーして返す           |\n\n## 特に要注意な破壊的なメソッド\n\n`reverse`メソッドは配列を逆順にした配列を返します。戻り値があるので、一見すると**非**破壊なメソッドに見えなくもありません。しかし、このメソッドは配列の順番も逆にしてしまうので注意が必要です。\n\n```ts twoslash\nconst nums = [1, 2, 3];\nconst newNums = nums.reverse();\nconsole.log(nums);\n// @log: [ 3, 2, 1 ]\nconsole.log(newNums);\n// @log: [ 3, 2, 1 ]\n```\n\nPHPの`array_reverse`関数はJavaScriptの`reverse`メソッドと名前が同じですが、PHPのほうは**非**破壊的な操作です。もとの配列を変更せずに逆順にソートされた配列を新しく生成して返します。\n\n```php title=\"PHPのarray_reverse\"\n$nums = [1, 2, 3];\n$reversedNums = array_reverse($nums);\nvar_dump($nums);\n//=> [1, 2, 3]\nvar_dump($reversedNums);\n//=> [3, 2, 1]\n```\n\nこのように、他の言語では非破壊的な配列操作がJavaScriptでは破壊的操作の場合もあります。メソッド名だけで破壊的か非破壊的かを判断せず、各メソッドの使い方をしっかり確認する必要があります。\n\n## 破壊的なメソッドを安全に使う方法\n\n破壊的なメソッドを**非**破壊的に使うには、破壊的操作を行う前に、配列を別の配列にコピーします。配列のコピーはスプレッド構文`...`を用います。\n\n[スプレッド構文](./spread-syntax-for-array.md)\n\nコピーした配列に対して破壊的操作を行えば、もとの配列が変更される心配が無くなります。\n\n```ts twoslash\nconst original = [1, 2, 3];\nconst copy = [...original]; // コピーを作る\ncopy.reverse();\nconsole.log(original); // 破壊的操作の影響がない\n// @log: [ 1, 2, 3 ]\nconsole.log(copy);\n// @log: [ 3, 2, 1 ]\n```\n\nこの`reverse`の例は、コピーと破壊的なメソッドの呼び出しを1行に短縮して書くこともできます。\n\n```ts twoslash {2}\nconst original = [1, 2, 3];\nconst reversed = [...original].reverse();\nconsole.log(original);\n// @log: [ 1, 2, 3 ]\nconsole.log(reversed);\n// @log: [ 3, 2, 1 ]\n```\n\n<PostILearned>\n\n・JavaScriptの配列メソッドには、破壊的なものと非破壊的なものがある\n・破壊的なものは、配列に変更を加える\n・非破壊的なものは、配列に変更を加えない\n・非破壊に思えるメソッドが実は破壊的なこともあるから要注意\n・配列をコピーしてから破壊的操作をすると安全\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/array-operations"
    },
    {
      "title": "配列はオブジェクト",
      "content": "# 配列はオブジェクト\n\nJavaScriptの配列はオブジェクトです。そのため、比較やコピーの際の挙動に注意が必要です。\n\n## 配列同士の比較\n\n配列の中身が同じでも、オブジェクトのインスタンスが異なると`==`では期待する比較ができないので注意が必要です。\n\n```ts twoslash\nconst list1 = [1, 2, 3];\nconst list2 = [1, 2, 3];\nconsole.log(list1 == list2);\n// @log: false\n```\n\nPHPでは配列(インデックス配列)は要素の内容で等価比較できますが、JavaScriptでは同じようにはできないので注意しましょう。\n\n```php\n<?php\n$list1 = [1, 2, 3];\n$list2 = [1, 2, 3];\nvar_dump($list1 === $list2); //=> bool(true)\n```\n\nこのような配列の中身を比べるための演算子やメソッドはJavaScriptにはないため、中身を比較したいときにはlodashの[isEqual](https://lodash.com/docs/4.17.15#isEqual)などのパッケージを使うのがお勧めです。\n\n## 配列のコピー\n\n配列も他のオブジェクトと同様に、代入を用いても値のコピーにはなりません。代入元の変数と代入先の変数は同じ値を指します。そして、一方の変数だけを変更したつもりでも、他方にも変更が反映されます。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst backup = arr;\narr.push(4); // 変更\nconsole.log(arr);\n// @log: (4) [1, 2, 3, 4]\nconsole.log(backup); // こちらにも影響\n// @log: (4) [1, 2, 3, 4]\n```\n\n上のような単純な配列のコピーには、スプレッド構文を使ってください。\n\n```ts twoslash\nconst arr = [1, 2, 3];\nconst backup = [...arr]; // スプレッド構文\narr.push(4); // 変更\nconsole.log(backup); // 影響なし\n// @log: (4) [1, 2, 3]\n```\n\n[配列のコピー](./spread-syntax-for-array.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/array-as-a-object"
    },
    {
      "title": "配列の共変性 (covariance)",
      "content": "---\nsidebar_label: 配列の共変性\n---\n\n# 配列の共変性 (covariance)\n\nTypeScriptの配列の型は共変(covariant)です。ここでは配列の共変性(covariance)がどのようなものなのか、共変性があるためにどういうことに注意が必要なのか、なぜTypeScriptの配列は共変なのかについて見ていきます。\n\n## 共変とは\n\n型の世界の話で、共変とはその型自身、もしくは、その部分型(subtype)が代入できることを言います。たとえば、Animal型とDog型の2つの型があるとします。DogはAnimalの部分型とします。共変であれば、Animal型の変数にはAnimal自身とその部分型のDogが代入できます。\n\n```ts twoslash\ninterface Animal {\n  isAnimal: boolean;\n}\ninterface Dog extends Animal {\n  isDog: boolean;\n}\n\nlet pochi: Dog = { isAnimal: true, isDog: true };\nlet animal: Animal = pochi; // 代入OK\n```\n\n一方で共変では、Dog型の変数には、DogのスーパータイプであるAnimalは代入できません。\n\n```ts twoslash\ninterface Animal {\n  isAnimal: boolean;\n}\ninterface Dog extends Animal {\n  isDog: boolean;\n}\n// ---cut---\n// @errors: 2741\nlet animal: Animal = { isAnimal: true };\nlet pochi: Dog = animal;\n```\n\n## 配列は共変が許される\n\nTypeScriptの配列型は共変になっています。たとえば、`Animal[]`型の配列に`Dog[]`を代入できます。\n\n```ts twoslash\ninterface Animal {\n  isAnimal: boolean;\n}\ninterface Dog extends Animal {\n  isDog: boolean;\n}\n\nlet pochi: Dog = { isAnimal: true, isDog: true };\nlet animal: Animal = pochi; // 代入OK\n// ---cut---\nconst dogs: Dog[] = [pochi];\nconst animals: Animal[] = dogs; // 代入OK\n```\n\n一見するとこの性質は問題なさそうです。ところが、次の例のように`animals[0]`をAnimal型の値に置き換えると問題が起こります。\n\n```ts twoslash\ninterface Animal {\n  isAnimal: boolean;\n}\ninterface Dog extends Animal {\n  wanwan(): string; // メソッド\n}\n\nconst pochi = {\n  isAnimal: true,\n  wanwan() {\n    return \"wanwan\"; // メソッドの実装\n  },\n};\n\nconst dogs: Dog[] = [pochi];\nconst animals: Animal[] = dogs;\nanimals[0] = { isAnimal: true }; // 同時にdogs[0]も書き換わる\nconst mayBePochi: Dog = dogs[0];\nmayBePochi.wanwan();\n// JS実行時エラー: mayBePochi.wanwan is not a function\n```\n\n変数`animals`に`dogs`を代入した場合、`animals`の変更は`dogs`にも影響します。これはJavaScriptの配列がミュータブルなオブジェクトであるためです。`animals[0]`にAnimal型の値を代入すると、`dogs[0]`もAnimalの値になります。`dogs`は`Dog[]`型なので、型どおりならAnimal型を受け付けないことが望ましいですが、実際はそれができてしまいます。その結果、`dogs[0]`の`wanwan`メソッドを呼び出すところで、メソッドが存在しないというJavaScript実行時エラーが発生します。\n\n型の安全性を突き詰めると、配列は共変であるべきではないです。型がある他の言語のJavaでは、`List<T>`型は共変ではなく非変(invariant)になっています。非変な配列では、その型自身しか代入できないようになり、上のような問題が起こらなくなります。\n\n```java\n// Javaコード\nimport java.util.*;\n\nclass Animal {\n}\n\nclass Dog extends Animal {\n}\n\npublic class Main {\n    static {\n        List<Dog> dogs = new ArrayList<Dog>();\n        List<Animal> animals = dogs;\n        // エラー: 不適合な型: List<Dog>をList<Animal>に変換できません\n    }\n}\n```\n\n上のJavaコードの例では`dogs`を`animals`に代入する段階でコンパイルエラーになります。\n\n## TypeScriptで配列が共変になっている理由\n\n配列が非変である言語がある中、TypeScriptはなぜ型の安全性を犠牲にしてまで配列を共変にしているでしょうか。それはTypeScriptが健全性(soundness)と利便性のバランスを取ること目標にして、型システムを設計しているためです。配列が非変であると健全性は高くなりますが、利便性は下がります。\n\nでは、具体的にどのようなところで不便になるのか、見ていきましょう。込み入った話になるので、段階を踏んで説明していきます。\n\nまず、共変とは、ある型とその部分型が代入できることです。たとえば、`number`型は、ユニオン型の`number | null`型の部分型です。これを配列にした`number[]`型は、`(number | null)[]`型の部分型ということになります。\n\nTypeScriptの配列の型は、共変です。したがって、`number[]`型は`(number | null)[]`型に代入できます。もし、TypeScriptの配列の型が非変なら、`(number | null)[]`型に代入できるのは、それ自身になります。`number[]`は`(number | null)[]`に代入できないことになります。\n\nここまでのことを整理すると次のようになります。\n\n- `number`は`number | null`の部分型\n- `number[]`は`(number | null)[]`の部分型\n- 共変なら、`(number | null)[]`に`number[]`が代入できる\n- 非変なら、`(number | null)[]`に`number[]`は代入できない\n\n次に、ここで話を変えて、次のような関数を考えてみます。\n\n```ts twoslash\nfunction sum(values: (number | null)[]): number {\n  let total = 0;\n  for (const value of values) {\n    if (typeof value === \"number\") {\n      total += value;\n    }\n  }\n  return total;\n}\n```\n\nこの`sum`関数は、`(number | null)[]`、つまり数値とヌルが混在しうる配列を受け取り、数値だけピックアップして、その合計値を返す関数です。関数の引数に代入する場合も、TypeScriptの配列は共変です。共変なので、次のような`number[]`型の値を代入できます。\n\n```ts twoslash\ndeclare function sum(values: (number | null)[]): number;\n// ---cut---\nconst values: number[] = [1, 2, 3];\nsum(values);\n```\n\nもしも、TypeScriptの配列が非変だと、上のようなコードはコンパイルエラーになるでしょう。`sum`関数は、引数に`(number | null)[]`を期待していますが、`number[]`を渡しているからです。そして、そのようなコンパイルエラーを回避しようとしたら、次のような余計な型アサーションを加えたりしないとなりません。\n\n```ts twoslash\ndeclare function sum(values: (number | null)[]): number;\ndeclare const values: number[];\n// ---cut---\nsum(values as (number | null)[]);\n//         ^^^^^^^^^^^^^^^^^型アサーション\n```\n\nこうしたことが随所で起きると、書くのも読むのも不便になります。したがって、TypeScriptでは型の完璧さよりも、利便性を優先しているものと考えられます。\n\nまた、TypeScriptはJavaScriptに型を追加した言語で、根底にはJavaScriptがあります。JavaScriptからTypeScriptに移行するコードもあると思いますが、配列が非変であることを前提に書かれたJavaScriptコードは少ないと思われます。そうした状況もあって、共変を許した可能性もあります。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/array-type-is-covariant"
    },
    {
      "title": "配列の分割代入 (destructuring assignment)",
      "content": "---\nsidebar_label: 配列の分割代入\n---\n\n# 配列の分割代入 (destructuring assignment)\n\n## 配列の分割代入\n\nJavaScriptでは、配列から要素を取り出す方法のひとつに、`array[1]`のようにインデックスでアクセスする方法があります。この方法とは別に、分割代入(destructuring assignment)という方法を使っても、配列要素にアクセスできます。\n\nたとえば、`[1, 2, 3, 4, 5]`のような配列から、最初の3要素を取り出して変数に代入するには次のように書きます。\n\n```ts twoslash\nconst oneToFive = [1, 2, 3, 4, 5];\nconst [one, two, three] = oneToFive;\nconsole.log(one);\n// @log: 1\nconsole.log(two);\n// @log: 2\nconsole.log(three);\n// @log: 3\n```\n\n存在しない要素に対して分割代入した場合は、変数に`undefined`が代入されます。JavaScriptではこれはエラーになりません。\n\n```js twoslash\nconst oneToFive = [1, 2];\nconst [one, two, three] = oneToFive;\nconsole.log(three);\n// @log: undefined\n```\n\nTypeScriptでは、分割代入された値の型は`T[]`の配列なら`T`型になります。たとえば、`number[]`型の`[1, 2, 3, 4, 5]`から分割代入したのなら、型は`number`になります。\n\n```ts twoslash\nconst oneToFive = [1, 2, 3, 4, 5];\nconst [one, two, three] = oneToFive;\nconst num: number = one; // oneはnumber型になるので代入できる\n```\n\nただしTypeScriptのコンパイラーオプション`noUncheckedIndexedAccess`を有効にした場合は異なります。\n\n[noUncheckedIndexedAccess](../../tsconfig/nouncheckedindexedaccess.md)\n\nこのオプション有効状態で、配列`T[]`から分割代入すると`T`型もしくはundefined型を示す`T | undefined`型になります。たとえば、`number[]`型の`[1, 2, 3, 4, 5]`から分割代入したのなら、型は`number | undefined`になります。\n\n```ts twoslash\nconst oneToFive = [1, 2, 3, 4, 5];\nconst [one, two, three] = oneToFive;\nconst num: number = one;\n// 上はコンパイルエラーになる。\n// oneはnumber | undefinedになり、numberには代入できないため。\n```\n\n## ネストした配列の分割代入\n\nJavaScriptの分割代入はフラットな配列だけでなく、ネストした入れ子構造の配列からも要素を抽出できます。ネストした要素の分割代入の書き方は、ネスト構造と一致するようにブラケット(`[ ]`)を重ねます。\n\n```ts twoslash\nconst twoByTwo = [\n  [1, 2],\n  [3, 4],\n];\nconst [[one, two], [three]] = twoByTwo;\nconsole.log(one);\n// @log: 1\nconsole.log(two);\n// @log: 2\nconsole.log(three);\n// @log: 3\n```\n\n## 途中要素の分割代入\n\n配列の分割代入は先頭からでなく、途中の要素を取り出すこともできます。その場合、取り出さない要素の数だけカンマを書きます。\n\n```ts twoslash\nconst oneToFive = [1, 2, 3, 4, 5];\nconst [, , , four, five] = oneToFive;\nconsole.log(four);\n// @log: 4\nconsole.log(five);\n// @log: 5\n```\n\n## 残余部分の代入\n\nJavaScriptの配列を分割代入するときに、残余パターン(`...`)を用いて、配列の残りの部分を取り出して変数に代入できます。\n\n```ts twoslash\nconst oneToFive = [1, 2, 3, 4, 5];\nconst [one, ...rest] = oneToFive;\nconsole.log(one);\n// @log: 1\nconsole.log(rest);\n// @log: [ 2, 3, 4, 5 ]\n```\n\nこのときTypeScriptでは、残余部分の型は配列の`number[]`になります。\n\n## 関連情報\n\n[配列要素へのアクセス](how-to-access-elements-in-an-array.md)\n\n[オブジェクトの分割代入 (destructuring assignment)](../object/destructuring-assignment-from-objects.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/destructuring-assignment-from-array"
    },
    {
      "title": "配列の型注釈 (type annotation)",
      "content": "---\nsidebar_label: 配列の型注釈\n---\n\n# 配列の型注釈 (type annotation)\n\nTypeScriptでは、配列に型注釈する方法が2通りあります。\n\n## Type\\[]\n\n1つ目の型注釈は、要素の型の後ろに`[]`をつける書き方です。たとえば、number型の配列の型注釈は`number[]`と書きます。\n\n```ts twoslash\nlet array: number[];\narray = [1, 2, 3];\n```\n\n## Array&lt;T>\n\n2つ目の型注釈は、`Array<T>`を用いる書き方です。`T`には要素の型を書きます。たとえば、number型の配列の型注釈は`Array<number>`と書きます。\n\n```ts twoslash\nlet array: Array<number>;\narray = [1, 2, 3];\n```\n\n## Type\\[]とArray&lt;T>どちらを使うべきか？\n\nTypeScriptでの配列の型注釈は、`Type[]`と`Array<T>`の2通りあるわけですが、その違いは書き方だけです。コード上の意味、つまり、コンパイラのチェックの内容はどちらも同じです。したがって、どちらの書き方を選ぶかは、書き手の好みになります。ただし、プロジェクトとしてはどちらの書き方にするかは統一しておくべきです。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/type-annotation-of-array"
    },
    {
      "title": "配列要素へのアクセス",
      "content": "# 配列要素へのアクセス\n\n## JavaScriptでの配列要素アクセス\n\nJavaScriptの配列の要素にアクセスするにはブラケット`[]`を使います。ブラケットにはアクセスする要素のインデックス番号を書きます。インデックス番号は0始まりです。たとえば、`abc = [\"a\", \"b\", \"c\"]`の1つ目の要素にアクセスするには、`abc[0]`と書きます。\n\n```js twoslash\nconst abc = [\"a\", \"b\", \"c\"];\nconsole.log(abc[0]);\n// @log: \"a\"\n```\n\nJavaScriptの配列では、存在しないインデックス番号でもアクセスできます。その場合でも、JavaScriptではエラーになりません。得られる値は`undefined`になります。\n\n```js twoslash\nconst abc = [\"a\", \"b\", \"c\"];\nconsole.log(abc[100]);\n// @log: undefined\n```\n\n## TypeScriptの要素の型\n\nTypeScriptでは、`Type[]`型の配列から要素を取り出したとき、その値の型は`Type`になります。たとえば、`string[]`型から0番目の要素の型は`string`になります。\n\n```ts twoslash\nconst abc: string[] = [\"a\", \"b\", \"c\"];\nconst character: string = abc[0];\n```\n\nJavaScriptでは存在しないインデックスで要素アクセスした場合、エラーにならず、代わりに`undefined`が得られると説明しましたが、TypeScriptでも不在要素へのアクセスについて、コンパイラーが警告することはありません。\n\n```ts twoslash\nconst abc = [\"a\", \"b\", \"c\"];\nconst character: string = abc[100]; // エラーにはならない\n```\n\n要素アクセスで得た値は`string`と`undefined`どちらの可能性もありながら、TypeScriptは常にstring型であると考えるようになっています。そのため、要素アクセスで`undefined`が返ってくる場合のエラーはTypeScriptでは発見できず、JavaScript実行時に判明することになります。\n\n```ts twoslash\nconst abc = [\"a\", \"b\", \"c\"];\nconst character: string = abc[100];\nconsole.log(character);\n// @log: undefined\ncharacter.toUpperCase();\n// @error: Cannot read properties of undefined (reading 'toUpperCase')\n```\n\n## TypeScriptで要素アクセスを型安全にする設定\n\nTypeScriptにこの問題を指摘してもらうようにするには、コンパイラーオプションの`noUncheckedIndexedAccess`を有効にします。\n\n[noUncheckedIndexedAccess](../../tsconfig/nouncheckedindexedaccess.md)\n\nこれを有効にすると、たとえば、`string[]`配列から要素アクセスで得た値の型は、string型もしくはundefined型を意味する`string | undefined`になります。\n\n```ts twoslash\nconst abc: string[] = [\"a\", \"b\", \"c\"];\nconst character: string | undefined = abc[0];\ncharacter.toUpperCase();\n// @error: Object is possibly 'undefined'.\n```\n\n`string | undefined`型のままでは`toUpperCase`などのstring型のメソッドは呼び出せません。そこで、if文で変数がstring型だけになるように絞り込みます。すると、string型のメソッドを呼び出してもコンパイルエラーで指摘されることがなくなります。\n\n```ts twoslash\nconst abc: string[] = [\"a\", \"b\", \"c\"];\nconst character = abc[0];\n// 絞り込み条件\nif (typeof character === \"string\") {\n  character.toUpperCase(); // コンパイルエラーにならない\n}\n```\n\n配列要素へのアクセスを安全にするために、`noUncheckedIndexedAccess`を有効にしておくことを推奨します。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/how-to-access-elements-in-an-array"
    },
    {
      "title": "配列リテラル (array literal)",
      "content": "---\nsidebar_label: 配列リテラル\n---\n\n# 配列リテラル (array literal)\n\nJavaScriptでは配列を配列リテラル(array literal)で書けます。配列リテラルはブラケット(`[`、`]`)を用いて書きます。\n\n```js twoslash\n[1, 2, 3];\n```\n\n配列リテラルは要素の区切れ目で改行して書くこともできます。最後の要素にはカンマを書いても構いません。\n\n<!--prettier-ignore-->\n```js twoslash\n[\n  1,\n  2,\n  3,\n]\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/array-literal"
    },
    {
      "title": "読み取り専用の配列 (readonly array)",
      "content": "---\nsidebar_label: 読み取り専用の配列\n---\n\n# 読み取り専用の配列 (readonly array)\n\nTypeScriptでは配列を読み取り専用(readonly)として型注釈できます。型注釈の方法は2通りあります。1つ目は`readonly`キーワードを使う方法です。2つ目は`ReadonlyArray<T>`を使う方法です。\n\n## readonly T\\[]\n\n配列の型注釈`T[]`の前に`readonly`キーワードを添えると、読み取り専用の配列型にできます。たとえば、`readonly number[]`と書くと、その変数の型はnumberの読み取り専用配列型になります。\n\n```ts twoslash\nconst nums: readonly number[] = [1, 2, 3];\n```\n\n## ReadonlyArray&lt;T>\n\n`ReadonlyArray<T>`のような書き方でも読み取り専用の配列型になります。たとえば、要素がnumber型の配列を読み取り専用にしたい場合、`ReadonlyArray<number>`と書きます。\n\n```ts twoslash\nconst nums: ReadonlyArray<number> = [1, 2, 3];\n```\n\n## readonly T\\[]とReadonlyArray&lt;T>の違い\n\n`readonly T[]`と`ReadonlyArray<T>`の違いは書き方以外にありません。どちらを使うかは書き手の好みです。開発チームとしてはどちらの書き方にするかは統一しておいたほうがよいでしょう。\n\n## 読み取り専用配列の特徴\n\n読み取り専用の配列には、配列に対して破壊的操作をする`push`メソッドや`pop`メソッドが、**コンパイル時には無いことに**なります。したがって、`readonly number[]`型の変数`nums`に対して、`nums.push(4)`をするコードはコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2339\nconst nums: readonly number[] = [1, 2, 3];\nnums.push(4);\n```\n\nこれは、破壊的操作系のメソッドを呼び出そうとするコードがTypeScriptコンパイラーに警告されるだけです。配列オブジェクトから`push`メソッドを削除しているわけではありません。なので、JavaScript実行時には`push`メソッドが残っている状態になります。\n\n```ts twoslash\nconst nums: readonly number[] = [1, 2, 3];\nconsole.log(\"push\" in nums);\n// @log: true\n```\n\nメソッドは削除されるわけではないので、コンパイルエラーを無視して実行してみると、読み取り専用型でも配列を書き換えることはできます。\n\n```ts twoslash\nconst nums: readonly number[] = [1, 2, 3];\n// @ts-ignore\nnums.push(4); // 本来コンパイルエラーになるが無視する\nconsole.log(nums);\n// @log: [1, 2, 3, 4]\n```\n\n## 読み取り専用配列を配列に代入する\n\nTypeScriptの読み取り専用配列を普通の配列に代入することはできません。代入しようとするとコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 4104\nconst readonlyNumbers: readonly number[] = [1, 2, 3];\nconst writableNumbers: number[] = readonlyNumbers;\n```\n\nこれは、普通の配列は`push`や`pop`などのメソッドが必要なのに、読み取り専用配列にはそれが無いことになっているためです。どうしても読み取り専用配列を普通の配列に代入したいときは、型アサーション(type assertion)を使う方法があります。\n\n```ts twoslash\nconst readonlyNumbers: readonly number[] = [1, 2, 3];\nconst writableNumbers: number[] = readonlyNumbers as number[];\n//                                                ^^^^^^^^^^^ 型アサーション\n```\n\n[型アサーション「as」(type assertion)](../type-assertion-as.md)\n\n逆のパターンとして、普通の配列を読み取り専用配列に代入することは可能です。\n\n## 関連情報\n\n[配列の破壊的操作](array-operations.md)\n\n[オブジェクト型のreadonlyプロパティ (readonly property)](../object/readonly-property.md)\n\n[Readonly&lt;T>](../../type-reuse/utility-types/readonly.md)\n\n[constアサーション](./../const-assertion.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/array/readonly-array"
    },
    {
      "title": "型推論と動的型付けの違い",
      "content": "# 型推論と動的型付けの違い\n\n型を書かないという意味では、JavaScriptをはじめRubyやPHPなどの動的型付け言語でも同様です。型推論と動的型付けは何が違うのでしょうか？\n\n型推論はコンパイルのタイミングで型が決定され、その型が変更されることはありません。型をプログラマが書くかコンパイラが自動で決めるという点で違いがあり、あくまで静的型付けの世界に閉じた話になります。\n\n次のTypeScriptの例では、変数`x`が型推論により`number`型として決定され、以降は常に`number`型として振舞います。\n\n```ts twoslash title=\"TypeScript\"\n// @errors: 2322 2339\nlet x = 1;\n//  ^?\nx = \"hello\"; // xはnumber型と決定しているのでstring型を代入するとエラー\nconsole.log(x.substring(1, 3));\n```\n\n一方、動的型付けでは実行時に型が決まるので、実行タイミングにより型が変化します。次のJavaScriptの例では、最初に`1`の値が代入され変数`x`の型は`number`型となります。その後、`hello`の文字列を代入することで 変数`x`の型は`string`型に変更されます。このように実行タイミングで型が変化するので、型推論ではエラーになる処理も動的型付け言語では正常に動作します。\n\n```ts title=\"JavaScript\" twoslash\nlet x = 1; // xはnumber型となる\nx = \"hello\"; //x はstring型となる\nconsole.log(x.substring(1, 3));\n// @log: \"el\"\n// @noErrors\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/difference-between-type-inference-and-dynamic-typing"
    },
    {
      "title": "any型",
      "content": "# any型\n\nTypeScriptのany型は、どんな型でも代入を許す型です。プリミティブ型であれオブジェクトであれ何を代入してもエラーになりません。\n\n```ts twoslash\nlet value: any;\nvalue = 1; // OK\nvalue = \"string\"; // OK\nvalue = { name: \"オブジェクト\" }; // OK\n```\n\nまた、any型の変数については、これ以上コンパイラーが型チェックを行いません。実行してみるとエラーになるようなコードでも、コンパイラーはその問題を指摘しません。次の例では、数値を変数`str`に代入しています。しかし、2行目の`toLowerCase`はstring型のメソッドでnumber型には存在しないため、実行してみるとエラーになります。このような単純な矛盾はTypeScriptコンパイラーで発見できますが、型注釈でanyにした値についてはコンパイラーが警告しなくなります。\n\n```ts twoslash\nconst str: any = 123;\nstr.toLowerCase();\n// @error: TypeError: str.toLowerCase is not a function\n```\n\n## 暗黙のany\n\n型を省略してコンテキストから型が推論できない時、TypeScriptは暗黙的に型をany型として扱います。たとえば、引数の型注釈を省略した場合です。\n\n次の例では `name` 変数がany型として判定されるため、型チェックは問題なく通ってしまいます。しかし、number型の値で `toUpperCase()` のメソッドの呼び出しが実行されるため、未定義メソッドとしてエラーが発生します。\n\n```ts twoslash\nfunction hello(name) {\n  //           ^?\n  console.log(`Hello, ${name.toUpperCase()}`);\n}\n\n// @error: name.toUpperCase is not a function\nhello(1);\n// @noImplicitAny: false\n```\n\nこのように暗黙のanyは型チェックをすり抜けて実行時エラーを引き起こす可能性があります。TypeScriptでは暗黙のanyを規制するオプションとして `noImplicitAny` が用意されています。\n\ntsconfig.json にて `noImplicitAny: true` を設定することで、TypeScriptが型をany型と推測した場合にエラーが発生するようになります。\n\n```ts twoslash\n// @errors: 7006\nfunction hello(name) {\n  console.log(`Hello, ${name.toUpperCase()}`);\n}\n```\n\n[noImplicitAny](../tsconfig/noimplicitany.md)\n\n## anyは悪？\n\nany型はコンパイラーのチェックを抑制したいときに用いる特別な型です。any型を濫用すると、型チェックが弱くなりバグの発見できなくなる恐れがあります。anyは型のチェックを放棄した型とも言えますが、一概に悪いとは言い切れません。理由なくanyを使うのは問題ですが、どうしてもanyを使わないとならない場面や、型安全性を妥協した上で、まずは動くコードを形にすることを優先するといったこともありえます。anyをどこまで許容するか、型チェックをどこまで厳格にするかは、チームの熟練度やプロジェクトの方針によるところが大きいです。\n\n## 「がんばらないTypeScript」\n\nTypeScriptは型チェックにより安全にコードを書くことができる静的型付け言語です。\n今までJavaScriptなどの動的型付き言語を書いていた人にとっては、実装時に静的な型を書くことに難しさを感じるかもしれません。\n\n実際に慣れない頃はコンパイルエラーが出ている原因を調べて解消するのに1日を費やす場合もあります。\n\nTypeScriptには「がんばらないTypeScript」というアプローチがあります。\n\nTypeScript の大きな利点として、型の制約を自由にコントロールすることができる点があります。ここで紹介されている any型 もそのひとつです。たとえば、コンパイルエラーで詰まった時に any型 を指定すれば、とりあえずコンパイルエラーを解消することができます。\n\nまた、既存のJavaScriptプロジェクトにTypeScriptを導入する際には大量のコンパイルエラーが発生する可能性があります。それらのコンパイルエラーをすべて解消するまでTypeScriptの導入を終わらせられないと、途中で挫折して結局TypeScriptの導入ができないという状況になるかもしれません。そんな場合は any型 などを積極的に利用して、とりあえずコンパイルエラーを解消して段階的に型付けをしていくのもひとつの手段です。\n\nすべてが型安全な実装になっている状態が理想ですが、一部分だけが型安全な実装になっているだけでも、型チェックがまったくないJavaScriptだけのときよりも大きな恩恵を受けることができます。\n\n型による制約はコードをより安全に書くためのひとつの手段にすぎません。型の制約に時間を費やして、動くモノが作れないのは本末転倒です。\n\nTypeScriptの型システムで疲弊しそうになったら、「がんばらないTypeScript」のアプローチを思い出してみてください。\n\n<PostILearned>\n\n・any型はどんな型でも代入を許す\n・any型は型チェックされない\n・型推論できない変数は暗黙的にany型になる\n・anyは使いようによっては悪くない\n・がんばらないTypeScriptという考え方もある\n\n</PostILearned>\n\n## 関連情報\n\n[🚧unknown型](../statements/unknown.md)\n\n[any vs unknown](../statements/any-vs-unknown.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/any"
    },
    {
      "title": "プリミティブ型 (primitive types)",
      "content": "---\nsidebar_label: プリミティブ型\n---\n\n# プリミティブ型 (primitive types)\n\nJavaScriptのデータ型は、プリミティブ型とオブジェクトの2つに分類されます。\n\n## イミュータブル特性\n\nJavaScriptのプリミティブ型の1つ目の特徴は、値を直接変更できない点です。つまりイミュータブル(immutable)です。一方、オブジェクトには、値を後で変更できるというミュータブル特性(mutable)があります。\n\n## プロパティを持たない\n\nJavaScriptのプリミティブ型の2つ目の特徴は、基本的にプロパティがないことです。プリミティブ型の`null`と`undefined`にはプロパティがありません。\n\n```js\nnull.toString(); // エラーになる\n```\n\nところが、文字列や数値などのプリミティブ型は、プロパティを持ったオブジェクトとして扱えます。\n\n```js\n\"name\".length; // 4\n```\n\nこのように、プリミティブ型をまるでオブジェクトのように扱えるのはJavaScriptの特徴です。JavaScriptには、プリミティブ型をオブジェクトに自動変換する機能があります。この機能はオートボクシング(autoboxing)、自動ボックス化と呼ばれます。\n\n[ボックス化 (boxing)](boxing.md)\n\n## プリミティブ型の種類\n\nプリミティブ型は次の7つがあります。\n\n<!-- textlint-disable prh -->\n\n1. boolean型(論理型): `true`または`false`の真偽値。\n2. number型(数値型): `0`や`0.1`のような数値。\n3. string型(文字列型): `\"Hello World\"`のような文字列。\n4. undefined型: 値が未定義であることを表す型。\n5. null型: 値がないことを表す型。\n6. symbol型(シンボル型): 一意で不変の値。\n7. bigint型(長整数型): `9007199254740992n`のようなnumber型では扱えない大きな整数型。\n<!-- textlint-enable prh -->\n\n上のプリミティブ型以外は、JavaScriptにおいてはすべてオブジェクトと考えて問題ありません。配列や正規表現オブジェクトなどもすべてオブジェクトです。\n\n<PostILearned>\n\n・JSのプリミティブ型はイミュータブルでプロパティを持たない\n・プリミティブをオブジェクトのように扱える「オートボクシング」がある\n・プリミティブは7種類: boolean, number, string, undefined, null, symbol, bigint\n・それ以外は全部オブジェクト\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/primitive-types"
    },
    {
      "title": "Rubyコード",
      "content": "---\nsidebar_label: symbol型\ntitle: symbol型 (シンボル型)\n---\n\nJavaScriptのsymbol型はプリミティブ型の一種で、その値が一意になる値です。boolean型やnumber型は値が同じであれば、等価比較が`true`になります。一方、シンボルはシンボル名が同じであっても、初期化した場所が違うと`false`になります。\n\n```js twoslash\nconst s1 = Symbol(\"foo\");\nconst s2 = Symbol(\"foo\");\nconsole.log(s1 === s1);\n// @log: true\nconsole.log(s1 === s2);\n// @log: false\n```\n\nRubyにもシンボルという名前の型があります。Rubyのシンボルは値さえ同じなら、書いてある場所が異なっても等価比較が`true`になります。\n\n```ruby\n# Rubyコード\ns1 = :foo\ns2 = :foo\np s1 == s2 #=> true\n```\n\n一方、JavaScriptでは前述のとおり、シンボルを初期化した場所で決まるので、Rubyから来た方は注意してください。Rubyのシンボル的なことは、JavaScriptやTypeScriptでは文字列を用いて解決します。\n\n## シンボルの型注釈\n\nTypeScriptでシンボルの型注釈は`symbol`を用います。\n\n```ts twoslash\nconst s: symbol = Symbol();\n```\n\n## シンボルの用途\n\nJavaScriptにシンボルが導入された動機は、JavaScriptの組み込みAPIの下位互換性を壊さずに新たなAPIを追加することでした。要するに、JavaScript本体をアップデートしやすくするために導入されたものです。したがって、アプリケーションを開発する場合に限っては、シンボルを駆使してコードを書く機会はそう多くはありません。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/symbol"
    },
    {
      "title": "typeof演算子 (typeof operator)",
      "content": "---\nsidebar_label: typeof演算子\n---\n\n# typeof演算子 (typeof operator)\n\nJavaScriptの`typeof`演算子では値の型を調べることができます。\n\n```js twoslash\ntypeof true; //=> \"boolean\"\ntypeof 0; //=> \"number\"\ntypeof \"Hello World\"; //=> \"string\"\ntypeof undefined; //=> \"undefined\"\ntypeof null; //=> \"object\"\ntypeof Symbol(); //=> \"symbol\"\ntypeof 1n; //=> \"bigint\"\ntypeof [1, 2, 3]; //=> \"object\"\ntypeof { a: 1, b: 2 }; //=> \"object\"\ntypeof (() => {}); //=> \"function\"\n```\n\n## TypeScriptで`typeof`を使うとifやswitchでその型として使うことができる\n\nTypeScriptでは`typeof`演算子をifやswitchと併せてつかうと、条件と合致したときにその変数をその型として扱えるようになります。次の例は`unknown`型とされた変数`n`が`typeof`演算子によって`string`型であると判別された例です。\n\n```ts twoslash\n// @noErrors\nconst n: unknown = \"\";\n\nif (typeof n === \"string\") {\n  n.toU;\n  //   ^|\n}\n```\n\n## `null`を判別する\n\n`typeof`演算子で特筆すべきなのは、値が`null`の場合です。`typeof null`の演算結果は`\"null\"`ではなく`\"object\"`です。誤解が起きやすい部分なので注意しましょう。特に値がオブジェクトかどうかを判定したいときは、`typeof null`が`\"object\"`になることを意識して書かないと思いがけない不具合になることがあります。\n\n```js twoslash\n// まずい実装\nfunction isObject(value) {\n  return typeof value === \"object\"; // valueがnullになる場合を考慮していない\n}\n\nisObject(null); // 戻り値がtrueになってしまう\n```\n\n`typeof null`を考慮した実装は次のようになります。\n\n```js twoslash\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\n```\n\nここで説明したのはJavaScriptのtypeof演算子です。TypeScriptのtypeof型演算子については、typeof型演算子の説明をご覧ください。\n\n[typeof型演算子](../type-reuse/typeof-type-operator.md)\n\n## 配列を判別する\n\n上記例にもあるとおり、配列を`typeof`にかけると`\"object\"`となります。これは不具合でもなんでもなく、配列はオブジェクトであるのでそのように判別されます。\n\nとはいえそれが配列かどうかを判別する機会は多いため、専用に`Array.isArray()`というメソッドが`Array`オブジェクトにあります。\n\n`Array.isArray()`を使ってtrueの戻り値が帰ってきた場合、その変数は`any[]`型であると判別されます。\n\n```ts twoslash\nconst n: unknown = [];\n\n// ---cut---\nif (Array.isArray(n)) {\n  // n is any[]\n}\n```\n\n`any[]`型を任意の型の配列として判別したい場合は各要素に対して`typeof`や`Array.isArray()`など型を調べる関数を使います。\n\n[unknown](../statements/unknown.md)\n\n[型ガード](../functions/type-guard-functions.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/typeof-operator"
    },
    {
      "title": "boolean型リテラル",
      "content": "---\nsidebar_label: boolean型\ntitle: boolean型 (論理型)\n---\n\nJavaScriptのboolean型は、`true`と`false`の論理値からなる型です。\n\n## boolean型リテラル\n\nJavaScriptのboolean型リテラルは`true`または`false`を用いて次のように書きます。\n\n```ts twoslash\nconst isOk = true;\nconst isPanda = false;\n```\n\n## boolean型の型注釈\n\nTypeScriptのboolean型の型注釈は`boolean`を使います。\n\n```ts twoslash\nconst isOk: boolean = true;\n```\n\nTypeScriptには大文字で始まる`Boolean`型がありますが、これと`boolean`は別の型です。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/boolean"
    },
    {
      "title": "インデックス型 (index signature)",
      "content": "---\nsidebar_label: インデックス型\n---\n\n# インデックス型 (index signature)\n\nTypeScriptで、オブジェクトのフィールド名をあえて指定せず、プロパティのみを指定したい場合があります。そのときに使えるのがこのインデックス型(index signature)です。たとえば、プロパティがすべて`number`型であるオブジェクトは次のように型注釈します。\n\n```ts twoslash\nlet obj: {\n  [K: string]: number;\n};\n```\n\nフィールド名の表現部分が`[K: string]`です。この`K`の部分は型変数です。任意の型変数名にできます。`K`や`key`にするのが一般的です。`string`の部分はフィールド名の型を表します。インデックス型のフィールド名の型は`string`、`number`、`symbol`のみが指定できます。\n\nインデックス型のオブジェクトであれば、フィールド名が定義されていないプロパティも代入できます。たとえば、インデックス型`{ [K: string]: number }`には、値がnumber型であれば、`a`や`b`など定義されていないフィールドに代入できます。\n\n```ts twoslash\nlet obj: {\n  [K: string]: number;\n};\n\nobj = { a: 1, b: 2 }; // OK\nobj.c = 4; // OK\nobj[\"d\"] = 5; // OK\n```\n\nコンパイラーオプションの`noUncheckedIndexedAccess`を有効にした場合、インデックス型では、プロパティの型は自動的にプロパティに指定した型とundefined型のユニオン型になります。これは、プロパティが存在しないときに、値が`undefined`になるのを正確に型で表すためです。\n\n```ts twoslash\nconst obj: { [K: string]: number } = { a: 1 };\nconst b: number | undefined = obj.b;\nconsole.log(b);\n// @log: undefined\n```\n\n[noUncheckedIndexedAccess](../../tsconfig/nouncheckedindexedaccess.md)\n\n## Record&lt;K, T>を用いたインデックス型\n\nインデックス型は`Record<K, T>`ユーティリティ型を用いても表現できます。次の2つの型注釈は同じ意味になります。\n\n```ts twoslash\nlet obj1: { [K: string]: number };\nlet obj2: Record<string, number>;\n```\n\n[Record&lt;Keys, Type>](../../type-reuse/utility-types/record.md)\n\n## 関連情報\n\n[Mapped Types](../../type-reuse/mapped-types.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/index-signature"
    },
    {
      "title": "オブジェクトリテラル (object literal)",
      "content": "---\nsidebar_label: オブジェクトリテラル\n---\n\n# オブジェクトリテラル (object literal)\n\nJavaScriptの特徴はオブジェクトリテラル`{}`という記法を用いて、簡単にオブジェクトを生成できる点です。\n\n```js twoslash\n// 空っぽのオブジェクトを生成\nconst object = {};\n\n// プロパティを指定しながらオブジェクトを生成\nconst person = { name: \"Bob\", age: 25 };\n```\n\nJavaやPHPなどの言語では、オブジェクトを生成するにはまずクラスを定義し、そのクラスを元にインスタンスを作るのが普通ですが、JavaScriptはクラス定義がなくてもこのようにオブジェクトリテラルを書くと、オブジェクトをインラインで作れます。\n\nオブジェクトリテラルがあるおかげで、JavaScriptでは自由度の高いコードが書けるようになっています。\n\n次の例のように、JavaScriptでも`Object`を`new`することでオブジェクトを作ることができます。しかし、オブジェクトリテラルを使ったほうが端的で読みやすいコードになります。\n\n```js twoslash\nconst person = new Object();\nperson.name = \"Bob\";\nperson.age = 25;\n```\n\nちなみに、広く使われるデータシリアライズ形式にJSONがあるのはご存知でしょう。JSONは多くのプログラミング言語で用いられていますが、JSONはJavaScript Object Notationの略で、JSONの由来はJavaScriptのオブジェクトリテラルにあります。そして、JavaScriptではJSONをそのままオブジェクトリテラルとして解釈できます。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/object-literal"
    },
    {
      "title": "オブジェクトのプロパティ",
      "content": "# オブジェクトのプロパティ\n\nJavaScriptのオブジェクトは、プロパティの集合体です。プロパティはキーと値の対です。プロパティの値には、`1`や`\"string\"`のようなプリミティブ型や関数、そして、オブジェクトも入れることができます。\n\n```js twoslash\nconst product = {\n  name: \"ミネラルウォーター\",\n  price: 100,\n  getTaxIncludedPrice: function () {\n    return Math.floor(this.price * 1.1);\n  },\n  shomikigen: new Date(\"2022-01-20\"),\n};\n```\n\n上の`getTaxIncludedPrice`には関数が代入されていますが、この関数は「メソッド」と呼ばれます。メソッドとは、オブジェクトに関連づいた関数のことです。メソッドを定義するには、キーと関数の値に分けて書く方法だけでなく、メソッド定義のための短い構文を使うこともできます。\n\n```js twoslash\nconst object = {\n  // キーと値に分けて書いたメソッド定義\n  printHello1: function () {\n    console.log(\"Hello\");\n  },\n  // 短い構文を用いたメソッド定義\n  printHello2() {\n    console.log(\"Hello\");\n  },\n};\n```\n\nJavaやPHPでは、オブジェクトのフィールドとメソッドははっきり区別されます。一方、JavaScriptではその区別はきっちりしていません。Javaで言うところのメソッドとフィールドは、JavaScriptでは同じように扱われます。たとえば、メソッドに`null`を代入することで、フィールドに変えてしまうこともできます。\n\n```js twoslash\nconst calculator = {\n  sum(a, b) {\n    return a + b;\n  },\n};\n\ncalculator.sum(1, 1);\n// @log: 2\ncalculator.sum = null;\ncalculator.sum(1, 1); // ここではもうメソッドではないので、呼び出すとエラーになります\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/properties-of-objects"
    },
    {
      "title": "余剰プロパティチェック (excess property checking)",
      "content": "---\nsidebar_label: 余剰プロパティチェック\n---\n\n# 余剰プロパティチェック (excess property checking)\n\nTypeScriptのオブジェクトの型には余剰プロパティチェック(excess property checking)という、追加のチェックが働く場合があります。余剰プロパティチェックとは、オブジェクトの型に存在しないプロパティを持つオブジェクトの代入を禁止する検査です。\n\nたとえば、`{ x: number }`はプロパティ`x`が必須なオブジェクトの型です。この型に`{ x: 1, y: 2 }`のような値を代入しようとします。この代入は許可されるでしょうか。代入値の型は、必須プロパティの`{ x: number }`を満たしているので問題なさそうです。ところが、この代入は許可されません。\n\n```ts twoslash\n// @errors: 2353\nlet onlyX: { x: number };\nonlyX = { x: 1 }; // OK\nonlyX = { x: 1, y: 2 }; // コンパイルエラー\n```\n\nこのとき、「Object literal may only specify known properties, and 'y' does not exist in type '{ x: number; }'.」というコンパイルエラーが発生します。なぜこれがコンパイルエラーになるかというと、`{ y: 2 }`が余計だと判断されるからです。こうした余計なプロパティを許さないTypeScriptのチェックが余剰プロパティチェックなのです。\n\n## 余剰プロパティチェックはオブジェクトリテラルだけを検査する\n\n余剰プロパティチェックはオブジェクトの余計なプロパティを禁止するため、コードが型に厳密になるよう手助けをします。しかし、余剰プロパティチェックが効くのは、オブジェクトリテラルの代入に対してのみです。なので、変数代入にはこのチェックは働きません。\n\n```ts twoslash\nconst xy: { x: number; y: number } = { x: 1, y: 2 };\nlet onlyX: { x: number };\nonlyX = xy; // OK\n```\n\n変数代入にも余剰プロパティチェックが働いたほうが良さそうと思われるかもしれません。型が厳密になるからです。しかし、そうなっていないのは、TypeScriptが型の安全性よりも利便性を優先しているためです。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/excess-property-checking"
    },
    {
      "title": "object型、Object型、{}型の違い",
      "content": "---\ntitle: object、Object、{}の違い\nimage: /img/difference-among-object-and-object.png\n---\n\nTypeScriptではオブジェクトの型注釈をするとき、プロパティの型まで指定するのが一般的です。\n\n```ts twoslash\nlet obj: { a: number; b: number };\n```\n\n[オブジェクトの型注釈 (type annotation)](type-annotation-of-objects.md)\n\nそういった一般的な型注釈とは異なり、プロパティの型を指定せず、ざっくり「オブジェクトであること」を型注釈する方法もあります。`object`型や`Object`型、`{}`型を使うものです。\n\n```ts twoslash\nlet a: object;\nlet b: Object;\nlet c: {};\n```\n\nこれらはどれもオブジェクトの型の値ならどんなものでも代入可能になる型です。\n\n```ts twoslash\nconst a: object = {}; // OK\nconst b: Object = {}; // OK\nconst c: {} = {}; // OK\n```\n\n<!-- textlint-disable prh -->\n\n## object型、Object型、{}型の違い\n\n<!-- textlint-enable prh -->\n\n`object`型や`Object`型、`{}`型の3つは類似する部分がありますが、`object`型と他の2つは異なる点があります。\n\n### object型\n\n`object`型はオブジェクトだけが代入できる型です。JavaScriptの値はプリミティブ型かオブジェクトの2つに大分されるので、`object`型はプリミティブ型が代入できない型とも言えます。\n\n```ts twoslash\n// @errors: 2322\nlet a: object;\na = { x: 1 }; // OK\na = [1, 2, 3]; // OK。配列はオブジェクト\na = /a-z/; // OK。正規表現はオブジェクト\n\n// プリミティブ型はNG\na = 1;\na = true;\na = \"string\";\n```\n\n[プリミティブ以外はすべてオブジェクト](non-primitives-are-objects.md)\n\n<!-- textlint-disable prh -->\n\n### Object型\n\n<!-- textlint-enable prh -->\n\n`Object`型はインターフェースです。`valueOf`などのプロパティを持つ値なら何でも代入できます。したがって、`Object`型には`null`や`undefined`を除くあらゆるプリミティブ型も代入できます。string型やnumber型などのプリミティブ型は自動ボックス化により、オブジェクトのようにプロパティを持てるからです。\n\n```ts twoslash\n// @errors: 2322\nlet a: Object;\na = {}; // OK\n\n// ボックス化可能なプリミティブ型OK\na = 1; // OK\na = true; // OK\na = \"string\"; // OK\n\n// nullとundefinedはNG\na = null;\na = undefined;\n```\n\n[ボックス化 (boxing)](../boxing.md)\n\n`Object`型は[TypeScriptの公式ドキュメントで使うべきでないとされています](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#number-string-boolean-symbol-and-object)。理由はプリミティブ型も代入できてしまうためです。もしオブジェクトならなんでも代入可にしたい場合は、代わりに`object`型を検討すべきです。\n\n### {}型\n\n`{}型`は、プロパティを持たないオブジェクトを表す型です。プロパティを持ちうる値なら何でも代入できます。この点は`Object`型と似ていて、`null`や`undefined`を除くあらゆる型を代入できます。\n\n```ts twoslash\n// @errors: 2322\nlet a: {};\na = {}; // OK\n\n// ボックス化可能なプリミティブ型OK\na = 1; // OK\na = true; // OK\na = \"string\"; // OK\n\n// nullとundefinedはNG\na = null;\na = undefined;\n```\n\n<!-- textlint-disable prh -->\n\n### object型、Object型、{}型の代入範囲\n\n<!-- textlint-enable prh -->\n\n`object`型や`Object`型、`{}`型の代入範囲をまとめると次の図のようになります。\n\n![](difference-among-object-and-object/image1.png)\n\n<!-- textlint-disable prh -->\n<PostILearned>\n\nTypeScriptにはよく似た型にobject、Object、{}がある。どれも「オブジェクト」を指す型。\n\n✅object、Object、{}の違い\n1️⃣object型: オブジェクトのみ代入可能\n2️⃣Object型、{}型: オブジェクトとnull、undefinedを除くプリミティブ型が代入可能\n\n</PostILearned>\n\n<!-- textlint-enable prh -->\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/difference-among-object-and-object"
    },
    {
      "title": "オブジェクトの型のオプションプロパティ (optional property)",
      "content": "---\nsidebar_label: オブジェクト型のオプションプロパティ\n---\n\n# オブジェクトの型のオプションプロパティ (optional property)\n\nTypeScriptで、オブジェクトプロパティのオプショナルを型付けするには、プロパティ名の後ろに`?`を書きます。\n\n```ts twoslash\nlet size: { width?: number };\n```\n\nオプションプロパティを持ったオブジェクトの型には、そのオプションプロパティを持たないオブジェクトを代入できます。\n\n```ts twoslash\nlet size: { width?: number };\n// ---cut---\nsize = {}; // OK\n```\n\nまた、オプションプロパティの値が`undefined`のオブジェクトも代入できます。\n\n```ts twoslash\nlet size: { width?: number };\n// ---cut---\nsize = { width: undefined }; // OK\n```\n\nしかし、オプションプロパティの値が`null`の場合は代入できません。\n\n```ts twoslash\n// @errors: 2322\nlet size: { width?: number };\n// ---cut---\nsize = { width: null };\n```\n\n## 関連情報\n\n[オプショナルチェーン (optional chaining)](optional-chaining.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/optional-property"
    },
    {
      "title": "プリミティブ以外はすべてオブジェクト",
      "content": "# プリミティブ以外はすべてオブジェクト\n\nJavaScriptでは、プリミティブ型以外のものはすべてオブジェクトです。オブジェクトには、クラスから作ったインスタンスだけでなく、クラスそのものや配列、正規表現もあります。\n\nプリミティブ型は値が同じであれば、同一のものと判定できますが、オブジェクトはプロパティの値が同じであっても、インスタンスが異なると同一のものとは判定されません。\n\n```js twoslash\nconst value1 = 123;\nconst value2 = 123;\nconsole.log(value1 == value2);\n// @log: true\n\nconst object1 = { value: 123 };\nconst object2 = { value: 123 };\nconsole.log(object1 == object2);\n// @log: false\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/non-primitives-are-objects"
    },
    {
      "title": "readonlyとconstの違い",
      "content": "# readonlyとconstの違い\n\nJavaScriptでは、`const`で宣言した変数は代入不可になります。TypeScriptではオブジェクトの型のプロパティに`readonly`修飾子をつけると、そのプロパティが代入不可になります。これら2つの機能は「代入不可」という点では似ています。ではこれらの違いは何でしょうか。\n\n## constは変数への代入を禁止にするもの\n\n`const`は変数への代入を禁止するものです。たとえば、`const`で宣言されたxに値を代入しようとすると、TypeScriptではコンパイルエラーになり、JavaScriptでは実行時エラーになります。\n\n```ts twoslash\n// @errors: 2588\nconst x = 1;\nx = 2;\n```\n\n`const`の代入禁止が効くのは変数そのものへの代入だけです。変数がオブジェクトだった場合、プロパティへの代入は許可されます。\n\n```ts twoslash\n// @errors: 2588\nconst x = { y: 1 };\nx = { y: 2 }; // 変数そのものへの代入は不可\nx.y = 2; // プロパティへの代入は許可\n```\n\n## readonlyはプロパティへの代入を禁止にするもの\n\nTypeScriptの`readonly`はプロパティへの代入を禁止するものです。たとえば、`readonly`がついたプロパティxに値を代入しようとすると、コンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2540\nlet obj: { readonly x: number } = { x: 1 };\nobj.x = 2;\n```\n\n一方、変数自体への代入は許可されます。\n\n```ts twoslash\nlet obj: { readonly x: number } = { x: 1 };\nobj = { x: 2 }; // 許可される\n```\n\n## constとreadonlyの違い\n\n`const`は変数自体を代入不可するものです。変数がオブジェクトの場合、プロパティへの代入は許可されます。一方、`readonly`はプロパティを代入不可にするものです。変数自体を置き換えるような代入は許可されます。以上の違いがあるため、`const`と`readonly`を組み合わせると、変数自体とオブジェクトのプロパティの両方を変更不能なオブジェクトを作ることができます。\n\n```ts twoslash\n// @errors: 2588 2540\nconst obj: { readonly x: number } = { x: 1 };\nobj = { x: 2 };\nobj.x = 2;\n```\n\n## 関連情報\n\n[変数宣言: letとconst](../let-and-const.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/readonly-vs-const"
    },
    {
      "title": "Shorthand property names",
      "content": "# Shorthand property names\n\nオブジェクトのキーと変数名が同じ時にかぎり、オブジェクトに値を代入するときも同様にShorthand property namesを使うことができます。これも分割代入と調べると情報を得られることがあります。次の例がほぼすべてです。\n\n```ts twoslash\nimport fs from \"fs\";\n// ---cut---\ntype Wild = {\n  name: string;\n  no: number;\n  genre: string;\n  height: number;\n  weight: number;\n};\n\nconst name = \"pikachu\";\nconst no = 25;\nconst genre = \"mouse pokémon\";\nconst height = 0.4;\nconst weight = 6.0;\n\nconst pikachu: Wild = {\n  name,\n  no,\n  genre,\n  height,\n  weight,\n};\n```\n\n要するにこちらの省略型です。\n\n```ts twoslash\nimport fs from \"fs\";\n\ntype Wild = {\n  name: string;\n  no: number;\n  genre: string;\n  height: number;\n  weight: number;\n};\n\nconst name = \"pikachu\";\nconst no = 25;\nconst genre = \"mouse pokémon\";\nconst height = 0.4;\nconst weight = 6.0;\n// ---cut---\nconst pikachu: Wild = {\n  name: name,\n  no: no,\n  genre: genre,\n  height: height,\n  weight: weight,\n};\n```\n\nもちろん一行で書くこともできます。\n\n```ts twoslash\nimport fs from \"fs\";\n\ntype Wild = {\n  name: string;\n  no: number;\n  genre: string;\n  height: number;\n  weight: number;\n};\n\nconst name = \"pikachu\";\nconst no = 25;\nconst genre = \"mouse pokémon\";\nconst height = 0.4;\nconst weight = 6.0;\n// ---cut---\nconst pikachu: Wild = { name, no, genre, height, weight };\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/shorthand-property-names"
    },
    {
      "title": "プロトタイプベース",
      "content": "# プロトタイプベース\n\nここではJavaScriptのプロトタイプベースの概要を説明します。JavaやPHPなどでクラスを使ったことがある方や、オブジェクト指向プログラミングに触れたことがある方を念頭に書いています。また、ここでは主に次の疑問に答えていきます。\n\n- プロトタイプベースとはどのような考え方なのか？\n- プロトタイプベースのJavaScriptは、クラスベースのPHPやJavaとどんなところが違う？\n- なぜJavaScriptはプロトタイプベースを採用したのか？\n- プロトタイプベースの利点は何か？\n\n## オブジェクトの生成\n\nオブジェクト指向プログラミング(OOP)では、オブジェクトを扱います。オブジェクトを扱う以上は、オブジェクトを生成する必要があります。\n\nしかし、オブジェクトの生成方式は、OOPで統一的な決まりはありません。言語によって異なるのです。言語によりオブジェクト生成の細部は異なりますが、生成方法は大きく分けて「クラスベース」と「プロトタイプベース」があります。\n\n## クラスベースとは\n\nJavaやPHP、Ruby、Pythonなどはクラスベースに分類されます。クラスベースでのオブジェクト生成は、オブジェクトの設計図である「クラス」を用います。クラスに対して`new`演算子を用いるなどして得られるのがオブジェクトであり、クラスベースの世界では、それを「インスタンス」と呼びます。\n\nたとえば、ボタンのオブジェクトがほしいときは、まずその設計図となるボタンクラスを作ります。\n\n```js twoslash\nclass Button {\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\nその上で、ボタンクラスに対して`new`演算子を用いると、ボタンオブジェクトが得られます。\n\n```js twoslash\nclass Button {\n  constructor(name) {\n    this.name = name;\n  }\n}\n// ---cut---\nconst dangerousButton = new Button(\"絶対に押すなよ?\");\n```\n\nこのような言語がクラスベースと言われるのは、オブジェクトの素となるのがクラスだからです。\n\n## プロトタイプベースとは\n\n一方のJavaScriptのオブジェクト生成はプロトタイプベースです。プロトタイプベースの特徴は、クラスのようなものが無いところです。(あったとしてもクラスもオブジェクトの一種だったりと特別扱いされていない)\n\nクラスベースではオブジェクトの素となるものはクラスでした。プロトタイプベースには、クラスがありません。では、何を素にしてオブジェクトを生成するのでしょうか。答えは、「オブジェクトを素にして新しいオブジェクトを生成する」です。\n\nたとえば、JavaScriptでは既存のオブジェクトに対して、`Object.create()`を実行すると新しいオブジェクトが得られます。\n\n```js twoslash\nconst button = {\n  name: \"ボタン\",\n};\n\nconst dangerousButton = Object.create(button);\ndangerousButton.name = \"絶対に押すなよ？\";\n```\n\n上の例の`button`と`dangerousButton`は異なるオブジェクトになります。その証拠に、それぞれの`name`プロパティは値が異なります。\n\n```js twoslash\nconsole.log(button.name);\n// @log: \"ボタン\"\nconsole.log(dangerousButton.name);\n// @log: \"絶対に押すなよ？\"\n```\n\n「プロトタイプ」とは日本語では「原型」のことです。プロトタイプベースは単純に言ってしまえば、原型となるオブジェクトを素にオブジェクトを生成するアプローチなのです。\n\n:::info\n\n### コラム: プロトタイプベースは直感的でない？\n\nこの本の読者の多くは、PHPやJavaなどクラスベースの言語に馴染みが深いかと思います。その立場からすると、プロトタイプベースは直感的でないと感じるかもしれません。ところが、日常生活で私たちはプロトタイプベース的な活動をしていることがあります。ここでは、プロトタイプベースが少しでも身近に感じられるよう、ちょっとした例え話をしたいと思います。\n\n仕事などで書類を作成することはないでしょうか。会議の議事録、テスト仕様書、報告書、経費精算書…。いろいろあると思います。中には定期的、または不定期に同じような書類を何度か作ることもあるでしょう。みなさんは繰り返しのペーパーワークをどうこなしていますか。\n\n準備のいい人は、雛形を作っておくことでしょう。雛形とは、いつも変わらない部分は埋めておき、毎度内容が変わる部分は空欄にした文書のことです。いざ書類が必要になったときは、雛形をベースに穴埋めすれば書類ができます。このやり方はクラスベースに似ています。クラスはそのままでは使えませんが、インスタンス化すると使えます。書類の雛形もそのままでは提出できませんが、穴埋めすれば役立ちます。\n\n一方で、書類の準備の時間がないときや、準備のモチベーションが上がらないときは、雛形までは作らないかもしれません。それでも、前回使った書類があれば、それを複製して今回必要になることに合わせて内容を加筆したり、置き換えたりして仕上げてしまうことはありませんでしょうか。このアプローチはプロトタイプベースに似ています。プロトタイプとなるオブジェクトはそれ自身も使えますし、それを素にした新しいオブジェクトももちろん使えます。前回使った書類はそれ自身で役に立っていますが、それを複製して作った新しい書類も役に立ちます。\n\n:::\n\n## 継承\n\n継承についても、クラスベースとプロトタイプベースでは異なる特徴があります。クラスベースでは、継承するときは`extends`キーワードなどを用いてクラスからクラスを派生させ、派生クラスからオブジェクトを生成する手順を踏みます。\n\nでは上の手順を具体的なコードで確認してみましょう。ここに`Counter`クラスがあります。\n\n```js twoslash\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  countUp() {\n    this.count++;\n  }\n}\n```\n\nこのクラスは数とそれをカウントアップする振る舞いを持っています。この`Counter`クラスを継承して、リセット機能を持った派生クラスは次の`ResettableCounter`クラスになります。\n\n```js twoslash\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  countUp() {\n    this.count++;\n  }\n}\n// ---cut---\nclass ResettableCounter extends Counter {\n  reset() {\n    this.count = 0;\n  }\n}\n```\n\nこの`ResettableCounter`クラスを使うには、このクラスに対して`new`演算子でオブジェクトを生成します。\n\n```js twoslash\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  countUp() {\n    this.count++;\n  }\n}\n\nclass ResettableCounter extends Counter {\n  reset() {\n    this.count = 0;\n  }\n}\n// ---cut---\ncounter = new ResettableCounter();\ncounter.countUp();\ncounter.reset();\n```\n\n以上の例でもわかるとおり、クラスベースでの継承とオブジェクトの生成は`extends`と`new`といった異なる言語機能になっていることが多いです。\n\n一方、プロトタイプベースのJavaScriptでは、継承もオブジェクトの生成と同じプロセスで行います。次の例は、`counter`オブジェクトを継承した`resettableCounter`オブジェクトを作っています。\n\n```js twoslash\nconst counter = {\n  count: 0,\n  countUp() {\n    this.count++;\n  },\n};\n\nconst resettableCounter = Object.create(counter);\nresettableCounter.reset = function () {\n  this.count = 0;\n};\n```\n\n継承と言ってもプロトタイプベースでは、クラスベースの`extends`のような特別な仕掛けがあるわけではなく、「既存のオブジェクトから新しいオブジェクトを作る」というプロトタイプベースの仕組みを継承に応用しているにすぎません。\n\n## クラスベース風にも書けるJavaScript\n\nここまでの説明で、クラスベースに慣れ親しんだ読者の中には「JavaScriptでオブジェクト指向プログラミングをしようとすると、随分と独特な書き方になるんだな」と思った方がいるかもしれません。ここで誤解して欲しくないのが、プロトタイプベースのJavaScriptでもクラスのような書き方ができるようになっていることです。\n\n古いJavaScriptには確かにクラスの構文がなく独特の書き方がありましたが、ES2015に`class`や`extends`構文が導入されたため、近年のJavaScriptではクラスベース風の書き方が容易にできるようになっています。なので、クラスベースの他言語から来た開発者にも、JavaScriptコードは理解しやすいものになってきています。次のコードはクラスベースの説明の際に提示したものですが、実はこれはJavaScriptでした。\n\n```js twoslash\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  countUp() {\n    this.count++;\n  }\n}\n```\n\n`class`構文が使える近年のJavaScript開発では、`Object.create`を多用したり、無理にプロトタイプベースを意識したコードにする必要もそうそう無いので心配しないでください。ただ、`class`構文があると言っても、JavaScriptがクラスベースに転向したのではなく、クラスベース風の書き方ができるにすぎません。かくいう`class`構文もプロトタイプベースの仕組みの上に成り立っており、JavaScriptのオブジェクトモデルはプロトタイプベースなので、この点は頭の片隅に入れておく必要があります。\n\n## なぜJavaScriptはプロトタイプベースなのか？\n\nJavaScriptが採用しているプロトタイプベースがどのようなものなのか見てきました。では、なぜJavaScriptはクラスベースではなくプロトタイプベースを選んだのでしょうか。プロトタイプベースにした狙いとは何だったのでしょうか。\n\nJavaScriptの開発には次のような要件がありました。ブラウザで動く言語で、構文はJava風に。しかし、Javaほど大掛かりでないようにと。そして、開発期間はというと、10日と逼迫したものでした。\n\nクラスベースの言語を作るのは、プロトタイプベースの言語を作るより難しいと言われています。JavaScriptを作るのに与えられた時間は非常に少ないものでしたから、工数削減にもプロトタイプベースは一役買ったことでしょう。\n\nJavaに似せよと言われて作られたJavaScript。Javaはクラスベースですが、JavaScriptはプロトタイプベースです。では、JavaScriptは泣く泣くクラスベースを諦めたのでしょうか。実はそうではありません。JavaScriptの作者であるBrendan Eich氏は[後のインタビュー](https://learning.oreilly.com/library/view/coders-at-work/9781430219484/Chapter04.html)で次のように語っています。\n\n> **Seibel**: So you wanted to be like Java, but not too much.\n> (Javaのようにしたいけれど、大掛かりはしたくなかったわけですね。)\n>\n> **Eich**: Not too much. If I put classes in, I'd be in big trouble. Not that I really had time to, but that would've been a no-no.\n> (そうですね。もしクラスを取り入れていたら、大変なことになっていたでしょう。時間がなかったのは確かですが、時間があったとしてもクラスはいやですね。)\n\nJavaScriptはクラスベースにするつもりはハナからなかったわけです。Eich氏はJavaScriptを設計するにあたって、できるだけ言語をシンプルにしたいと考えていたようです。JavaScriptはプリミティブ型の種類が少なかったり、プリミティブ型もオブジェクトのようにメソッドが使えるようになっていてプリミティブとオブジェクトの間に大きな隔たりが無かったりします。こうした言語設計もシンプルさを目指したからだそうです。\n\nJavaScriptの開発にあたり、Selfという言語の影響があったとEich氏は言います。Selfは1990年に発表されたプロトタイプベースのオブジェクト指向言語です。Selfの発表論文に掲げられたタイトルは「The Power of Simplicity」つまり「シンプルさの力」です。Selfはクラスを用いたオブジェクト指向プログラミングよりも、プロトタイプベースのほうが言語が単純化されると同時に柔軟になると主張しました。Selfはクラスだけでなく、関数と値の区別や、メソッドとフィールドの区別も撤廃したシンプルさを追求した言語です。言語は単純になると、言語の説明も簡単になり学びやすくもなります。シンプルにするために継承やクラスを諦めたかというとそうではなく、逆に柔軟さが生まれるので、クラスのようなものや継承もプロトタイプを応用すれば実現できるとSelfは主張しています。\n\nこれはあくまでSelfの意見でJavaScriptが明言したわけではありませんが、歴史の文脈から読み取るに、JavaScriptもSelfの考え方に共感してプロトタイプベースを採用したのは明らかです。JavaScriptのプロトタイプベース採用の背景には、言語をシンプルで柔軟なものにしたいという考えが根底にあったわけです。\n\nJavaScriptがプロトタイプベースを採用したことで、実際に柔軟なプログラミングが行えるようになっています。その一例として、プロトタイプを応用してクラス風のオブジェクト指向を実現するイディオムが生まれ、それが`class`構文として言語仕様に取り込まれたり、プロトタイプをプログラマが拡張することで古い実行環境でも最新バージョンのJavaScriptのメソッドが使えるようにするポリフィルが誕生してきました。\n\n## まとめ\n\n- クラスベースは、クラスをもとに新しいオブジェクトを生成するスタイル。JavaやPHPなどが該当。\n- プロトタイプベースは、既存のオブジェクトから新しいオブジェクトを生成するスタイル。JavaScriptが該当。\n- プロトタイプベースでの継承は、特別な操作ではなく、オブジェクト生成とまったく同じプロセスである。\n- JavaScriptでも`class`構文を使えばクラスベース風のプログラミングが可能。\n- JavaScriptがプロトタイプベースを採用したのは、言語をシンプルで柔軟なものにするのが狙い。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/prototype-based-programming"
    },
    {
      "title": "オブジェクトをループする方法",
      "content": "# オブジェクトをループする方法\n\nJavaScript・TypeScriptでオブジェクトのプロパティをループする方法を説明します。\n\n## for-in文\n\nJavaScriptでオブジェクトをループする古くからある方法はfor-in文を使うものです。\n\n```js twoslash\nconst foo = { a: 1, b: 2, c: 3 };\nfor (const prop in foo) {\n  console.log(prop, foo[prop]);\n  // a 1\n  // b 2\n  // c 3 の順で出力される\n}\n```\n\n## for-in文では`hasOwnProperty`を使おう\n\nJavaScriptのオブジェクトには元になるプロトタイプがあります。たとえば、オブジェクトリテラルであれば、`Object.prototype`がプロトタイプになります。\n\n```js twoslash\nconst foo = { a: 1, b: 2, c: 3 };\nconsole.log(Object.getPrototypeOf(foo) === Object.prototype);\n// @log: true\n```\n\n`Object.prototype`を変更するとその影響は、このプロトタイプを持つすべてのオブジェクトに影響します。\n\n```js twoslash\nconst foo = { a: 1 };\nconst date = new Date();\nconst arr = [1, 2, 3];\n\n// どのオブジェクトもhiプロパティが無いことを確認\nconsole.log(foo.hi, date.hi, arr.hi);\n// @log: undefined undefined undefined\n\n// プロトタイプにプロパティを追加する\nObject.prototype.hi = \"Hi!\";\n\n// どのオブジェクトもhiプロパティを持つようになる\nconsole.log(foo.hi, date.hi, arr.hi);\n// @log: Hi! Hi! Hi!\n```\n\nfor-in文はプロトタイプのプロパティも含めてループする仕様があります。そのため、プロトタイプが変更されると、意図しないところでfor-inのループ回数が変わることがあります。\n\n```js twoslash\nconst foo = { a: 1, b: 2, c: 3 };\nObject.prototype.hi = \"Hi!\";\nfor (const prop in foo) {\n  console.log(prop, foo[prop]);\n  // a 1\n  // b 2\n  // c 3\n  // hi Hi! の順で出力される\n}\n```\n\nしたがって、for-inで反復処理を書く場合は、`hasOwnProperty`でプロパティがプロトタイプのものでないことをチェックしたほうが安全です。\n\n```js twoslash\nconst foo = { a: 1, b: 2, c: 3 };\nObject.prototype.hi = \"Hi!\";\nfor (const prop in foo) {\n  if (Object.prototype.hasOwnProperty.call(foo, prop)) {\n    console.log(prop, foo[prop]);\n    // a 1\n    // b 2\n    // c 3  の順で出力される\n  }\n}\n```\n\n## `Object.entries`\n\n`Object.entries`の戻り値をfor-of文でループする方法もあります。\n\n```ts twoslash\n// @target: es2017\nconst foo = { a: 1, b: 2, c: 3 };\nfor (const [key, value] of Object.entries(foo)) {\n  console.log(key, value);\n  // a 1\n  // b 2\n  // c 3 の順で出力される\n}\n```\n\nfor-in文と異なり、`hasOwnProperty`のチェックが不要です。\n\n## `Object.keys`\n\nプロパティのキーだけを反復処理する場合は、`Object.key`の戻り値をfor-of文でループする方法があります。\n\n```ts twoslash\n// @target: es2017\nconst foo = { a: 1, b: 2, c: 3 };\nfor (const key of Object.keys(foo)) {\n  console.log(key);\n  // a\n  // b\n  // c の順で出力される\n}\n```\n\nfor-in文と異なり、`hasOwnProperty`のチェックが不要です。\n\n## `Object.values`\n\nプロパティの値だけを反復処理する場合は、`Object.values`の戻り値をfor-of文でループする方法があります。\n\n```ts twoslash\n// @target: es2017\nconst foo = { a: 1, b: 2, c: 3 };\nfor (const value of Object.values(foo)) {\n  console.log(value);\n  // 1\n  // 2\n  // 3 の順で出力される\n}\n```\n\nfor-in文と異なり、`hasOwnProperty`のチェックが不要です。\n\n<PostILearned>\n\nJavaScriptやTypeScriptのオブジェクトプロパティをループするには次の方法がある。\n\n1️⃣ for-in文\n2️⃣ for-of文 + Object.entries()\n3️⃣ for-of文 + Object.keys()\n4️⃣ for-of文 + Object.values()\n\n⚠️ for-in文はhasOwnPropertyのチェックが必要。\n\n</PostILearned>\n\n## 関連情報\n\n[配列をループする方法](../array/how-to-loop-an-array.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/how-to-loop-an-object"
    },
    {
      "title": "オブジェクトの型注釈 (type annotation)",
      "content": "---\nsidebar_label: オブジェクトの型注釈\n---\n\n# オブジェクトの型注釈 (type annotation)\n\nTypeScriptでオブジェクトの型注釈は、JavaScriptオブジェクトリテラルのような書き方で、オブジェクトプロパティをキーと値の型のペアを書きます。\n\n```ts twoslash\nlet box: { width: number; height: number };\n//       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^型注釈\nbox = { width: 1080, height: 720 };\n```\n\nオブジェクトの型注釈をしておくと、型の誤りをコンパイラーが警告してくれるようになります。\n\n```ts twoslash\n// @errors: 2322 2741\nlet box: { width: number; height: number };\n// 誤ってプロパティに文字列を代入した\nbox = { width: \"1080\", height: 720 };\n// 誤ってheightを指定し忘れた\nbox = { width: 1080 };\n```\n\nプロパティの区切り文字には、オブジェクトリテラルのようにカンマ`,`も使えますが、セミコロン`;`を用いるほうを推奨します。理由は、コード整形ツール[Prettier](/tutorials/prettier)がオブジェクトの型注釈を直すとき、カンマをセミコロンに置き換えるためです。\n\nオブジェクトの型注釈は途中で改行することもできます。改行した場合、プロパティの区切り文字は省略できます。\n\n```ts twoslash\nlet box: {\n  width: number;\n  height: number;\n};\nbox = { width: 1080, height: 720 };\n```\n\nインラインの型注釈の代わりに、型エイリアスを使った型注釈の書き方もできます。\n\n```ts twoslash\n// 型エイリアス\ntype Box = { width: number; height: number };\nlet box: Box = { width: 1080, height: 720 };\n//       ^^^型注釈\n```\n\n[型エイリアス](../type-alias.md)\n\n## メソッドの型注釈\n\nオブジェクトの型注釈には、メソッドの型注釈を書くこともできます。書き方はJavaScriptのメソッド構文に引数と戻り値の型注釈を加えたようなものになります。\n\n```ts twoslash\nlet calculator: {\n  sum(x: number, y: number): number;\n};\n\ncalculator = {\n  sum(x, y) {\n    return x + y;\n  },\n};\n```\n\nメソッドの型注釈は関数構文の書き方もできます。\n\n```ts twoslash\nlet calculator: {\n  sum: (x: number, y: number) => number;\n};\n```\n\nメソッド構文(method syntax)の型注釈と関数構文(function syntax)の型注釈は、基本的に同じ意味ですが、コンパイラーオプションの`strictFunctionTypes`を有効にした場合に関数構文の書き方は、メソッド引数のチェックが双変(bivariant)から共変(covariant)へと厳格になります。この詳細については`strictFunctionTypes`の説明を参照してください。\n\n[strictFunctionTypes](../../tsconfig/strictfunctiontypes.md)\n\n## オブジェクトの型推論\n\nオブジェクトの値を変数宣言で代入する場合、型注釈を省略できます。値から型が自動的に判別されます。これを型推論といいます。\n\n```ts twoslash\nlet box = { width: 1080, height: 720 };\n//  ^?\n```\n\nメソッドを持つオブジェクトリテラルでも型推論が働きます。ただし、メソッドの場合は引数の型注釈は必要です。\n\n```ts twoslash\nlet calculator = {\n  sum(x: number, y: number) {\n    return x + y;\n  },\n};\ncalculator;\n// ^?\n```\n\n## `Record<Keys, Type>`\n\n連想配列のようなキーバリューのオブジェクトの型を定義する場合、ユーティリティ型の`Record`を使う方法もあります。\n\n```ts twoslash\nlet foo: Record<string, number>;\nfoo = { a: 1, b: 2 };\n```\n\n[Record](../../type-reuse/utility-types/record.md)\n\n## `object`型\n\nオブジェクトの型注釈には`object`型を用いることもできます。\n\n```ts twoslash\nlet box: object;\nbox = { width: 1080, height: 720 };\n```\n\n`object`型の使用はお勧めしません。第1の理由は、`object`型には何のプロパティがあるかの情報がないためです。そのため、`box.width`を参照するとコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2339\nlet box: object;\nbox = { width: 1080, height: 720 };\n// ---cut---\nbox.width;\n```\n\n第2の理由はどんなオブジェクトでも代入できるからです。期待しない値も代入できてしまうので、コードの問題に気づきにくくなります。\n\n```ts twoslash\nlet box: object;\nbox = { wtdih: 1080, hihget: 720 }; // スペルミス\n```\n\nオブジェクトを型注釈する場合は、`object`型はできるだけ使わずに、プロパティまで型を定義することをお勧めします。\n\n<PostILearned>\n\n・TypeScriptでオブジェクトを型注釈するには、プロパティキーごとに型を定義する\n例: { width: number; height: number}\n・変数にオブジェクトを代入すると型推論が効く\n・安全性の観点からobject型を用いるのは避ける\n\n</PostILearned>\n\n## 関連情報\n\n[object、Object、{}の違い](./difference-among-object-and-object.md)\n\n[インターフェース (interface)](/reference/object-oriented/interface)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/type-annotation-of-objects"
    },
    {
      "title": "オプショナルチェーン (optional chaining)",
      "content": "---\nsidebar_label: オプショナルチェーン\n---\n\n# オプショナルチェーン (optional chaining)\n\nJavaScriptのオプショナルチェーン`?.`は、オブジェクトのプロパティが存在しない場合でも、エラーを起こさずにプロパティを参照できる安全な方法です。\n\n## プロパティ参照がエラーになる問題\n\nJavaScriptでは`null`や`undefined`のプロパティを参照するとエラーが発生します。\n\n```js twoslash\nconst book = undefined;\nconst title = book.title;\n// @error: TypeError: Cannot read property 'title' of undefined\n\nconst author = null;\nconst email = author.email;\n// @error: TypeError: Cannot read property 'email' of null\n```\n\nエラーを避けるには、値が`null`や`undefined`でないかチェックする必要があります。\n\n```js twoslash\nconst book = undefined;\nconst title = book === null || book === undefined ? undefined : book.title;\nconsole.log(title);\n// @log: undefined\n```\n\n```js twoslash\nconst book = { title: \"サバイバルTypeScript\" };\nconst title = book === null || book === undefined ? undefined : book.title;\nconsole.log(title);\n// @log: \"サバイバルTypeScript\"\n```\n\nネストしたオブジェクトの場合、チェック処理はいっそう複雑になってきます。\n\n```js twoslash\nconst book = { author: { email: \"alice@example.com\" } };\nconst authorEmail =\n  book === null || book === undefined\n    ? undefined\n    : book.author === null || book.author === undefined\n    ? undefined\n    : book.author.email;\n```\n\nチェックすればエラーなく動きますが、記述量が多くなるという課題もあります。\n\n## オプショナルチェーン\n\nJavaScriptのオプショナルチェーンは`null`や`undefined`のプロパティを誤って参照しないようにしつつ、記述量を抑えられる書き方です。オプショナルチェーンは`?.`演算子を用いて書きます。\n\n```js twoslash\nconst book = undefined;\nconst title = book?.title;\n//                ^^オプショナルチェーン\nconsole.log(title);\n// @log: undefined\n```\n\n```js twoslash\nconst book = { title: \"サバイバルTypeScript\" };\nconst title = book?.title;\nconsole.log(title);\n// @log: \"サバイバルTypeScript\"\n```\n\nオプショナルチェーンはネストして使うこともできます。\n\n```js twoslash\nconst book = undefined;\nconst authorEmail = book?.author?.email;\nconsole.log(authorEmail);\n// @log: undefined\n```\n\n```js twoslash\nconst book = { author: { email: \"alice@example.com\" } };\nconst authorEmail = book?.author?.email;\nconsole.log(authorEmail);\n// @log: \"alice@example.com\"\n```\n\nもしも`?.`に先行する変数やプロパティの値が`null`または`undefined`のときは、その先のプロパティは評価されず、`undefined`が返ります。\n\n```js twoslash\nconst book = null;\nconsole.log(book?.title);\n// @log: undefined\n```\n\n```js twoslash\nconst book = { author: null };\nconsole.log(book.author?.name);\n// @log: undefined\n```\n\n## 関数呼び出し\n\n関数を呼び出すときにもオプショナルチェーンが使えます。関数に使う場合は、引数カッコの前に`?.`を書きます。\n\n```js twoslash\nconst increment = undefined;\nconst result = increment?.(1);\nconsole.log(result);\n// @log: undefined\n```\n\n```js twoslash\nconst increment = (n) => n + 1;\nconst result = increment?.(1);\nconsole.log(result);\n// @log: 2\n```\n\nメソッドを呼び出すときも同様の書き方です。\n\n```js twoslash\nconst book = { getPrice: undefined };\nconsole.log(book.getPrice?.());\n// @log: undefined\n```\n\n```js twoslash\nconst book = {\n  getPrice() {\n    return 0;\n  },\n};\nconsole.log(book.getPrice?.());\n// @log: 0\n```\n\n## 配列要素の参照\n\n配列要素を参照する際にもオプショナルチェーンが使えます。要素を参照する場合は、カギカッコの前に`?.`を書きます。\n\n```js twoslash\nconst books = undefined;\nconst title = books?.[0];\nconsole.log(title);\n// @log: undefined\n```\n\n```js twoslash\nconst books = [\"サバイバルTypeScript\"];\nconst title = books?.[0];\nconsole.log(title);\n// @log: \"サバイバルTypeScript\"\n```\n\n## TypeScriptでの型\n\nTypeScriptでオプショナルチェーンを使った場合、得られる値の型は、最後のプロパティの型と`undefined`のユニオン型になります。\n\n```ts twoslash\nlet book: undefined | { title: string };\nconst title = book?.title;\n//    ^?\n```\n\n## TypeScriptのコンパイル結果\n\nTypeScriptのコンパイラーオプション`target`が`es2020`以上のときは、オプショナルチェーンはそのままJavaScriptにコンパイルされます。\n\n```ts twoslash\n// @target: es2020\n// @showEmit\nlet book: undefined | { title: string };\n// ---cut---\nconst title = book?.title;\n```\n\n`target`が`es2019`以前の場合は、次のような三項演算子を用いたコードにコンパイルされます。\n\n```ts twoslash\n// @target: es2019\n// @showEmit\nlet book: undefined | { title: string };\n// ---cut---\nconst title = book?.title;\n```\n\n## Null合体演算子と組み合わせる\n\nオプショナルチェーンが`undefined`を返したときに、デフォルト値を代入したい場合があります。その際には、Null合体演算子`??`を用いると便利です。\n\n```js twoslash\nconst book = undefined;\nconst title = book?.title ?? \"デフォルトタイトル\";\nconsole.log(title);\n// @log: \"デフォルトタイトル\"\n```\n\n<PostILearned>\n\n・JavaScriptのオプショナルチェーン?.は安全にプロパティを参照する方法\n・値がnullかundefinedのときundefinedが返る\n・a?.b?.cのようにネストも可能\n・関数は?.()\n・配列は?.[]\n・TypeScriptでは値の型とundefinedのユニオン型になる\n・Null合体演算子と相性がいい\n\n</PostILearned>\n\n## 関連情報\n\n[配列要素へのアクセス](../array/how-to-access-elements-in-an-array.md)\n\n[三項演算子 (ternary operator)](../../statements/ternary-operator.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/optional-chaining"
    },
    {
      "title": "オブジェクトの型のreadonlyプロパティ (readonly property)",
      "content": "---\nsidebar_label: オブジェクト型のreadonlyプロパティ\n---\n\n# オブジェクトの型のreadonlyプロパティ (readonly property)\n\nTypeScriptでは、オブジェクトのプロパティを読み取り専用にすることができます。読み取り専用にしたいプロパティには`readonly`修飾子をつけます。読み取り専用のプロパティに値を代入しようとすると、TypeScriptコンパイラーが代入不可の旨を警告するようになります。\n\n```ts twoslash\n// @errors: 2540\nlet obj: {\n  readonly foo: number;\n};\nobj = { foo: 1 };\nobj.foo = 2;\n```\n\n## readonlyは再帰的ではない\n\n`readonly`は指定したそのプロパティだけが読み取り専用になります。`readonly`はそのオブジェクトが入れ子になっている場合、その中のオブジェクトのプロパティまでを`readonly`にはしません。つまり、再帰的なものではありません。\n\nたとえば、`foo`プロパティが`readonly`で、`foo.bar`プロパティが`readonly`でない場合、`foo`への代入はコンパイルエラーになるものの、`foo.bar`へ直接代入するのはコンパイルエラーになりません。\n\n```ts twoslash\n// @errors: 2540\nlet obj: {\n  readonly foo: {\n    bar: number;\n  };\n};\nobj = {\n  foo: {\n    bar: 1,\n  },\n};\nobj.foo = { bar: 2 };\nobj.foo.bar = 2; // コンパイルエラーにはならない\n```\n\n再帰的にプロパティを読み取り専用にしたい場合は、子や孫の各プロパティに`readonly`をつけていく必要があります。\n\n```ts twoslash\nlet obj: {\n  readonly foo: {\n    readonly bar: number;\n  };\n};\n```\n\n## readonlyはコンパイル時のみ\n\n`readonly`はTypeScriptの型の世界だけの概念です。つまり、読み取り専用指定を受けたプロパティがチェックを受けるのはコンパイル時だけです。コンパイルされた後のJavaScriptとしては、`readonly`がついていたプロパティも代入可能になります。\n\nたとえば、`foo`プロパティを`readonly`指定したコードで、`foo`に代入するコードはコンパイル時にはエラーとして検出されます。\n\n```ts twoslash\n// @errors: 2540\nconst obj: { readonly foo: number } = { foo: 1 };\nobj.foo = 2; // コンパイルエラーになる\n```\n\nしかし、コンパイル後のJavaScriptコードでは、`readonly`の記述がなくなるので、実行時にエラーとして検出されることはありません。\n\n```ts twoslash title=\"コンパイル後のJavaScriptコード\"\n// @noErrors\n// @showEmit\n// @alwaysStrict: false\nconst obj: { readonly foo: number } = { foo: 1 };\nobj.foo = 2; // 実行時エラーにはならない\n```\n\n実行時にチェックが無いことは一見すると危険そうですが、コンパイルエラーを無視せず、ちゃんと修正しておけば大きな問題になることはありません。\n\n## すべてのプロパティを一括して読み取り専用にする方法\n\nTypeScriptではプロパティを読み取り専用にするには、読み取り専用にしたい各プロパティにひとつひとつ`readonly`修飾子をつける必要があります。プロパティ数が多くなると`readonly`をつけていくのは記述量が多くなり手間です。\n\nそういったケースではユーティリティ型の`Readonly`を使うのも手です。`Readonly`はプロパティをすべて読み取り専用にしてくれる型です。\n\n```ts twoslash\nlet obj: Readonly<{\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}>;\n```\n\n[Readonly&lt;T>](../../type-reuse/utility-types/readonly.md)\n\n## 関連情報\n\n[クラスのreadonly修飾子](../../object-oriented/class/readonly-modifier-in-classes.md)\n\n[インターフェースのreadonly修飾子](../../object-oriented/interface/readonly-modifier-in-interfaces.md)\n\n[読み取り専用の配列 (readonly array)](../array/readonly-array.md)\n\n[constアサーション](./../const-assertion.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/readonly-property"
    },
    {
      "title": "オブジェクトの分割代入 (destructuring assignment)",
      "content": "---\nsidebar_label: オブジェクトの分割代入\n---\n\n# オブジェクトの分割代入 (destructuring assignment)\n\nJavaScriptには、オブジェクトの分割代入(destructuring assignment)という便利な構文があります。分割代入は、オブジェクトからプロパティを取り出す機能です。\n\n通常、オブジェクトからプロパティを取り出す場合は、プロパティアクセサーを用います。プロパティアクセサーは、ドットを使ってプロパティを参照する記法です。\n\n```ts twoslash\nconst item = { price: 100 };\nconst price = item.price; // プロパティアクセサー\n```\n\n分割代入は、中カッコ`{}`に取り出したいプロパティを指定することで、プロパティ名と同じ名前の変数が作れます。次の分割代入のサンプルコードは、上のプロパティアクセサーを使ったコードと同等の処理になります。\n\n```ts twoslash\nconst item = { price: 100 };\nconst { price } = item;\n// 上は const price = item.price; と同等の処理\n```\n\n分割代入は、プロパティ名と同じ名前で変数を定義するときに、プロパティ名を2度書かないで済むのがひとつの利点です。\n\n## 複数のプロパティを取り出す\n\n分割代入は、複数のプロパティを一度に取り出すこともできます。その場合、取り出したいプロパティを中カッコに列挙します。\n\n```ts twoslash\nconst obj = { a: 1, b: 2 };\nconst { a, b } = obj;\n```\n\nこの特徴は、取り出すプロパティ数が多い場合に、プロパティアクセサーより便利です。プロパティアクセサーでは、プロパティごとに代入文を書かないとなりません。\n\n```ts twoslash title=\"プロパティアクセサーで取り出す例\"\nconst color = { r: 0, g: 122, b: 204, a: 1 };\nconst r = color.r;\nconst g = color.g;\nconst b = color.b;\nconst a = color.a;\n```\n\n分割代入を使うと、これを簡潔にまとめられます。\n\n```ts twoslash title=\"多くのプロパティを分割代入で取り出す例\"\nconst color = { r: 0, g: 122, b: 204, a: 1 };\nconst { r, g, b, a } = color;\n```\n\n## 代入する変数名の指定\n\nオブジェクトの分割代入では、コロン`:`のあとに変数名を指定すると、その名前の変数に代入できます。\n\n```ts twoslash\nconst color = { r: 0, g: 122, b: 204, a: 1 };\nconst { r: red, g: green, b: blue, a: alpha } = color;\nconsole.log(green);\n// @log: 122\n```\n\n## 入れ子構造の分割代入\n\nオブジェクトの中にオブジェクトある入れ子構造にも、分割代入が使えます。深い階層のプロパティを取り出すには、階層の分だけ中カッコで囲みます。\n\n```ts twoslash\nconst continent = {\n  name: \"北アメリカ\",\n  us: {\n    name: \"アメリカ合衆国\",\n    capitalCity: \"ワシントンD.C.\",\n  },\n};\n\nconst {\n  us: { name, capitalCity },\n} = continent;\n\nconsole.log(name);\n// @log: \"アメリカ合衆国\"\nconsole.log(capitalCity);\n// @log: \"ワシントンD.C.\"\n// @lib: esnext\n```\n\n## 入れ子構造の分割代入と変数名の指定\n\n入れ子構造の分割代入をしながら、値を代入する変数名を指定することを同時にすることもできます。\n\n```ts twoslash\nconst continent = {\n  name: \"北アメリカ\",\n  us: {\n    name: \"アメリカ合衆国\",\n    capitalCity: \"ワシントンD.C.\",\n  },\n};\n\nconst {\n  name: continentName,\n  us: { name: countryName },\n} = continent;\n\nconsole.log(continentName);\n// @log: \"北アメリカ\"\nconsole.log(countryName);\n// @log: \"アメリカ合衆国\"\n```\n\n## 分割代入のデフォルト値\n\n分割代入では、`=`のあとにデフォルト値が指定できます。デフォルト値は値が、`undefined`のときに代入されます。\n\n```ts twoslash\nconst color = { r: undefined, g: 122, b: 204 };\nconst { r = 0, g = 0, b = 0 } = color;\nconsole.log(r, g, b);\n// @log: 0,  122,  204\n```\n\n値が`null`のときは、デフォルト値が使われません。`null`がそのまま代入されます。\n\n```ts twoslash\nconst color = { r: null };\nconst { r = 0 } = color;\nconsole.log(r);\n// @log: null\n```\n\n## デフォルト値と変数名の指定\n\n分割代入のデフォルト値と代入先の変数名を同時に指定することもできます。その場合、代入先変数名に続けて、デフォルト値を書きます。\n\n```ts twoslash\nconst color = { r: undefined, g: 122, b: 204 };\nconst { r: red = 0 } = color;\nconsole.log(red);\n// @log: 0\n```\n\n<PostILearned>\n\n・JavaScriptの分割代入はプロパティを取り出せる。\n・同じ変数名を使う場合、コードが簡潔になる。\n・複数のプロパティを取り出すときは特に便利。\n・入れ子のプロパティも取り出せる。\n・デフォルト値も指定できる。\n\n</PostILearned>\n\n## 関連情報\n\n[配列の分割代入 (destructuring assignment)](../array/destructuring-assignment-from-array.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/object/destructuring-assignment-from-objects"
    },
    {
      "title": "タプル (tuple)",
      "content": "---\nsidebar_label: タプル\n---\n\n# タプル (tuple)\n\nTypeScriptの関数は1値のみ返却可能です。戻り値に複数の値を返したい時に、配列に返したいすべての値を入れて返すことがあります。なお次の関数の戻り値は定数になっていますが、実際は演算した結果だと解釈してください。\n\n```ts twoslash\nfunction tuple() {\n  //...\n  return [1, \"ok\", true];\n}\n```\n\n## 配列が抱える問題\n\n上記例では戻り値の型として何が妥当でしょうか。配列のページから読み進めていただいた方はなんでも入れられる型、ということで`any[]`または`unknown[]`が型の候補として思い浮かぶ人もいるかと思います。\n\n```ts twoslash\n// @errors: 2571\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst list: unknown[] = tuple();\n\nlist[0].toString();\n```\n\nですが、この`list[n]`からメソッドを呼ぶことができません。それは`list`の各要素は`unknown`であるからです。\n\nでは`any[]`を戻り値の型として使うべきかというと、それも問題です。せっかくTypeScriptを使って型による恩恵を享受しているのに、ここだけ型がないものとしてコーディングをするのも味気がありません。そこで使えるのがタプルです。\n\n## タプルの型\n\nタプルの型は簡単で`[]`を書いて中に型を書くだけです。つまり、上記関数`tuple()`は次のような戻り値を持っていると言えます。\n\n```ts twoslash\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst list: [number, string, boolean] = tuple();\n```\n\n同様に関数の戻り値にも書くことができます。\n\n```ts twoslash\nfunction tuple(): [number, string, boolean] {\n  //...\n  return [1, \"ok\", true];\n}\n```\n\n配列の型は`T[]`と`Array<T>`のふたつの書き方がありましたがタプルはこの書き方しか存在しません。\n\n## タプルへのアクセス\n\nタプルを受けた変数はそのまま中の型が持っているプロパティ、メソッドを使用できます。\n\n```ts twoslash\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst list: [number, string, boolean] = tuple();\n\nlist[0].toExponential();\nlist[1].length;\nlist[2].valueOf();\n```\n\nタプルを受けた変数は、タプルで定義した範囲外の要素に対してアクセスができません。\n\n```ts twoslash\n// @errors: 2493\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst list: [number, string, boolean] = tuple();\n\nlist[5];\n```\n\nそのため`list.push()`のような配列の要素を増やす操作をしてもその要素を使うことはできません。\n\n### 分割代入を使ってタプルにアクセスする\n\n上記関数`tuple()`の戻り値は分割代入を使うと次のように受けることができます。\n\n```ts twoslash\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst [num, str, bool]: [number, string, boolean] = tuple();\n```\n\nまた、特定の戻り値だけが必要である場合は変数名を書かず`,`だけを書きます。\n\n```ts twoslash\ndeclare function tuple(): [number, string, boolean];\n// ---cut---\nconst [, , bool]: [number, string, boolean] = tuple();\n```\n\n## タプルを使う場面\n\nTypeScriptで非同期プログラミングをする時に、時間のかかる処理を直列ではなく並列で行いたい時があります。そのときTypeScriptでは`Promise.all()`というものを使用します。このときタプルが役に立ちます。\n`Promise`についての詳しい説明は本書に専門の頁がありますので譲ります。ここでは`Promise<T>`という型の変数は`await`をその前につけると`T`が取り出せることだけ覚えておいてください。また、この`T`をジェネリクスと言いますが、こちらも専門の頁があるので譲ります。\n\n[非同期処理](../asynchronous/README.md)\n\n[ジェネリクス (generics)](/reference/generics)\n\n```ts twoslash\n// @module: esnext\n// @target: esnext\nimport fs from \"fs\";\n\ndeclare function yyAsync(): Promise<number>;\n// ---cut---\nconst promise: Promise<number> = yyAsync();\nconst num: number = await promise;\n```\n\nたとえば次のような処理に時間が3秒、5秒かかる関数`takes3Seconds(), takes5Seconds()`があるとします。\n\n```ts twoslash\nasync function takes3Seconds(): Promise<string> {\n  // ...\n  return \"finished!\";\n}\n\nasync function takes5Seconds(): Promise<number> {\n  // ...\n  return -1;\n}\n```\n\nこの関数をそのまま実行すると3 + 5 = 8秒かかってしまいます。\n\n```ts twoslash\n// @module: esnext\n// @target: esnext\nimport fs from \"fs\";\n\ndeclare function takes3Seconds(): Promise<string>;\ndeclare function takes5Seconds(): Promise<number>;\n// ---cut---\nconst str: string = await takes3Seconds();\nconst num: number = await takes5Seconds();\n```\n\nこれを`Promise.all()`を使うことで次のように書くことができます。このときかかる時間は関数の中でもっとも時間がかかる関数、つまり5秒です。\n\n```ts twoslash\n// @module: esnext\n// @target: esnext\nimport fs from \"fs\";\n\ndeclare function takes3Seconds(): Promise<string>;\ndeclare function takes5Seconds(): Promise<number>;\n// ---cut---\nconst tuple: [string, number] = await Promise.all([\n  takes3Seconds(),\n  takes5Seconds(),\n]);\n```\n\nこのとき`Promise.all()`の戻り値を受けた変数`tuple`は`[string, number]`です。実行する関数の`Promise<T>`のジェネリクスの部分とタプルの型の順番は一致します。つまり次のように入れ替えたら、入れ変えた結果のタプルである`[number, string]`が得られます。\n\n```ts twoslash\n// @module: esnext\n// @target: esnext\nimport fs from \"fs\";\n\ndeclare function takes3Seconds(): Promise<string>;\ndeclare function takes5Seconds(): Promise<number>;\n// ---cut---\nconst tuple: [number, string] = await Promise.all([\n  takes5Seconds(),\n  takes3Seconds(),\n]);\n```\n\n`Promise.all()`は先に終了した関数から順番に戻り値のタプルとして格納されることはなく、元々の順番を保持します。`take3seconds()`の方が早く終わるから、先にタプルに格納されるということはなく、引数に渡した順番のとおりにタプル`tuple`の要素の型は決まります。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/tuple"
    },
    {
      "title": "ユニオン型 (union type)",
      "content": "---\nsidebar_label: ユニオン型\n---\n\n# ユニオン型 (union type)\n\nTypeScriptのユニオン型(union type)は「いずれかの型」を表現するものです。\n\n## ユニオン型の型注釈\n\nユニオン型の型注釈は、2つ以上の型をパイプ記号(`|`)で繋げて書きます。たとえば、number型もしくはundefined型を表す場合は、`number | undefined`のように書きます。\n\n```ts twoslash\nlet numberOrUndefined: number | undefined;\n```\n\n`|`は型のリストの冒頭に置くこともできます。型ごとに改行するときに、列が揃うので便利です。\n\n<!--prettier-ignore-->\n```ts twoslash\ntype ErrorCode =\n  | 400\n  | 401\n  | 402\n  | 403\n  | 404\n  | 405;\n```\n\n## 配列要素にユニオン型を使う際の書き方\n\n配列の要素としてユニオン型を用いる場合は、書き方に注意が必要です。たとえば、`string`または`number`からなる配列の型を宣言することを考えてみましょう。`string`または`number`をユニオン型で表現すると`string | number`になります。配列型は要素の型に`[]`をつけて表現します。これをそのまま繋げて考えると、次のような型を思いつくかもしれませんが、これは間違いです。\n\n```ts twoslash\ntype List = string | number[];\n```\n\nこれは`string`型または`number[]`型であることになっているためです。正しくは以下です。特に配列を`T[]`形式で書いているときは`()`が必要になるので注意してください。\n\n```ts twoslash\ntype List = (string | number)[];\n```\n\n## ユニオン型と絞り込み\n\nユニオン型`string | null`が`string`なのか`null`なのかを判定したいときは、TypeScriptの絞り込み(narrowing)を用います。絞り込みをするにはいくつかの方法がありますが、代表例はif文です。条件分岐で変数がstring型かどうかをチェックすると、同じ変数でも分岐内では`string | null`型が`string`型だと判定されます。\n\n```ts twoslash\n// @errors: 2322\nconst maybeUserId: string | null = localStorage.getItem(\"userId\");\n\nconst userId: string = maybeUserId; // nullかもしれないので、代入できない。\n\nif (typeof maybeUserId === \"string\") {\n  const userId: string = maybeUserId; // この分岐内では文字列型に絞り込まれるため、代入できる。\n}\n```\n\n[制御フロー分析と型ガードによる型の絞り込み](../statements/control-flow-analysis-and-type-guard.md)\n\n## 関連情報\n\n[判別可能なユニオン (discriminated union)](discriminated-union.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/union"
    },
    {
      "title": "変数宣言: letとconst",
      "content": "# 変数宣言: letとconst\n\nJavaScriptの変数宣言(variable declaration)には、`let`と`const`があります。\n\n## letの変数宣言\n\n`let`を用いた変数宣言の書き方は次のようにします。\n\n```ts twoslash\nlet x = 1;\n```\n\n`let`は再代入が可能です。\n\n```ts twoslash\nlet x = 1;\nx = 2; // 再代入ができる\n```\n\n`let`は変数の初期値なしで変数定義できます。初期値なしの変数の値は`undefined`になります。\n\n```js twoslash\nlet x; // 初期値なし\nx = 1; // 後で代入\n```\n\n## constの変数宣言\n\n`const`を用いた変数宣言の書き方は次のようになります。初期値は必須です。\n\n```js twoslash\nconst y = 2;\n```\n\n`const`は変数への再代入が禁止されています。\n\n```js twoslash\nconst y = 1;\ny = 1;\n// @error: TypeError: Assignment to constant variable.\n```\n\n## letとconstの使い分け\n\n初めて JavaScript を書く場合に、`let`と`const`のどちらの変数宣言を使えばよいか悩む場合があるかもしれません。基本は`const`で変数宣言をして必要な場合にのみ、`let`を使うのがオススメです。`const`で変数宣言することで再代入を禁止して、意図せず変数が書き換えられることを予防できるので、より安全なコードになります。\n\n<PostILearned>\n\n・JavaScriptの変数宣言はletとconstがある\n・letは再代入OK、constは再代入NG\n・基本的にconstを使うとよい\n\n</PostILearned>\n\n## constは可変オブジェクトを保護しない\n\nconstは再代入不可な変数名を宣言するだけです。constには、可変(ミュータブル)なオブジェクトのプロパティを不変にする保護効果はありません。この点は誤解されがちです。\n\nたとえば、constでオブジェクトを宣言した場合、変数自体への再代入はできません。ところが、オブジェクトプロパティは変更できます。\n\n```ts twoslash\n// @errors: 2588\nconst obj = { a: 1 };\nobj = { a: 2 }; // 再代入は不可\nobj.a = 2; // プロパティの変更はできる\n```\n\nTypeScriptでオブジェクトを不変にするには、プロパティを読み取り専用にする必要があります。\n\n[readonlyプロパティ](./object/readonly-property.md)\n\n配列もオブジェクトの一種なので同様です。変数自体の再代入はできません。しかし、配列要素は変更できます。\n\n```ts twoslash\n// @errors: 2588\nconst arr = [1, 2];\narr = [3, 4]; // 再代入は不可\narr.push(3); // 要素の変更はできる\n```\n\nTypeScriptで配列を不変にするには読み取り専用配列を使う必要があります。\n\n[読み取り専用配列](./array/readonly-array.md)\n\nconstアサーションを使ってオブジェクトや配列を不変にする方法もあります。\n\n[constアサーション](./const-assertion.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/let-and-const"
    },
    {
      "title": "数値リテラル",
      "content": "---\nsidebar_label: number型\nslug: /reference/values-types-variables/number\ntitle: number型 (数値型)\n---\n\nJavaScriptのnumber型は、1や-1などの整数と0.1などの小数を含めた数値の型です。PHPなどの言語では、数値について整数を表す型(int)と小数を表す型(floatやdouble)の2つの型を持ちます。Javaなどの言語では、整数型をさらに32ビットと64ビットに細分化する言語もあります。JavaScriptには、整数と小数を型レベルで区別するものはありません。どちらもnumber型で表現します。\n\n## 数値リテラル\n\nJavaScriptの数値リテラルは次のように数値を見たままに書きます。\n\n<!--prettier-ignore-->\n```js\n123 // 整数\n-123 // 整数(負の数)\n20.315 // 小数\n```\n\n小数は小数点ではじめる書き方もできます。また、整数も小数点で終わる書き方もできます。\n\n<!--prettier-ignore-->\n```js\n0.1 === .1\n5.0 === 5.\n```\n\n### 2進数、8進数、16進数\n\n2進数、8進数、16進数の表記も可能です。それぞれ表現したい数値の前に`0b`、`0o`、`0x`をつけます。\n\n<!--prettier-ignore-->\n```ts\n0b1010 // 2進数\n0o755 // 8進数\n0xfff // 16進数\n```\n\n### 数値の区切り文字(numeric separators)\n\nJavaScriptの数値リテラルは可読性のためにアンダースコアで区切って書けます。何桁ごとに区切るかは自由です。表したい値や、国と地域の慣習などに合わせて選択できます。\n\n<!--prettier-ignore-->\n```js\n100_000_000 // 1億\n```\n\nただし、`_`を先頭や末尾、小数点の前後、連続で2個以上置くことはできません。つまり次のような表記はできません。\n\n```ts\n_100\n100_\n100_.0\n100._0\n1__00\n```\n\n### 数値リテラルのプロパティ\n\nJavaScriptの数値リテラルのプロパティを直接参照する場合、小数点のドットとプロパティアクセッサーのドットが区別できないため、構文エラーになります。\n\n```ts twoslash\n// @errors: 1351\n5.toString(); // この書き方は構文エラー\n```\n\nこれを回避するには、ドットを2つ続けるか、数値をカッコで囲む必要があります。\n\n<!--prettier-ignore-->\n```ts twoslash\n5..toString();\n(5).toString();\n```\n\n## number型の型注釈\n\nTypeScriptでnumber型の型注釈は`number`を用います。\n\n```ts twoslash\nconst count: number = 123;\n```\n\nよく似た名前の型として`Number`型がありますが、これと`number`は別物なので注意してください。\n\n## 数値の範囲\n\nJavaScriptのnumber型は、IEEE 754の倍精度浮動小数です。64ビットのうち、52ビットが数値の格納に、11ビットが小数の位置に、1ビットが正負符号に使われます。正確に扱える数値は`-(2^53 − 1)`から`2^53 − 1`の間です。整数について言うと、他言語の64ビット整数型の範囲より狭いので注意しましょう。\n\n## 特殊な数値\n\nJavaScriptのnumber型には、`NaN`と`Infinity`という特殊な値があります。\n\n### NaN\n\n`NaN`は非数(not-a-number)を表す変数です。JavaScriptでは、処理の結果、数値にならない場合に`NaN`を返すことがあります。たとえば、文字列を数値に変換する`parseInt`関数は、数値化できない入力に対し、`NaN`を返します。\n\n```js twoslash\nconst price = parseInt(\"百円\");\nconsole.log(price);\n// @log: NaN\n```\n\n値が`NaN`であるかのチェックは`Number.isNaN`を用います。\n\n```ts twoslash\nconst price = parseInt(\"百円\");\nif (Number.isNaN(price)) {\n  console.log(\"数値化できません\");\n}\n```\n\n`NaN`は特殊で、等号比較では常に`false`になるので注意してください。\n\n```js twoslash\nconsole.log(NaN == NaN);\n// @log: false\nconsole.log(NaN === NaN);\n// @log: false\n```\n\n### Infinity\n\n`Infinity`は無限大を表す変数です。たとえば、1を0で割った場合、この値になります。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/number/README"
    },
    {
      "title": "小数計算の誤差",
      "content": "# 小数計算の誤差\n\nJavaScriptの小数の計算には誤差が生じる場合があるので要注意です。たとえば、0.1 + 0.2は0.3になってほしいところですが、計算結果は0.30000000000000004になります。これはJavaScriptのバグではありません。\n\n```js\n0.1 + 0.2 === 0.3; //=> false\n```\n\nnumber型はIEEE 754という規格に準拠していて、その制約によって生じる現象です。10進数の0.2は有限小数ですが、それを2進数で表すと0.0011...のような循環小数になります。循環小数は小数点以下が無限に続きますが、IEEE 754が扱う小数点以下は有限であるため、循環小数は桁の途中で切り捨てられます。その結果、小数の計算に誤差が生じてしまうわけです。これはちょうど、私達が円周率の計算を筆算するときの制約に似ています。円周率は3.141592...と無限に小数点以下が続きますが、時間も紙面も有限なため、ある程度の誤差は妥協して3.14に丸めて計算するかと思います。ちなみに、2進数で有限小数になる0.5や0.25などの数値だけを扱う計算は誤差なく計算できます。\n\n```js\n0.5 + 0.25 === 0.75; //=> true\n```\n\n小数計算の誤差を解決するために、一度整数に桁上げして計算し、もとの桁を下げる方法が考えられます。整数の計算は誤差が生じないという特性に期待した方法です。たとえば、110円の消費税込価格を求める計算を考えてみましょう。110に1.1を掛け算すると、誤差が生じて121円ぴったりにはなりません。\n\n```js\n110 * 1.1; //=> 121.00000000000001\n```\n\nそこで、110と桁上げした税率11を掛け算してから、10で割ってみます。すると、うまく計算できます。\n\n```js\n(110 * 11) / 10 === 121; //=> true\n```\n\nこの方法を使う場合は、桁を戻した数値は小数になることがあり、その値には小数計算誤差問題が残り続けることに注意してください。\n\n```js twoslash\nconst price1 = (101 * 11) / 10; // 111.1\nconst price2 = (103 * 11) / 10; // 113.3\nprice1 + price2; // 224.39999999999998\n```\n\n小数計算の誤差問題を包括的に解決したい場合は、[decimal.js](https://github.com/MikeMcl/decimal.js/)のような計算誤差がないパッケージを使うのも手です。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/number/decimal-calculation-error"
    },
    {
      "title": "constアサーション「as const」 (const assertion)",
      "content": "---\nsidebar_label: constアサーション「as const」\n---\n\n# constアサーション「as const」 (const assertion)\n\nオブジェクトリテラルの末尾に`as const`を記述すればプロパティが`readonly`でリテラルタイプで指定した物と同等の扱いになります。\n\n```ts twoslash\nconst pikachu = {\n  name: \"pikachu\",\n  no: 25,\n  genre: \"mouse pokémon\",\n  height: 0.4,\n  weight: 6.0,\n} as const;\n```\n\n代入はもちろんできません。\n\n```ts twoslash\n// @errors: 2540\nconst pikachu = {\n  name: \"pikachu\",\n  no: 25,\n  genre: \"mouse pokémon\",\n  height: 0.4,\n  weight: 6.0,\n} as const;\n// ---cut---\npikachu.name = \"raichu\";\n```\n\n## `readonly`と`const assertion`の違い\n\nどちらもオブジェクトのプロパティを`readonly`にする機能は同じですが、以下が異なります。\n\n### `readonly`はプロパティごとにつけられる\n\n`const assertion`はオブジェクト全体に対する宣言なので、すべてのプロパティが対象になりますが、`readonly`は必要なプロパティのみにつけることができます。\n\n### `const assertion`は再帰的に`readonly`にできる\n\nオブジェクトの中にオブジェクトがあるときの挙動が異なります。たとえば次のようなオブジェクトがあるとします。\n\n```ts twoslash\ntype Country = {\n  name: string;\n  capitalCity: string;\n};\n\ntype Continent = {\n  readonly name: string;\n  readonly canada: Country;\n  readonly us: Country;\n  readonly mexico: Country;\n};\n\nconst america: Continent = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n};\n```\n\nここで`Continent`のタイプエイリアスがもつプロパティはすべて`readonly`です。よって次のようなことはできません。\n\n```ts twoslash\n// @errors: 2540\ntype Country = {\n  name: string;\n  capitalCity: string;\n};\n\ntype Continent = {\n  readonly name: string;\n  readonly canada: Country;\n  readonly us: Country;\n  readonly mexico: Country;\n};\n\nconst america: Continent = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n};\n// ---cut---\namerica.name = \"African Continent\";\namerica.canada = {\n  name: \"Republic of Côte d'Ivoire\",\n  capitalCity: \"Yamoussoukro\",\n};\n```\n\nしかしながら、次のようなことは問題なくできてしまいます。\n\n```ts twoslash\ntype Country = {\n  name: string;\n  capitalCity: string;\n};\n\ntype Continent = {\n  readonly name: string;\n  readonly canada: Country;\n  readonly us: Country;\n  readonly mexico: Country;\n};\n\nconst america: Continent = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n};\n// ---cut---\namerica.canada.name = \"Republic of Côte d'Ivoire\";\namerica.canada.capitalCity = \"Yamoussoukro\";\n```\n\nこれは`readonly`をつけたプロパティがオブジェクトである場合に、そのオブジェクトのプロパティまで`readonly`にはしないことに起因します。\n\n### `const assertion`はすべてのプロパティを固定する\n\n`as const`を付けます。\n\n```ts twoslash\nconst america = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n} as const;\n```\n\n`readonly`と同様にトップレベルのプロパティへの代入はできません。\n\n```ts twoslash\n// @errors: 2540\nconst america = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n} as const;\n// ---cut---\namerica.name = \"African Continent\";\namerica.canada = {\n  name: \"Republic of Côte d'Ivoire\",\n  capitalCity: \"Yamoussoukro\",\n};\n```\n\nこれだけではなくオブジェクトが持つプロパティも同様に`readonly`にしてくれます。\n\n```ts twoslash\n// @errors: 2540\nconst america = {\n  name: \"North American Continent\",\n  canada: {\n    name: \"Republic of Canada\",\n    capitalCity: \"Ottawa\",\n  },\n  us: {\n    name: \"United States of America\",\n    capitalCity: \"Washington, D.C.\",\n  },\n  mexico: {\n    name: \"United Mexican States\",\n    capitalCity: \"Mexico City\",\n  },\n} as const;\n// ---cut---\namerica.canada.name = \"Republic of Côte d'Ivoire\";\namerica.canada.capitalCity = \"Yamoussoukro\";\n```\n\n## 関連情報\n\n[型アサーション「as」(type assertion)](type-assertion-as.md)\n\n[オブジェクト型のreadonlyプロパティ (readonly property)](object/readonly-property.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/const-assertion"
    },
    {
      "title": "判別可能なユニオン型 (discriminated union)",
      "content": "---\nsidebar_label: 判別可能なユニオン型\nimage: /reference/values-types-variables/discriminated-union/summary-card.png\n---\n\n# 判別可能なユニオン型 (discriminated union)\n\n![](/reference/values-types-variables/discriminated-union/summary-card@3x.png)\n\nTypeScriptの判別可能なユニオン型は、ユニオンに属する各オブジェクトの型を区別するための「しるし」がついた特別なユニオン型です。オブジェクトの型からなるユニオン型を絞り込む際に、分岐ロジックが複雑になる場合は、判別可能なユニオン型を使うとコードの可読性と保守性がよくなります。\n\n## 通常のユニオン型は絞り込みが複雑になる\n\nTypeScriptの[ユニオン型](./union.md)は自由度が高く、好きな型を組み合わせられます。次の`UploadStatus`はファイルアップロードの状況を表現したユニオン型です。アップロード中`InProgress`、アップロード成功`Success`、アップロード失敗`Failure`の組み合わせです。\n\n```ts twoslash\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { done: boolean; progress: number };\ntype Success = { done: boolean };\ntype Failure = { done: boolean; error: Error };\n```\n\n`UploadStatus`の各状態を整理したのが次の表です。\n\n| 型           | 意味             | `done`  | `progress` |  `error`   |\n| ------------ | ---------------- | :-----: | :--------: | :--------: |\n| `InProgress` | アップロード中   | `false` | 進捗率(%)  |     -      |\n| `Success`    | アップロード成功 | `true`  |     -      |     -      |\n| `Failure`    | アップロード失敗 | `true`  |     -      | エラー詳細 |\n\n状態を表示する関数を実装してみます。\n\n```ts twoslash\n// @errors: 2339\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { done: boolean; progress: number };\ntype Success = { done: boolean };\ntype Failure = { done: boolean; error: Error };\n// ---cut---\nfunction printStatus(status: UploadStatus) {\n  if (status.done === false) {\n    console.log(`アップロード中:${status.progress}%`);\n  }\n}\n```\n\nこの実装は、`done`が`false`であることをチェックしています。不具合はないはずです。しかし、コンパイラーには`progress`が無いと警告されます。これは、if分岐内でも、`status`が`Success`や`Failure`かもしれないとコンパイラーが考えるためです。\n\nこのエラーを解消するには、`progress`があることをチェックする必要があります。そうすると、コンパイラーはif分岐内の`status`は`InProgress`だと判断します。\n\n```ts twoslash {2}\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { done: boolean; progress: number };\ntype Success = { done: boolean };\ntype Failure = { done: boolean; error: Error };\n// ---cut---\nfunction printStatus(status: UploadStatus) {\n  if (status.done === false && \"progress\" in status) {\n    //                         ^^^^^^^^^^^^^^^^^^^^追加\n    console.log(`アップロード中:${status.progress}%`);\n    // コンパイルエラーが解消！\n  }\n}\n```\n\nコンパイルエラーを起こさないように、すべての状態に対応した関数が次です。\n\n```ts twoslash\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { done: boolean; progress: number };\ntype Success = { done: boolean };\ntype Failure = { done: boolean; error: Error };\n// ---cut---\nfunction printStatus(status: UploadStatus) {\n  if (status.done) {\n    if (\"error\" in status) {\n      console.log(`アップロード失敗:${status.error.message}`);\n    } else {\n      console.log(\"アップロード成功\");\n    }\n  } else if (\"progress\" in status) {\n    console.log(`アップロード中:${status.progress}%`);\n  }\n}\n```\n\nどうでしょうか。このコードはなんだかごちゃついていませんか。あまり読みやすいとは言えないかもしれません。こうしたオブジェクトのユニオン型は、判別可能なユニオン型に書き直すとよいです。読みやすく、保守性も良くなります。\n\n## 判別可能なユニオン型とは？\n\nTypeScriptの判別可能なユニオン型(discriminated union)はユニオン型の応用です。判別可能なユニオン型は、タグ付きユニオン(tagged union)や直和型と呼ぶこともあります。\n\n判別可能なユニオン型は次の特徴を持ったユニオン型です。\n\n1. オブジェクトの型で構成されたユニオン型\n1. 各オブジェクトの型を判別するためのプロパティ(しるし)を持つ\n   - このプロパティのことをディスクリミネータ(discriminator)と呼ぶ\n1. ディスクリミネータの型は[リテラル型](./literal-types.md)などであること\n1. ディスクリミネータさえ有れば、各オブジェクトの型は固有のプロパティを持ってもよい\n\nたとえば、上の`UploadStatus`を判別可能なユニオン型に書き直すと、次のようになります。\n\n```ts twoslash\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { type: \"InProgress\"; progress: number };\ntype Success = { type: \"Success\" };\ntype Failure = { type: \"Failure\"; error: Error };\n```\n\nこれを表に整理したのが次です。\n\n| 型           | 意味             | ディスクリミネータ   | `progress` |  `error`   |\n| ------------ | ---------------- | -------------------- | :--------: | :--------: |\n| `InProgress` | アップロード中   | `type: \"InProgress\"` | 進捗率(%)  |     -      |\n| `Success`    | アップロード成功 | `type: \"Success\"`    |     -      |     -      |\n| `Failure`    | アップロード失敗 | `type: \"Failure\"`    |     -      | エラー詳細 |\n\n変わった点といえば、`done: boolean`がなくなり、`type`というディスクリミネータが追加されたところです。`type`の型が`string`ではなく、`InProgress`などのリテラル型になったことも重要な変更点です。\n\n## 判別可能なユニオン型の絞り込み\n\n判別可能なユニオン型は、ディスクリミネータを分岐すると型が絞り込まれます。\n\n```ts twoslash\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { type: \"InProgress\"; progress: number };\ntype Success = { type: \"Success\" };\ntype Failure = { type: \"Failure\"; error: Error };\n// ---cut---\nfunction printStatus(status: UploadStatus) {\n  if (status.type === \"InProgress\") {\n    console.log(`アップロード中:${status.progress}%`);\n    //                          ^?\n  } else if (status.type === \"Success\") {\n    console.log(\"アップロード成功\", status);\n    //                           ^?\n  } else if (status.type === \"Failure\") {\n    console.log(`アップロード失敗:${status.error.message}`);\n    //                           ^?\n  } else {\n    console.log(\"不正なステータス: \", status);\n  }\n}\n```\n\nswitch文で書いても同じく絞り込みをコンパイラーが理解します。\n\n```ts twoslash\ntype UploadStatus = InProgress | Success | Failure;\ntype InProgress = { type: \"InProgress\"; progress: number };\ntype Success = { type: \"Success\" };\ntype Failure = { type: \"Failure\"; error: Error };\n// ---cut---\nfunction printStatus(status: UploadStatus) {\n  switch (status.type) {\n    case \"InProgress\":\n      console.log(`アップロード中:${status.progress}%`);\n      break;\n    case \"Success\":\n      console.log(\"アップロード成功\", status);\n      break;\n    case \"Failure\":\n      console.log(`アップロード失敗:${status.error.message}`);\n      break;\n    default:\n      console.log(\"不正なステータス: \", status);\n  }\n}\n```\n\n判別可能なユニオン型を使ったほうが、コンパイラーが型の絞り込みを理解できます。その結果、分岐処理が読みやすく、保守性も高くなります。\n\n## ディスクリミネータに使える型\n\nディスクリミネータに使える型は、リテラル型と`null`、`undefined`です。\n\n- リテラル型\n  - 文字列リテラル型: (例)`\"success\"`、`\"OK\"`など\n  - 数値リテラル型: (例)`1`、`200`など\n  - 論理値リテラル型: `true`または`false`\n- `null`\n- `undefined`\n\n上の`UploadStatus`では、文字列リテラル型をディスクリミネータに使いました。リテラル型には数値と論理値もあります。これらもディスクリミネータに使えます。\n\n```ts twoslash title=\"数値リテラル型のディスクリミネータ\"\ntype OkOrBadRequest =\n  | { statusCode: 200; value: string }\n  | { statusCode: 400; message: string };\n\nfunction handleResponse(x: OkOrBadRequest) {\n  if (x.statusCode === 200) {\n    console.log(x.value);\n  } else {\n    console.log(x.message);\n  }\n}\n```\n\n```ts twoslash title=\"論理値リテラル型のディスクリミネータ\"\n// prettier-ignore\ntype OkOrNotOk = \n  | { isOK: true; value: string } \n  | { isOK: false; error: string };\n\nfunction handleStatus(x: OkOrNotOk) {\n  if (x.isOK) {\n    console.log(x.value);\n  } else {\n    console.log(x.error);\n  }\n}\n```\n\n`null`と非nullの関係にある型もディスクリミネータになれます。次の例では、`error`プロパティが`null`または`Error`で、null・非nullの関係が成り立っています。\n\n```ts twoslash\n// prettier-ignore\ntype Result = \n  | { error: null; value: string } \n  | { error: Error };\n\nfunction handleResult(result: Result) {\n  if (result.error === null) {\n    console.log(result.value);\n  } else {\n    console.log(result.error);\n  }\n}\n```\n\n同様に`undefined`もundefined・非undefinedの関係が成り立つプロパティは、ディスクリミネータになります。\n\n```ts twoslash\n// prettier-ignore\ntype Result = \n  | { error: undefined; value: string } \n  | { error: Error };\n\nfunction handleResult(result: Result) {\n  if (result.error) {\n    console.log(result.error);\n  } else {\n    console.log(result.value);\n  }\n}\n```\n\n## ディスクリミネータを変数に代入する場合\n\nディスクリミネータを変数に代入し、その変数を条件分岐に使った場合も、型の絞り込みができます。\n\n```ts twoslash\ntype Shape =\n  | { type: \"circle\"; color: string; radius: number }\n  | { type: \"square\"; color: string; size: number };\n\nfunction toCSS(shape: Shape) {\n  const { type, color } = shape;\n  //      ^^^^ディスクリミネータ\n  switch (type) {\n    case \"circle\":\n      return {\n        background: color,\n        borderRadius: shape.radius,\n        //            ^?\n      };\n\n    case \"square\":\n      return {\n        background: color,\n        width: shape.size,\n        height: shape.size,\n        //      ^?\n      };\n  }\n}\n```\n\n<PostILearned>\n\n🦄TypeScriptの判別可能なユニオン型\n・ディスクリミネータを持つオブジェクトの型からなるユニオン型\n・if/switch分岐で型が絞り込みやすい\n\n🏷ディスクリミネータ\n・各オブジェクト共通のプロパティキー(しるし的なもの)\n・使える型は、リテラル型、null、undefined\n\n</PostILearned>\n\n## 関連情報\n\n[ユニオン型 (union type)](./union.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/discriminated-union"
    },
    {
      "title": "インターセクション型 (intersection type)",
      "content": "---\nsidebar_label: インターセクション型\n---\n\n# インターセクション型 (intersection type)\n\n考え方はユニオン型と相対するものです。ユニオン型が**どれか**を意味するならインターセクション型は**どれも**です。言い換えるとオブジェクトの定義を合成させることを指します。\n\nインターセクション型を作るためには合成したいオブジェクト同士を`&`で列挙します。\n\n```ts twoslash\ntype TwoDimensionalPoint = {\n  x: number;\n  y: number;\n};\n\ntype Z = {\n  z: number;\n};\n\ntype ThreeDimensionalPoint = TwoDimensionalPoint & Z;\n\nconst p: ThreeDimensionalPoint = {\n  x: 0,\n  y: 1,\n  z: 2,\n};\n```\n\nxy平面上の点を表す`TwoDimensionalPoint`を拡張してxyz平面上の点の`ThreeDimensionalPoint`に変換しました。\n\n## プリミティブ型のインターセクション型\n\nプリミティブ型のインターセクション型をつくることもできますが、作ると`never`という型ができます。\n\n```ts twoslash\n// @errors: 2322\ntype Never = string & number;\n\nconst n: Never = \"2\";\n```\n\nこの`never`型にはいかなる値も代入できません。使い道がまるでないように見えますが意外なところで役に立ちます。今回は説明を省きます。\n\n## インターセクション型を使いこなす\n\nシステムの巨大化に伴い、受け付けたいパラメーターが巨大化したとします。\n\n```ts twoslash\ntype Parameter = {\n  id: string;\n  index?: number;\n  active: boolean;\n  balance: number;\n  photo?: string;\n  age?: number;\n  surname: string;\n  givenName: string;\n  company?: string;\n  email: string;\n  phoneNumber?: string;\n  address?: string;\n  // ...\n};\n```\n\n一見してどのプロパティが必須で、どのプロパティが選択可かが非常にわかりづらいです。これをインターセクション型とユーティリティ型の`Required<T>`と`Partial<T>`を使いわかりやすく表記できます。ユーティリティ型については解説しているページがありますのでご覧ください。\n\n[Required&lt;T>](../type-reuse/utility-types/required.md)\n\n[Partial&lt;T>](../type-reuse/utility-types/partial.md)\n\n### 必須とそうでないパラメータのタイプエイリアスに分離する\n\n```ts twoslash\ntype Mandatory = {\n  id: string;\n  active: boolean;\n  balance: number;\n  surname: string;\n  givenName: string;\n  email: string;\n};\n\ntype Optional = {\n  index: number;\n  photo: string;\n  age: number;\n  company: string;\n  phoneNumber: string;\n  address: string;\n};\n```\n\n### `Required<T>, Partial<T>`をつける\n\n`Mandatory`は`Required<T>`を、`Optional`は`Partial<T>`をつけます。\n\n```ts twoslash\ntype Mandatory = Required<{\n  id: string;\n  active: boolean;\n  balance: number;\n  surname: string;\n  givenName: string;\n  email: string;\n}>;\n\ntype Optional = Partial<{\n  index: number;\n  photo: string;\n  age: number;\n  company: string;\n  phoneNumber: string;\n  address: string;\n}>;\n```\n\n### インターセクション型で合成する\n\nこれで最初に定義した`Parameter`と同じタイプエイリアスができました。\n\n```ts twoslash\ntype Mandatory = Required<{\n  id: string;\n  active: boolean;\n  balance: number;\n  surname: string;\n  givenName: string;\n  email: string;\n}>;\n\ntype Optional = Partial<{\n  index: number;\n  photo: string;\n  age: number;\n  company: string;\n  phoneNumber: string;\n  address: string;\n}>;\n// ---cut---\ntype Parameter = Mandatory & Optional;\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/intersection"
    },
    {
      "title": "型アサーション「as」(type assertion)",
      "content": "---\nsidebar_label: 型アサーション「as」\n---\n\n# 型アサーション「as」(type assertion)\n\nTypeScriptには、型推論を上書きする機能があります。その機能を型アサーション(type assertion)と言います。\n\nTypeScriptコンパイラーはコードをヒントに型を推論してくれます。その型推論は非常に知的ですが、場合によってはコンパイラーよりもプログラマーがより正確な型を知っている場合があります。そのような場合は、型アサーションを用いるとコンパイラーに型を伝えることができます。型アサーションはコンパイラに「私を信じて！私のほうが型に詳しいから」と伝えるようなものです。\n\n## 型アサーションの書き方\n\n型アサーションの書き方は2つあります。1つはas構文です。\n\n```ts twoslash\nconst value: string | number = \"this is a string\";\nconst strLength: number = (value as string).length;\n```\n\nもう1つはアングルブラケット構文(angle-bracket syntax)です。\n\n```ts twoslash\nconst value: string | number = \"this is a string\";\nconst strLength: number = (<string>value).length;\n```\n\nどちらを用いるかは好みですが、アングルブラケット構文はJSXと見分けがつかないことがあるため、as構文が用いられることのほうが多いです。\n\n## コンパイルエラーになる型アサーション\n\n型アサーションを使えば制限なく型の情報を上書きできるかというとそうではありません。たとえば、`number`型を`string`型にする型アサーションはコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2352\nconst num = 123;\nconst str: string = num as string;\n```\n\nこのエラーは「number型をstring型にするのは間違いです。お互いの型に共通する部分が少なすぎるからです」という内容です。\n\nこのように型アサーションはコンパイラーの型推論を上書きできるとは言っても、無茶な型の変換はできないようになっています。\n\nそれでも自分の書いた型アサーションが正しいという場合は、`unknown`型を経由することで上のようなエラーを出さないようにもできます。\n\n```ts twoslash\nconst num = 123;\nconst str: string = num as unknown as string; // OK\n```\n\n## 型アサーションとキャストの違い\n\n型アサーションは、他の言語のキャストに似ています。キャストとは、実行時にある値の型を別の型に変換することです。型アサーションは、実行時に影響しません。値の型変換はしないのです。あくまでコンパイル時にコンパイラーに型を伝えるだけです。コンパイラーはその情報を手がかりに、コードをチェックします。型アサーションはキャストではないため、TypeScriptでは型アサーションをキャストとは呼ばないことになっています。実行時に型変換をするには、そのためのロジックを書く必要があります。\n\n## 大いなる力には大いなる責任が伴う\n\n型アサーションには、コンパイラーの型推論を上書きする強力さがあります。そのため、プログラマーは型アサーションによってバグを産まないように十分注意する必要があります。型に関することはできるだけ、コンパイラーの型推論に頼ったほうが安全なので、型アサーションは、やむを得ない場合にのみ使うべきです。\n\n型アサーションを使う必要が出てきたら、それよりも先に、型ガードやユーザー定義型ガードで解決できないか検討してみるとよいでしょう。\n\n[制御フロー分析と型ガードによる型の絞り込み](../statements/control-flow-analysis-and-type-guard.md)\n\n[型ガード関数 (type guard function)](../functions/type-guard-functions.md)\n\n[アサーション関数 (assertion functions)](../functions/assertion-functions.md)\n\n## 型アサーションと型アノテーションの違い\n\n型アサーションと型アノテーション(type annotation)は名前が似ているためかしばしば混同されます。本書では型アノテーションを「型注釈」と表記しています。この2つはTypeScriptの異なる機能です。\n\n型注釈は、コンパイラーに「この変数に代入できるのはこの型だよ」と伝えるものです。コンパイラーは型注釈をヒントに、その型に値が代入可能かどうかをチェックし、代入できないことが分かり次第報告してきます。\n\n```ts twoslash\nlet value: number;\n//         ^^^^^^ 型注釈\n```\n\n一方、型アサーションはコンパイラーに「君はこの型だと思ってるかもしれないけど、本当はこの型だよ」と型推論の不正確さを伝えるものです。\n\n[変数宣言の型注釈 (type annotation)](type-annotation.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/type-assertion-as"
    },
    {
      "title": "型強制 (type coercion)",
      "content": "---\nsidebar_label: 型強制\n---\n\n# 型強制 (type coercion)\n\nJavaScriptにはデータ型がありますが、型が異なる2つの値に対し演算してもエラーにならない場合があります。たとえば、string型の`\"1\"`からnumber型の`1`を減算した場合、number型の`0`が計算結果として出てきます。\n\n```js\n\"1\" - 1; //=> 0\n```\n\nこれは型強制(type coercion)と呼ばれる仕組みがあるためです。型強制とは、型が異なる2つの値を処理するとき、暗黙的に別の型へ変換されることを言います。\n\n上の例では、string型の`\"1\"`がnumber型の`1`に型強制された上で、`- 1`が演算されたため`0`が計算結果になるわけです。\n\n型に厳しい言語では、型が異なる値同士の演算ができない言語もあるので、そのような言語に慣れている方は特に注意してください。\n\nちなみに、どんな型に型強制されるかは演算子によっても異なるので注意が必要です。たとえば、string型の`\"1\"`にnumber型の`1`を加算する場合は、string型の`\"11\"`が計算結果になります。これは、number型の`1`がstring型の`\"1\"`に型強制された上で、`\"1\" + \"1\"`の文字列結合の演算になるためです。\n\n```js\n\"1\" + 1; //=> \"11\"\n```\n\n<PostILearned>\n\n文字列と数値など型が異なる2つの値を演算するとき、暗黙に型変換される「型強制」がJavaScriptにはある。\n\n\"1\" - 1; //=> 0\n\"1\" + 1; //=> \"11\"\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/type-coercion"
    },
    {
      "title": "undefined型",
      "content": "# undefined型\n\nJavaScriptのundefinedは未定義を表すプリミティブな値です。変数に値がセットされていないとき、戻り値が無い関数、オブジェクトに存在しないプロパティにアクセスしたとき、配列に存在しないインデックスでアクセスしたときなどに現れます。\n\n```js twoslash\nlet name;\nconsole.log(name);\n// @log: undefined\n\nfunction func() {}\nconsole.log(func());\n// @log: undefined\n\nconst obj = {};\nconsole.log(obj.name);\n// @log: undefined\n\nconst arr = [];\nconsole.log(arr[1]);\n// @log: undefined\n```\n\n## undefinedリテラル\n\nJavaScriptでは同じプリミティブ型でも、boolean型やnumber型がリテラルがあるのに対し、`undefined`にはリテラルはありません。実は`undefined`は変数です。グローバル定数のようなものと理解して構いません。\n\n## undefinedの型注釈\n\nTypeScriptでundefined型の型注釈を行うには、`undefined`を用います。\n\n```ts twoslash\nconst x: undefined = undefined;\n```\n\n戻り値のない関数は`undefined`になりますが、TypeScriptで戻り値なしを型注釈で表現する場合、`undefined`ではなく`void`を用います。詳しくは関数の説明をご覧ください。\n\n[戻り値がない関数とvoid型 (void type)](../functions/void-type.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/undefined"
    },
    {
      "title": "型のメンタルモデル",
      "content": "---\nsidebar_label: 型のメンタルモデル\n---\n\n# 型のメンタルモデル\n\n## 型システムの背景理論\n\nプログラミング言語の型システムにはそれぞれ固有の世界観があり、言語ごとに型の機能が異なります。\n\nその一方で複数の言語で共通している機能もあり、それらのさまざまな型の機能は唐突にどこからともなく出現してきたわけではありません。背景として大きくは**型理論**(type theory)と呼ばれる数学的な研究分野があり、各言語の型システムは型理論に基づいて実装されています。\n\nたとえば、TypeScriptの`unknown`型や`never`型のような一見何のためにあるか分からないような型であっても、型理論においてはその役割や機能を一般的に説明することができます。これらの型はトップ型やボトム型と呼ばれる型の種類に分類され、部分型関係が作る階層構造の両端点に位置する型として振る舞います。\n\n<figure><figcaption>部分型階層の両端点に位置する型</figcaption>\n<img src=\"/reference/values-types-variables/mental-model-of-types/subtyping-end-points.svg\" width=\"480\" />\n</figure>\n\n型理論的な観点からの知識を持つことで似たような型システムを持つ他の言語においても型の機能について自然に推論することが可能になります。たとえばScalaというプログラミング言語では`Nothing`と呼ばれる型が型階層のボトムに位置することから`never`型と同じ働きをすることが推論できます。このように型について一般化された知識を使うことで、プログラミング言語をスイッチするような場合でもスムーズに機能の類推や学習を行うことができるようになります。\n\n型理論は非常に奥深く難解な分野でもありますが、その一方で比較的簡単に理解できて実用的にも役立つ概念も非常に多くあります。このドキュメントではそういった知識からTypeScriptの型の世界観、いわば**メンタルモデル**を構築するための知識の一部を紹介します。\n\n:::info より深く学ぶには\nこの章の内容を読んでみて型システムや型理論について興味が湧いたら、著名な入門書である『[型システム入門 プログラミング言語と型の理論](https://www.ohmsha.co.jp/book/9784274069116/)』の単純型や部分型付けの章などを読んでみることをオススメします。\n\n論理学的な知識があると推論規則などが比較的読みやすくなるので、東京大学出版会から出版されている『[論理学](https://www.utp.or.jp/book/b298898.html)』などの書籍を合わせて読むとよいかもしれません。また、型システム入門の読み方としては定理を隅々検証して読むというよりかは、知識や概念を入手する目的で面白そうなところを拾って読んでいくと意外と読みやすくなるのでぜひ挑戦してみてください。\n:::\n\n## 集合論的なデザイン\n\n型のメンタルモデル、つまり「型をどのように解釈するか」を考える上で非常に有用でありなが身近な数学的なツールがあります。それが集合論(set thoery)であり、この章では「型=集合」として考えることにします。\n\n一般に型(type)は集合(set)は異なる概念ですが、型理論と集合論の間には[密接な関連](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%83%E3%82%BB%E3%83%AB%E3%81%AE%E3%83%91%E3%83%A9%E3%83%89%E3%83%83%E3%82%AF%E3%82%B9)があります。\n\n特にTypeScriptにおいては、型を集合論的に扱えるようなデザインが意図的になされており、型を「**値の集合**」として捉えることで直感的に型を理解することができるようになっています。この見方は決して偏ったものではなく、[公式ドキュメント](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#types-as-sets)でも推奨されている型の考え方です。\n\n本章ではこのような集合論的な見方に立って型を考えることで、型の振る舞いについての自然な推論を行えるようなメンタルモデルを構築します。\n\n## 和集合と共通部分\n\n型を集合論的に扱えるお陰で、TypeScriptの型は集合が持つような演算の一部を利用することができます。\n\n集合の演算は集合から新しい集合を作り出すような操作であり、そのような演算にはいくつも種類があります。TypeScriptではそのような演算の中で和集合と共通部分を演算に相当する[ユニオン型](./union.md)と[インターセクション型](./intersection.md)が備わっています。\n\n```ts twoslash twoslash\ntype A = { a: string };\ntype B = { b: number };\n\n// AとBの和集合を表現する型\ntype Union = A | B;\n\n// AとBの共通部分を表現する型\ntype Intersection = A & B;\n```\n\n<figure><figcaption>和集合と共通部分に相当する型表現</figcaption>\n<img src=\"/reference/values-types-variables/mental-model-of-types/union-intersection-inclusion.svg\" width=\"480\" />\n</figure>\n\n直感的にはユニオン型はふたつの集合の和集合を表現する型であり、インターセクション型はふたつの型の共通部分を表現する型です。ユニオン型は特に型の絞り込み(narrowing)において特に重要な役割を果たし、型の和集合から選択的に型の候補を削っていくことができます。\n\n```ts twoslash title=\"型の絞り込みは和集合から集合を削っていく\"\ntype StrOrNum = string | number;\n\nfunction narrowUnion(param: StrOrNum) {\n  if (typeof param === \"string\") {\n    // stringとnumberの和集合からstringを削る\n    console.log(param.toUpperCase());\n  } else {\n    // 残された集合はnumber\n    console.log(param * 3);\n  }\n}\n```\n\nこのふたつの型は複数の型から新しい型を合成できるという点で演算として重要ですが、特定の型そのものが集合としてどのように解釈できるかを次に紹介する３つの型で解説していきます。\n\n## ユニット型\n\nここからは、TypeScriptにおいて型は値の集合として扱えることができることを具体例を交えて説明していきます。\n\nまずは単に型を「値の集合」であると考えてください。たとえば、`number`型という数値を表す型ですが、この型が集合であるとすると、その要素は具体的な`number`型の値である数値です。たとえば`1`や`3.14`などの数値がこの集合の要素となります。[number型](../values-types-variables/number/README.md)のページで述べているようにnumber型で表現可能な範囲は有限であり、それらの範囲の要素に`NaN`と`Infinity`などの特殊な定数を加えた集合が`number`型の集合ということになります。\n\nさて、重要な型の概念として**ユニット型**(unit type)という型の種類があります。ユニット型とは文字通りの単位的な型であり、型の要素として値をひとつしか持たないような型です。集合論においては単一の要素からなる集合は単位集合(unit set)や単集合(singleton set)など呼ばれます。\n\n型の世界での単位集合に相当するものがユニット型であり、たとえば、PHPでは`null`という単一の値を持つ`null`型がユニット型に相当し、KotlinやScalaでは分かりやすく`Unit`型という名前の型がユニット型です。\n\nTypeScriptでは`null`という単一の値を持つ`null`型と、`undefined`という単一の値を持つ`undefined`型がユニット型に相当します。\n\n```ts twoslash title=\"nullとundefinedはユニット型\"\ntype N = null;\nconst n: N = null;\n\ntype U = undefined;\nconst u: U = undefined;\n```\n\n他にもTypeScriptには[リテラル型](../values-types-variables/literal-types.md)という型がありましたが、このリテラル型もユニット型に相当します。\n\n```ts twoslash title=\"リテラル型はユニット型\"\ntype Unit = 1;\nconst one: Unit = 1;\n```\n\nリテラル型は値リテラルをそのまま型として表現できる型であり、`number`や`string`などのプリミティブ型にはそれぞれ具体的な値のリテラルによって作成されるリテラル型が存在します。\n\n- 文字列リテラル型 : `\"st\"`, `\"@\"`, ...\n- 数値リテラル型 : `1`, `3.14`, `-2`, ...\n- 真偽値リテラル型 : `ture`, `false` のふたつのみ\n\n型は値の集合でしたが、具体的な値はそのリテラル型と一対一で対応します。\n\n集合の要素の個数は「濃度(cardinality)」と呼ばれる概念によって一般化され、基数という数によって表記されます。たとえば、要素がひとつしかない単位集合の濃度は１です。つまり、型を集合としてみなしたときのユニット型の濃度は１ということになります。\n\nそれでは濃度が２、つまり要素の個数が二個からなるシンプルな型について考えてみましょう。たとえば、真偽値を表す `boolean` という型の要素(値)は`true`と`false`のみであり、`boolean`型の変数にはそれら以外の値を割り当てることはできません。したがって`boolean`型は濃度2の集合としてみなせます。\n\n```ts twoslash\nconst b1: boolean = true;\nconst b2: boolean = false;\n// @errors: 2322\nconst b3: boolean = 1;\n```\n\nリテラル型について思い出すと真偽値についてもそれぞれリテラル型`true`と`false`が存在しました。これらの型はそれぞれがひとつの値だけを持つユニット型でした。\n\nリテラル型は具体的な値と一対一の対応となります。型の集まりには集合演算が備わっていたので、リテラル型を要素として新しい集合を作ってみると考えてもよいでしょう。ふたつの単集合`true`と`false`を合成してふたつの型(あるいは値)から和集合を作成すると濃度2の型を得ることができます。\n\n```ts twoslash title=\"true と false の和集合\"\ntype Bool = true | false;\n```\n\nこのようにユニオン型で合成した型`Bool`は`boolean`型と同一の型となります。\n\n## ボトム型\n\nユニット型は値をひとつしか持たない型ですが、値をまったく持たないような型も存在しています。そのような型を**ボトム型**(bottom type)と呼びます。型が集合であるとするとき、ボトム型は空集合(empty set)に相当し、空型(empty type)とも呼ばれることがあります。\n\nボトム型は値をまったく持たない型として、例外が発生する関数の返り値の型として利用されますが、TypeScriptでのボトム型は部分型階層の一番下、つまりボトムの位置に存在している`never`型となります。\n\n```ts twoslash\nfunction neverReturn(): never {\n  throw new Error(\"決して返ってこない関数\");\n}\n```\n\n`never`型は集合としては空集合であり、値をひとつも持たないため、その型の変数にはどのような要素も割り当てることができません。\n\n```ts twoslash\n// @errors: 1206 2322\nconst n: never = 42;\n```\n\n## トップ型\n\nボトム型が値をまったく持たない型なら、それとは逆にすべての値を持つような型も存在しています。そのような型を**トップ型**(top type)と呼びます。\n\nトップ型はすべての値を持っており、その型の変数にはあらゆる値を割り当てることができます。オブジェクト指向言語であれば大抵は型階層のルート位置、つまりトップ位置に存在している型であり、TypeScriptでは`unknown`型がトップ型に相当します。\n\n```ts twoslash\nconst u1: unknown = 42;\nconst u2: unknown = \"st\";\nconst u3: unknown = { p: 1 };\nconst u4: unknown = null;\nconst u5: unknown = () => 2;\n```\n\nボトム型が空集合に相当するなら、トップ型は全体集合に相当すると言えるでしょう。なおTypeScriptでは`{} | null | undefind`という特殊なユニオン型を`unknown`型相当として扱い、相互に割当可能としています。\n\n```ts twoslash twoslash title=\"unknown型相当の特殊なユニオン型\"\ndeclare const u: unknown;\nconst t: {} | null | undefined = u;\n```\n\n`{}`はプロパティを持たないオブジェクトを表現する空のobject型であり、この型はあらゆるオブジェクトの型と`null`と`undefined`を除くすべてのプリミティブ型を包含しています。したがって、`unknown`という全体集合は上記のような３つの集合に分割できると考えることもできます。\n\nTypeScriptには`unknwon`型以外にもうひとつ特殊なトップ型があります。それが`any`型です。`any`型には`unknown`型と同様にあらゆる型の値を割当可能です。\n\n```ts twoslash\nconst a1: any = 42;\nconst a2: any = \"st\";\nconst a3: any = { p: 1 };\nconst a4: any = null;\nconst a5: any = () => 2;\n```\n\n`any`型の特殊性はトップ型としてあらゆる型からの割当が可能だけでなく、`never`型を除くあらゆる型へも割当可能な点です。\n\n```ts twoslash\ndeclare const a: any;\n\nconst n1: unknown = a;\nconst n2: {} = a;\nconst n3: number = a;\nconst n4: 1 = a;\n// @errors: 2322\nconst n5: never = a;\n```\n\n`any`型は`never`型を除けばあらゆる型へも割当可能なため一見するとボトム型のように振る舞っているように見えますが、実際にはボトム型ではありません。\n\nTypeScriptは元来、JavaScriptに対して**オプショナルに型付けを行う**という言語であり、型注釈を省略して型推論ができない場合には未知の型を暗黙的に`any`型として推論します。このような状況において`any`型はあらゆる型からの割当が可能であるだけでなく、あらゆる型への割当が可能であることが必要であり、それによって型注釈がないJavaScriptに対して漸進的に型を付けていくことが可能になります。\n\n実は`any`型は`unknown`型がTypeScriptに導入されるまで唯一のトップ型として機能していましたが、純粋にあらゆる型の上位型になる部分型関係のトップ位置の型として機能する`unknown`型が導入されたことで部分型関係の概念が明瞭になりました。\n\n## 部分型関係の解釈\n\n部分型関係とはそもそも「型Bが型Aの部分型であるとき、Aの型の値が求められる際にBの型の値を指定できる」という型同士の互換性に関わる関係です。関数型を除く通常の型については、ここまで見てきた通り型を集合として解釈すれば部分型関係は**集合の包含関係**に相当します。\n\n[部分型関係の説明](./structural-subtyping.md)において、型と型の関係性は**階層構造**で捉えることができると述べましたが、集合の包含関係は階層構造について少し見方を変えた構造であると言えます。\n\n<figure><figcaption>集合的と見方と階層的な見方</figcaption>\n<img src=\"/reference/values-types-variables/mental-model-of-types/2way-views-types.svg\" width=\"480\" />\n</figure>\n\nトップ型である`unknown`型はあらゆる型の基本型、つまり上位型として振る舞い、あらゆる型は`unknown`型の部分型となります。したがって、型を集合として解釈したとき、`unknown`型はTypeScriptにおけるあらゆる値を含む集合となります。つまり全体集合であり、あらゆる型は`unknown`型の部分集合とみなすことができます。\n\nそれとは逆に、ボトム型である`never`型はあらゆる型の部分型となります。したがって、型を集合として解釈したとき、`never`型はTypeScriptにおけるどのような値も含まない集合、つまり空集合としてみなすことができます。\n\nこのように部分型関係を集合の包含関係として捉えることで、より直感的に型の互換性についての推論が可能となります。\n\nたとえばふたつの集合の和集合はその共通部分を包含します。ユニオン型とインターセクション型は和集合と共通部分に相当していたので、包含関係からインターセクション型がユニオン型の部分型となることが推論されます。実際に検証してみると、ユニオン型の変数にインターセクション型の変数を割りあてることが可能です。\n\n```ts twoslash\ntype A = { a: string };\ntype B = { b: number };\n\ntype Union = A | B;\ntype Intersection = A & B;\n\nconst a_and_b: Intersection = { a: \"st\", b: 42 };\nconst a_or_b: Union = a_and_b;\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/mental-model-of-types"
    },
    {
      "title": "undefinedとnullの違い",
      "content": "# undefinedとnullの違い\n\n多くのプログラミング言語で「値がない」を表現する方法は、nullなど1通りです。しかし、JavaScriptでは「値がない」に相当する表現にnullとundefinedの2通りがあります。他の言語からJavaScriptに来た人が驚き、使い分けに悩む部分です。ここでは、nullとundefinedの仕様上の違い、実際のコーディングでどう使い分けるべきかについて説明します。\n\n## 意味合いの違い\n\nundefinedとnullは大きなくくりで「値がない」ことを意味する点は共通しています。意味的な違いがあるとしたら、undefinedは「値が代入されていないため、値がない」、nullは「代入すべき値が存在しないため、値がない」という微妙な違いです。\n\nこの意味的な違いを厳密につきつめてコーディングするのは、入門者には難しいものです。使い分けに客観的な基準があるわけではないためです。もしどちらを使うべきか迷ったらundefinedを使っておくほうが無難です。\n\n## 言語仕様上の違い\n\nundefinedとnullには言語の仕様上の違いがあります。これは意味合いの違いのような漠然としたものではなく、はっきりと確認できるものです。\n\n### nullは自然発生しない\n\nundefinedは言語仕様上、プログラマーが明示的に使わなくても、自然に発生してくるものです。たとえば、変数を宣言したときに初期値がなければJavaScriptはその変数にundefinedを代入します。\n\n```js twoslash\nlet value;\nconsole.log(value);\n// @log: undefined\n```\n\nオブジェクトに存在しないプロパティや配列にない要素にアクセスしたときも、自動的にundefinedになります。\n\n```js twoslash\nconst obj = {};\nconsole.log(obj.foo);\n// @log: undefined\nconst arr = [];\nconsole.log(arr[0]);\n// @log: undefined\n```\n\n戻り値がない関数の戻り値を取得したときもundefinedになります。\n\n```js twoslash\nfunction func() {}\nconsole.log(func());\n// @log: undefined\n```\n\n一方、nullはプログラマーが意図的に使わない限り発生しません。JavaScriptとしてはnullを提供することがないということです。ただし、一部のDOM系のAPIはnullを返すこともあるため、ライブラリによってはnullと出会うことはあります。\n\n### undefinedは変数\n\nundefinedもnullもプリミティブ型の値という点は共通していますが、undefinedは変数でありnullはリテラルです。nullはリテラルなのでnullという名前の変数を作ることはできません。一方でundefinedはリテラルではなく変数なので、undefinedという変数を作ることはできます。\n\n### typeof演算子\n\ntypeof演算子の結果がundefinedとnullで変わってきます。undefinedはtypeofの結果がプリミティブ名を指す\"undefined\"になるのに対し、nullは\"null\"ではなく\"object\"になります。\n\n```js twoslash\ntypeof undefined;\n// @log: \"undefined\"\ntypeof null;\n// @log: \"object\"\n```\n\n### JSON\n\nオブジェクトプロパティの値にundefinedを用いたとき、そのオブジェクトをJSON.stringifyでJSON化したときに、オブジェクトプロパティは削除されます。一方、プロパティの値がnullのときは、JSON化したときに値が保持されます。\n\n```js twoslash\nconsole.log(JSON.stringify({ foo: undefined }));\n// @log: {}\nconsole.log(JSON.stringify({ foo: null }));\n// @log: {\"foo\": null}\n```\n\n## undefinedとnullの使い分け\n\nundefinedとnullをどう使い分けたらいいかは大きな論争を呼ぶテーマです。プログラマーの中には、undefinedだけを使うべきと言う人もいれば、nullを使うべきという人もいます。また、undefinedとnullの意味合いの違いをしっかり理解して、使い分けるべきと主張する人もいます。逆に、深く考えすぎずに使うというスタンスの人もいます。\n\n特にこだわりがないのなら、TypeScriptではnullは使わずにundefinedをもっぱら使うようにするのがお勧めです。とは言っても、nullを返すAPIがなくはないので、自分が新たにコードを書く部分においては、nullは使わずにundefinedにできるだけ寄せるといったイメージです。APIが返すnullをundefinedに変換していってもいいですが、変換コードだらけになるような場合は、nullをそのまま許容するといった折衷案もよいです。\n\n### 使い分け意識を育てる労力は、それに見合うメリットが少ない\n\n2種類を使い分けるとなると、コードの各所でどちらを使うべきかの意思決定が必要になります。意思決定は個人作業ならまだしも、チームワークとなるとハードルが上がってきます。チームで「こういう場合はundefinedを使うべき」「こういうときはnullを使う」といったルールと具体例を共通認識として持つ必要がでてきます。共通認識が確立されていないと、コーディング中に質問が出てきたり、コードレビューで指摘されて手直しが発生したりと、あまり本質的でないところで開発が一時停止していまいがちです。使い分けをするために、ルール策定や意識のすり合わせすることは不可能ではありませんが、その労力に見合うほど、undefinedとnullを使い分けるメリットは大したものではないというが実際のところです。\n\n一方で、「nullは使わずundefinedに統一しよう」はシンプルなルールです。これなら共通認識として持つことがしやすく、チームワークもしやすくなります。実際にTypeScriptの開発チームでは[「nullは使わない」というたった1行のシンプルなガイドライン](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#null-and-undefined)を示し、数多くの開発者が参加しやすくなるようにしています。\n\n### undefinedに統一するほうが簡単\n\n「値がない」ことを意味するものがundefinedとnullの2種類あることが混乱の元なので、どちらか一方を使うようにするほうがコーディング上の意思決定を減らせます。なので、nullに寄せていく方法も考えられます。しかし、それはお勧めしません。undefinedはいたるところで自然に発生してくるので、それらをすべてnullにしようとすると、記述量がどんどん増えていくからです。\n\n変数宣言で初期値をnullにする程度なら簡単ですが、存在しないオブジェクトプロパティや配列要素にアクセスしたときにもnullを返すようにするところまでやろうとすると難しくなってきます。したがって、統一するとしたらundefinedに寄せるほうが現実的です。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/undefined-vs-null"
    },
    {
      "title": "列挙型(enum)の問題点と代替手段",
      "content": "# 列挙型(enum)の問題点と代替手段\n\nTypeScriptの列挙型(enum)にはいくつか問題点が指摘されていてます。ここでは、その問題点と代替手段を説明します。\n\n## 列挙型の問題点\n\n### 列挙型はTypeScript独自すぎる\n\nTypeScriptは、JavaScriptを拡張した言語です。拡張といっても、むやみに機能を足すのではなく、追加するのは型の世界に限ってです。こういった思想がTypeScriptにはあるため、型に関する部分を除けば、JavaScriptの文法から離れすぎない言語になっています。\n\nJavaScriptの文法からドラスティックに離れたAltJSもあります。その中で、TypeScriptが多くの開発者に支持されているのは、JavaScriptから離れすぎないところに魅力があるからというのもひとつの要因です。\n\nTypeScriptの列挙型に目を向けると、構文もJavaScriptに無いものであるだけでなく、コンパイル後の列挙型はJavaScriptのオブジェクトに変化したりと、型の世界の拡張からはみ出している独自機能になっています。TypeScriptプログラマーの中には、この点が受け入れられない人もいます。\n\n### 数値列挙型には型安全上の問題がある\n\n数値列挙型は、`number`型なら何でも代入できるという型安全上の問題点があります。次の例は、値が`0`と`1`のメンバーだけからなる列挙型ですが、実際にはそれ以外の数値を代入できてしまいます。\n\nこの問題はTypeScript5.0未満で発生します。\n\n```ts twoslash\n// TypeScript v4.9.5\n// @noErrors\nenum ZeroOrOne {\n  Zero = 0,\n  One = 1,\n}\nconst zeroOrOne: ZeroOrOne = 9; // コンパイルエラーは起きません！\n```\n\nTypeScript5.0からは改善されており、コンパイルエラーとなります。\n\n```ts twoslash\n// TypeScript v5.0.4\n// @errors: 2322\nenum ZeroOrOne {\n  Zero = 0,\n  One = 1,\n}\nconst zeroOrOne: ZeroOrOne = 9;\n```\n\n列挙型には、列挙型オブジェクトに値でアクセスすると、メンバー名を得られる仕様があります。メンバーに無い値でアクセスしたら、コンパイルエラーになってほしいところですが、そうなりません。\n\n```ts twoslash\nenum ZeroOrOne {\n  Zero = 0,\n  One = 1,\n}\n\nconsole.log(ZeroOrOne[0]); // これは期待どおり\n// @log: \"Zero\"\nconsole.log(ZeroOrOne[9]); // これはコンパイルエラーになってほしいところ…\n// @log: undefined\n```\n\n### 文字列列挙型だけ公称型になる\n\nTypeScriptの型システムは、[構造的部分型](../structural-subtyping.md)を採用しています。ところが、文字列列挙型は例外的に公称型になります。\n\n```ts twoslash\n// @errors: 2322\nenum StringEnum {\n  Foo = \"foo\",\n}\nconst foo1: StringEnum = StringEnum.Foo; // コンパイル通る\nconst foo2: StringEnum = \"foo\"; // コンパイルエラーになる\n```\n\nこの仕様は意外さがある部分です。加えて、数値列挙型は公称型にならないので、不揃いなところでもあります。\n\n## 列挙型の代替案\n\n列挙型の代替案をいくつか提示します。ただし、どの代替案も列挙型の特徴を100%再現するものではありません。次の代替案は目的や用途に合う合わないを判断して使い分けてください。\n\n### 列挙型の代替案1: ユニオン型\n\nもっともシンプルな代替案はユニオン型を用いる方法です。\n\n```ts twoslash\ntype YesNo = \"yes\" | \"no\";\n\nfunction toJapanese(yesno: YesNo) {\n  switch (yesno) {\n    case \"yes\":\n      return \"はい\";\n    case \"no\":\n      return \"いいえ\";\n  }\n}\n```\n\nユニオン型とシンボルを組み合わせる方法もあります。\n\n```ts twoslash\nconst yes = Symbol();\nconst no = Symbol();\ntype YesNo = typeof yes | typeof no;\n\nfunction toJapanese(yesno: YesNo) {\n  switch (yesno) {\n    case yes:\n      return \"はい\";\n    case no:\n      return \"いいえ\";\n  }\n}\n```\n\n### 列挙型の代替案2: オブジェクトリテラル\n\nオブジェクトリテラルを使う方法もあります。\n\n```ts twoslash\nconst Position = {\n  Top: 0,\n  Right: 1,\n  Bottom: 2,\n  Left: 3,\n} as const;\n\ntype Position = (typeof Position)[keyof typeof Position];\n// 上は type Position = 0 | 1 | 2 | 3 と同じ意味になります\n\nfunction toJapanese(position: Position) {\n  switch (position) {\n    case Position.Top:\n      return \"上\";\n    case Position.Right:\n      return \"右\";\n    case Position.Bottom:\n      return \"下\";\n    case Position.Left:\n      return \"左\";\n  }\n}\n```\n\n## まとめ\n\n列挙型の問題点と代替案についても説明しました。特に列挙型は型安全上の問題もあるため、列挙型を積極的に使うかどうかは、よく検討してください。\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/enum/enum-problems-and-alternatives-to-enums"
    },
    {
      "title": "列挙型 (enum)",
      "content": "---\nsidebar_label: 列挙型\nslug: /reference/values-types-variables/enum\n---\n\n# 列挙型 (enum)\n\nTypeScriptでは、列挙型(enum)を用いると、定数のセットに意味を持たせたコード表現ができます。\n\n列挙型を宣言するには、`enum`キーワードの後に列挙型名とメンバーを書きます。次の例では、`Position`が列挙型名で、`Top`、`Right`、`Bottom`、`Left`がメンバーになります。\n\n```ts twoslash\nenum Position {\n  Top,\n  Right,\n  Bottom,\n  Left,\n}\n```\n\n`enum`キーワードはTypeScript独自のものです。なのでJavaScriptにコンパイルすると次のようなコードになります。\n\n<!--prettier-ignore-->\n```js\nvar Position;\n(function (Position) {\n    Position[Position[\"Top\"] = 0] = \"Top\";\n    Position[Position[\"Right\"] = 1] = \"Right\";\n    Position[Position[\"Bottom\"] = 2] = \"Bottom\";\n    Position[Position[\"Left\"] = 3] = \"Left\";\n})(Position || (Position = {}));\n```\n\nご覧のとおり、列挙型名と同じ名前のオブジェクトが定義されます。列挙型のメンバーはオブジェクトのプロパティーになります。値は0からの連番になります。\n\n```ts twoslash\nenum Position {\n  Top,\n  Right,\n  Bottom,\n  Left,\n}\n// ---cut---\nconsole.log(Position.Top); // 0\nconsole.log(Position.Right); // 1\nconsole.log(Position.Bottom); // 2\n```\n\n列挙型名は型として扱うことができます。\n\n```ts twoslash\nenum Position {\n  Top,\n  Right,\n  Bottom,\n  Left,\n}\n// ---cut---\nlet position: Position;\n//            ^^^^^^^^型\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/enum/README"
    },
    {
      "title": "文字列列挙型 (string enum)",
      "content": "---\nsidebar_label: 文字列列挙型\n---\n\n# 文字列列挙型 (string enum)\n\nTypeScriptの列挙型では、メンバーの値に文字列も使えます。文字列で構成された列挙型は文字列列挙型(string enum)と呼ばれます。\n\n```ts twoslash\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/enum/string-enum"
    },
    {
      "title": "数値列挙型 (numeric enum)",
      "content": "---\nsidebar_label: 数値列挙型\n---\n\n# 数値列挙型 (numeric enum)\n\nTypeScriptの数値列挙型(numeric enum)はもっとも典型的な列挙型です。メンバーの値は上から順に`0`からの連番になります。\n\n```ts twoslash\nenum Position {\n  Top, // 0\n  Right, // 1\n  Bottom, // 2\n  Left, // 3\n}\n```\n\nメンバーは値を代入できます。値を代入した場合、それに続くメンバーは連番になります。\n\n```ts twoslash\nenum Position {\n  Top = 1, // 1\n  Right, // 2\n  Bottom, // 3\n  Left, // 4\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/enum/numeric-enum"
    },
    {
      "title": "varはもう使わない",
      "content": "# varはもう使わない\n\n`var`は古い変数宣言の方法です。`var`にはいくつかの問題点がありました。それを解決するために、ES2015で`let`と`const`が導入されました。ここでは、`var`とその問題点を説明します。新たにコードを書く場合には`var`は使わずに`let`と`const`を使うことを推奨します。\n\n## varの変数宣言\n\n`var`は次のように書くことで変数を宣言できます。\n\n```js twoslash\nvar name = \"taro\";\n```\n\n初期値を省略した変数宣言もできます。その場合の変数値は`undefined`です。\n\n```js twoslash\nvar name;\n```\n\n## varの問題点\n\n`var`による変数宣言には気をつけるべき挙動が何点か存在します。\n\n### 同名の変数宣言\n\n`var`の変数宣言では同じ変数名で宣言をした場合にエラーとならずに、後から宣言された変数が有効となります。これは思いがけず既存の変数を書き換えてしまい、意図しない結果を出力する可能性があります。\n\n```js twoslash\nfunction test() {\n  var x = 1;\n  var x = 2;\n  console.log(x);\n}\n```\n\n`let`と`const`では、同名の変数宣言はエラーになるようになっています。\n\n```ts twoslash\nlet x = 1;\nlet x = 2;\n// @error: SyntaxError: Identifier 'x' has already been declared\n\nconst y = 1;\nconst y = 2;\n// @error: SyntaxError: Identifier 'y' has already been declared\n// @noErrors\n```\n\n### グローバル変数の上書き\n\n`var`はグローバル変数として定義されたときに、`window`オブジェクトのプロパティとして定義されるため、既存のプロパティを上書きする危険性があります。\n\nたとえば、ブラウザ上で`innerWidth`変数をグローバル変数として定義してしまうと、標準APIの`window.innerWidth`が上書きされるため、ブラウザの幅を変更しても常に同じ値が返ってくるようになってしまいます。\n\n```js twoslash\nvar innerWidth = 10;\nconsole.log(window.innerWidth);\n// @log: 10\n```\n\n`let`や`const`はグローバルなスコープで定義されることはないため、`window`オブジェクトのプロパティを不用意に上書きする心配はありません。\n\n```ts twoslash\nconst innerWidth = 10;\nconsole.log(window.innerWidth);\n// @log: 500\n// @noErrors\n```\n\n[変数のスコープ (scope)](../statements/variable-scope.md)\n\n### 変数の巻き上げ\n\nJavaScriptで宣言された変数はスコープの先頭で変数が生成されます。これは**変数の巻き上げ**と呼ばれています。`var`で宣言された変数は、スコープの先頭で生成されて`undefined`で値が初期化されます。次の例では`greeting`変数への参照はエラーとならずに`undefined`となります。\n\n```ts twoslash\nconsole.log(greeting);\n// @log: undefined\nvar greeting = \"こんにちは\";\n\n// ↓ 巻き上げの影響で実際はこう実行される\n\n// @noErrors\nvar greeting;\nconsole.log(greeting);\n// @log: undefined\ngreeting = \"こんにちは\";\n```\n\n`var`での変数巻き上げでは参照エラーとならないため、意図せずに`undefined`の値を参照し予期せぬバグが発生する危険性があります。\n\n`let`と`const`では、宣言前の変数を参照すると`Reference Error`が発生します。\n\n```ts twoslash\nconsole.log(x);\n// @errors: 2448 2454\nlet x = 1;\n\nconsole.log(y);\n// @errors: 2448 2454\nconst y = 2;\n```\n\nただ、ここで注意すべきなのが`let`と`const`の場合でも**変数の巻き上げは発生している**という点です。では、なぜ`Reference Error`が発生するのでしょうか？\n\n`var`は変数の巻き上げが発生したタイミングで`undefined`で**変数を初期化している**ため、値の参照が可能となっていました。それに対して`let`と`const`は変数の巻き上げが発生しても変数が評価されるまで**変数は初期化されません**。そのため、初期化されていない変数を参照するためReference Errorが発生しているのです。\n\n次の例では`let`や`const`で変数の巻き上げが発生しないなら`console.log(x)`の評価のタイミングで関数の先頭で宣言されている`var x = 1`が参照されて`1`が出力されるはずです。しかし、実際は`let`で宣言された変数`x`がブロックスコープ内で初期化されていない状態で生成されるため、未初期化の`x`を参照してReference Errorが発生します。\n\n```ts twoslash\n// @errors: 2448 2454\nfunction output() {\n  var x = 1;\n  {\n    console.log(x);\n    let x = 2;\n  }\n}\n\noutput();\n```\n\n### スコープ\n\nJavaScript では`var`で宣言された変数のスコープは関数となるため、`{}`の中で変数宣言をしても最初に定義した変数`x`は上書きされます。\n\n<!--prettier-ignore-->\n```ts twoslash\nfunction print() {\n  var x = 1;\n  if (true) {\n    var x = 2;\n    console.log(x);\n// @log: 2\n  }\n  console.log(x);\n// @log: 2\n}\n```\n\n`let`と`const`のスコープはブロックスコープです。次の例は`var`では変数`x`が上書きされていましたが、ここではブロックスコープ内で異なる変数として別々に定義されています。\n\n<!--prettier-ignore-->\n```ts twoslash\nfunction print() {\n  const x = 1;\n  if (true) {\n    const x = 2;\n    console.log(x);\n// @log: 2\n  }\n  console.log(x);\n// @log: 1\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/vars-problems"
    },
    {
      "title": "null型",
      "content": "# null型\n\nJavaScriptのnullは値がないことを示す値です。\n\n## nullリテラル\n\nJavaScriptのnullリテラルは`null`です。\n\n```ts twoslash\nconst x = null;\n```\n\n## nullの型注釈\n\nTypeScriptでnull型を型注釈するには`null`を用います。\n\n```ts twoslash\nconst x: null = null;\n```\n\n## typeof演算子の注意点\n\nJavaScriptには値の型を調べるtypeof演算子があります。`null`に対して`typeof`を用いると`\"object\"`が返るので注意が必要です。\n\n```ts twoslash\nconsole.log(typeof null);\n// @log: \"object\"\n```\n\ntypeof演算子の詳細は「typeof演算子」のセクションをご覧ください。\n\n[typeof演算子 (typeof operator)](typeof-operator.md)\n",
      "url": "https://typescriptbook.jp/reference/values-types-variables/null"
    },
    {
      "title": "exactOptionalPropertyTypes",
      "content": "---\ndescription: オプションプロパティにundefinedの代入することを禁止する\n---\n\n# exactOptionalPropertyTypes\n\n`exactOptionalPropertyTypes`はオプションプロパティに`undefined`の代入することを禁止するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 4.4\n- TypeScript公式が有効化推奨\n\n## 解説\n\n今までオプション修飾子は値を設定しないことに加えて`undefined`を意図的に設定することができました。\n\n```ts twoslash\ninterface User {\n  name: string;\n  nationality?: \"India\" | \"China\";\n}\n\nconst user1: User = {\n  name: \"Srinivasa Aiyangar Ramanujan\",\n  nationality: \"India\",\n};\n\nconst user2: User = {\n  name: \"Sergei Vasilevich Rachmaninov\",\n  nationality: undefined,\n};\n\nconst user3: User = {\n  name: \"Yekaterina II Alekseyevna\",\n};\n```\n\n値が未定義であることと値が`undefined`であることは厳密には動作が異なります。たとえば`Object.keys()`は最たる例で、上記の`user1, user2, user3`にそれぞれ`Object.keys()`を適用すれば結果は次のようになります。\n\n```ts twoslash\n// user1\n[\"name\", \"nationality\"];\n// user2\n[\"name\", \"nationality\"];\n// user3\n[\"name\"];\n```\n\nこの差異が意図しない実行時エラーを生むことがあります。意図する値が設定されていれば(この場合`'India' | 'China'`)`nationality`は`Object.keys()`に含まれるべきですが`undefined`のときは結局その先で値の存在チェックが必要になります。\n\nこのオプションを有効にすると`interface, type`でオプション修飾子を持つキーはその値がキー自体を持たないようにしなければなりません。先ほどの例では`undefined`を代入した`user2`で次のようなエラーが発生します。\n\n```ts twoslash\n// @exactOptionalPropertyTypes: true\n// @errors: 2375\ninterface User {\n  name: string;\n  nationality?: \"India\" | \"China\";\n}\n\nconst user1: User = {\n  name: \"Srinivasa Aiyangar Ramanujan\",\n  nationality: \"India\",\n};\n\nconst user2: User = {\n  name: \"Sergei Vasilevich Rachmaninov\",\n  nationality: undefined,\n};\n\nconst user3: User = {\n  name: \"Yekaterina II Alekseyevna\",\n};\n```\n\nどうしてもキーに`undefined`も指定したい場合はオプション修飾子に加えて`undefined`のユニオン型を付加してください。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/exactoptionalpropertytypes"
    },
    {
      "title": "strict",
      "content": "---\ndescription: strict系のオプションを一括で有効化する\ntags: [strict]\n---\n\n# strict\n\n`strict`はstrict系のコンパイラオプションを一括で有効化するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 2.3\n- TypeScript公式が有効化推奨\n\n## 解説\n\nこのオプションは**TypeScript4.4時点で**次の8個のオプションをすべて有効にしていることと同じです。スクラッチから開発するのであれば有効にしておいて差し支えないでしょう。\n\n- noImplicitAny\n- strictNullChecks\n- strictFunctionTypes\n- strictBindCallApply\n- strictPropertyInitialization\n- noImplicitThis\n- useUnknownInCatchVariables\n- alwaysStrict\n\nこの説明にTypeScriptのバージョンが明記されているのは、今後のバージョンで**オプションが追加または廃止されることがありうる**からです。より安定したオプションを設定したい場合は`strict`ではなく個々のオプションを有効にしてください。このオプションを有効にして個々のオプションを無効にした場合個々の設定が優先されます。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/strict"
    },
    {
      "title": "noPropertyAccessFromIndexSignature",
      "content": "---\ndescription: インデックス型のプロパティ参照に[]を必須にする\n---\n\n# noPropertyAccessFromIndexSignature\n\n`noPropertyAccessFromIndexSignature`はインデックス型のプロパティ参照に`[]`を必須にするコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 4.2\n\n## 解説\n\n`noUncheckedIndexedAccess`と同様にインデックス型を持つオブジェクトに対する型評価です。インデックス型に対するアクセスをインデックス記法に強制します。\n\nドット記法とインデックス記法についてですが、次のようにあるオブジェクトがあるとしてドット(`.`)でプロパティアクセスをしているものがドット記法、ブラケット(`[]`)でアクセスをしているものがインデックス記法です。\n\n```ts twoslash\ntype SystemTerms = {\n  en: string;\n  [key: string]: string;\n};\n\nconst butterfly: SystemTerms = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n\n// dot syntax\nbutterfly.en;\n// indexed syntax\nbutterfly[\"en\"];\n```\n\n`SystemTerms`は`noUncheckedIndexedAccess`にて登場した型と同じものでシステムにおける単語、用語のうち英語は担保し他言語の存在は曖昧なものにしています。\n\n```ts twoslash\ntype SystemTerms = {\n  en: string;\n  [key: string]: string;\n};\n\nconst butterfly: SystemTerms = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n// ---cut---\nconsole.log(butterfly.fr);\n// @log: \"Papillon\"\n```\n\n存在が不確かなプロパティへのアクセスについて、ドット記法でアクセスするときに、このオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noPropertyAccessFromIndexSignature: true\ntype SystemTerms = {\n  en: string;\n  [key: string]: string;\n};\n\nconst butterfly: SystemTerms = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n// ---cut---\n// @errors: 4111\nconsole.log(butterfly.fr);\n```\n\nこのようにインデックス型へのドット記法でのアクセスが禁止されます。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/nopropertyaccessfromindexsignature"
    },
    {
      "title": "strictNullChecks",
      "content": "---\ndescription: null・undefinedのチェックを厳しくする\ntags: [strict]\nimage: /img/strictNullChecks.png\n---\n\n# strictNullChecks\n\n`strictNullChecks`は`null`や`undefined`のチェックを厳しくするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 2.0\n- TypeScript公式が有効化推奨\n\n## `null`と`undefined`が代入できる危険性\n\nTypeScriptでは`strictNullChecks`が`false`の場合、`null`と`undefined`の代入がチェックされません。非null型や非undefined型の変数にも、`null`と`undefined`が代入できます。\n\n```ts twoslash title=\"strictNullChecksがfalseの場合\"\n// @strictNullChecks: false\nconst date: Date = null; // OK\nconst error: Error = undefined; // OK\n```\n\n`null`や`undefined`にはプロパティが存在しません。そのため、JavaScript実行時にエラーになります。\n\n```ts twoslash\nconst date: Date = null; // OK\n// ---cut---\ndate.getDay();\n// @error: Cannot read properties of null (reading 'getDay')\n// @strictNullChecks: false\n```\n\n`strictNullChecks`が`true`の場合、非null型への`null`の代入、非undefined型への`undefined`の代入それぞれがコンパイルエラーになります。\n\n```ts twoslash title=\"strictNullChecksがtrueの場合\"\n// @strictNullChecks: true\n// @errors: 2322\nconst date: Date = null;\nconst error: Error = undefined;\n```\n\n## 関数の戻り値の型への影響\n\n`strictNullChecks`の設定によって、関数の戻り値の型が変わることがあります。配列の`find`メソッドの戻り値の型は、要素の型もしくは`undefined`です。しかし、`strictNullChecks`が`false`の場合、戻り値が`undefined`になる可能性をコンパイラが考えなくなります。戻り値に`null`が入る可能性がある関数、たとえば`getElementById`の場合も同様です。\n\n```ts twoslash title=\"strictNullChecksがfalseの場合\"\n// @strictNullChecks: false\nconst result = [1, 2, 3].find((x) => x == 1);\n//    ^?\nconst element = document.getElementById(\"main\");\n//    ^?\n```\n\n`strictNullChecks`が`true`の場合は、`undefined`や`null`が戻り値になる可能性をコンパイラが考慮します。そのため、`find`なら要素の型と`undefined`のユニオン型に、`getElementById`なら`HTMLElement | null`になります。\n\n```ts twoslash title=\"strictNullChecksがtrueの場合\"\n// @strictNullChecks: true\nconst result = [1, 2, 3].find((x) => x == 1);\n//    ^?\nconst element = document.getElementById(\"main\");\n//    ^?\n```\n\nこの設定の効果は、ユーザー定義の型ガード関数にも及びます。たとえば、関数の戻り値を`string | undefined`と型注釈したとしても、`strictNullChecks`が`false`の場合は`string`型になります。\n\n```ts twoslash title=\"strictNullChecksがfalseの場合\"\n// @strictNullChecks: false\n// ユーザー定義の型ガード関数\nfunction getStringOrUndefined(): string | undefined {\n  return undefined;\n}\nconst value = getStringOrUndefined();\n//    ^?\n```\n\n## `strictNullChecks`は有効にしよう\n\n`null`や`undefined`を期待しない変数にそれらが代入できるのは危険です。また、関数の戻り値に`null`や`undefined`が入る可能性が見えなくなることも、思わぬバグを生む原因になります。`strictNullChecks`は`true`を設定するのがお勧めです。\n\n<PostILearned>\n\n😱TypeScriptデフォルトでnullとundefinedの代入チェックをしない(どんな型にも代入できる)\n✅コンパイラオプションstrictNullChecksをtrueにすると、nullとundefinedの代入がチェックされる\n👍strictNullChecksは有効にしよう\n\n</PostILearned>\n\n## 関連情報\n\n[strict](./strict.md)\n\n[null型](../values-types-variables/null.md)\n\n[undefined型](../values-types-variables/undefined.md)\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/strictnullchecks"
    },
    {
      "title": "strictBindCallApply",
      "content": "---\ndescription: bind、call、applyの型チェックを厳しくする\ntags: [strict]\n---\n\n# strictBindCallApply\n\n`strictBindCallApply`は`bind`、`call`、`apply`の型チェックを厳しくするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 3.2\n- TypeScript公式が有効化推奨\n\n## `bind`、`call`、`apply`が型チェックされない\n\n`strictBindCallApply`が`false`(TypeScriptのデフォルト)の場合、ビルトイン関数`bind`、`call`、`apply`の引数の型をチェックしません。\n\n```ts twoslash\n// @strictBindCallApply: false\n// 引数が文字列型の関数\nfunction fn(x: string) {}\n\n// 渡す引数は数値型だが、警告は出ない\nfn.call(undefined, 122);\n```\n\n`bind`、`call`、`apply`で呼び出す関数の戻り値型注釈は無視され、戻り値の型は`any`になります。\n\n```ts twoslash\n// @strictBindCallApply: false\nfunction fn(): string {\n  return \"str\";\n}\nconst x = fn.call(undefined);\n//    ^?\n```\n\n`strictBindCallApply`が`false`の場合、実行時エラーが発生する恐れがあります。\n\n```ts twoslash\nfunction fn(x: string) {\n  x.toUpperCase();\n}\nconst x = fn.call(undefined, 123);\n// @error: TypeError: x.toUpperCase is not a function\n// @strictBindCallApply: false\n```\n\n## `bind`、`call`、`apply`の型チェックを行う\n\n`strictBindCallApply`を`true`にすると、`bind`、`call`、`apply`の型チェックが行われます。\n\n```ts twoslash\n// @errors: 2345\nfunction fn(x: string) {}\nfn.call(undefined, 123);\n```\n\n加えて、戻り値の型は呼び出す関数の戻り値型になります。\n\n```ts twoslash\nfunction fn(): string {\n  return \"str\";\n}\nconst x = fn.call(undefined);\n//    ^?\n```\n\n戻り値に型がつくため、補完が効くメリットもあります。\n\n```ts twoslash\n// @noErrors\nfunction fn(): string {\n  return \"str\";\n}\nconst str = fn.call(undefined);\nstr.toU;\n//     ^|\n```\n\n`strictBindCallApply`は有効にするのがお勧めです。\n\n<PostILearned>\n\nTypeScriptのstrictBindCallApplyはbind、call、applyの型チェックを厳しくするコンパイラオプション\n\n【falseの場合】\n❌引数の型チェックがされない\n⚠️戻り値はanyになる\n\n【trueの場合】\n✅引数の型チェックがされる\n💚戻り値に型がつく\n👍有効化推奨\n\n</PostILearned>\n\n## 関連情報\n\n[strict](./strict.md)\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/strictbindcallapply"
    },
    {
      "title": "noImplicitAny",
      "content": "---\ndescription: 暗黙のany型を禁ずる\ntags: [strict]\n---\n\n# noImplicitAny\n\n`noImplicitAny`は暗黙のany型を禁止するコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: -\n- TypeScript公式が有効化推奨\n\n## 暗黙のanyの問題点\n\n型注釈もなく型推論もできない場合、TypeScriptは変数の型を`any`にします。これを暗黙のanyといいます。特に引数やプロパティで暗黙のanyになることが多いです。\n\n```ts twoslash title=\"暗黙のanyが発生する例\"\n// @noImplicitAny: false\nfunction foo(param) {}\n//           ^?\n\nclass Bar {\n  private prop;\n  //      ^?\n}\n```\n\nany型の変数には型チェックが無いため、バグの危険性が増します。\n\n```ts twoslash\nfunction increment(number) {\n  console.log(number + 1);\n}\nincrement(\"1\");\n// @log: \"11\"\nincrement(undefined);\n// @log: NaN\n// @noImplicitAny: false\n```\n\n## `noImplicitAny`で暗黙のanyを防ぐ\n\n`noImplicitAny`を`true`にすると、変数が暗黙のanyになることを避けられます。TypeScriptは暗黙のanyになる変数を見つけると、警告を出すようになります。\n\n```ts twoslash title=\"暗黙のanyが警告される例\"\n// @noImplicitAny: true\n// @errors: 7006 7008\nfunction foo(param) {}\n\nclass Bar {\n  private prop;\n}\n```\n\n## 関数の戻り値の型\n\n関数の戻り値の型は型注釈がなくても、TypeScriptが型推論可能なため暗黙のanyにはなりません。したがって、型注釈の無い戻り値は、`noImplicitAny`を有効にしても警告は出ません。\n\n```ts twoslash\nfunction foo() {\n  //     ^?\n  return 1;\n}\n```\n\n戻り値の型注釈を必須にしたい場合は、[`noImplicitReturns`](./noimplicitreturns.md)を有効にしてください。\n\n<PostILearned>\n\n😢TypeScriptは型注釈がないOR型推論不能の場合、型をanyにする(暗黙のany)\n🙅‍♂️noImplicitAnyは暗黙のanyを禁止するコンパイラオプション\n😊これをtrueにすると暗黙のanyが警告される\n✅有効化推奨のオプション\n\n</PostILearned>\n\n## 関連情報\n\n[strict](./strict.md)\n\n[any型](../values-types-variables/any.md)\n\n[関数宣言](../functions/function-declaration.md)\n\n[フィールド](../object-oriented/class/fields.md)\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/noimplicitany"
    },
    {
      "title": "noUnusedParameters",
      "content": "---\ndescription: 使われていない引数を禁止する\n---\n\n# noUnusedParameters\n\n`noUnusedParameters`は使われていない引数を禁止するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 2.0\n\n## 解説\n\n関数で使用していない引数を禁止します。\n\n```ts twoslash\n// @noUnusedParameters: false\nfunction add(n1: number, n2: number, n3: number): number {\n  return n1 + n2;\n}\n```\n\nこのオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noUnusedParameters: true\n// @errors: 6133\n\nfunction add(n1: number, n2: number, n3: number): number {\n  return n1 + n2;\n}\n```\n\nこれを回避するためには、使用していない引数を`_`で始まる名前に変更します。\n\n```ts twoslash\nfunction add(n1: number, n2: number, _n3: number): number {\n  return n1 + n2;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/nounusedparameters"
    },
    {
      "title": "strictPropertyInitialization",
      "content": "---\ndescription: クラスプロパティの初期化を必須にする\ntags: [strict]\n---\n\n# strictPropertyInitialization\n\n`strictPropertyInitialization`はクラスプロパティの初期化を必須にするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 2.7\n- TypeScript公式が有効化推奨\n\n:::caution\n\nこのオプションを効かすには[`strictNullChecks`](./strictnullchecks.md)も`true`する必要があります。\n\n:::\n\n## 解説\n\n`strictPropertyInitialization`を`true`にすると、値が初期化されていないクラスプロパティについて警告を出します。\n\n```ts twoslash\n// @errors: 2564\nclass Foo {\n  prop: number;\n}\n```\n\n初期化は、次のいずれかで行う必要があります。\n\n1. コンストラクタで初期化\n1. 初期化子で初期化\n1. undefinedとのユニオン型で型注釈する\n\n次は、コンストラクタで初期化する例です。\n\n```ts twoslash\nclass Foo {\n  prop: number;\n\n  constructor() {\n    this.prop = 1;\n  }\n}\n```\n\n次は、[初期化子](../object-oriented/class/field-initializers.md)で初期化する例です。\n\n```ts twoslash\nclass Foo {\n  prop: number = 1;\n  //           ^^^初期化子\n}\n```\n\nプロパティの型が`undefined`との[ユニオン型](../values-types-variables/union.md)の場合、初期化しなくても警告が出ません。\n\n```ts twoslash\nclass Foo {\n  prop: number | undefined;\n}\n```\n\nプロパティがオプションの場合も警告が出ません。\n\n```ts twoslash\nclass Foo {\n  prop?: number;\n}\n```\n\n<PostILearned>\n\nTypeScriptのstrictPropertyInitializationはプロパティの初期化を必須にするコンパイラオプション。\n\n⚠️strictNullChecksもtrueする必要あり\n✅コンストラクタで初期化OR初期化子が必須になる\n🙆🏻‍♂️undefinedとのユニオン型で型注釈するのはOK\n\n</PostILearned>\n\n## 関連情報\n\n[strict](./strict.md)\n\n[フィールド (field)](../object-oriented/class/fields.md)\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/strictpropertyinitialization"
    },
    {
      "title": "noImplicitThis",
      "content": "---\ndescription: thisの型注釈を必須にする\ntags: [strict]\n---\n\n# noImplicitThis\n\n`noImplicitThis`はthisの型注釈を必須にするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 2.0\n- TypeScript公式が有効化推奨\n\n## 解説\n\n名前付き関数、匿名関数はアロー関数と異なり、実行時に`this`が決定されます。そのため、内部で`this`を使っているとそれらは関数を書いている時点では`any`型と同じ扱いになります。\n\nたとえば、対角線の長さを求める関数`lengthOfDiagonal()`を考えます。(横, 縦)を (width, height) とすれば関数は次のようになります。\n\n```ts twoslash\n// @noErrors\nfunction lengthOfDiagonal(): number {\n  return (this.width ** 2 + this.height ** 2) ** (1 / 2);\n}\n```\n\nこれを`width, height`をプロパティに持つオブジェクトのインスタンスに代入すれば対角線の長さを計算できます。\n\n```ts twoslash\ndeclare function lengthOfDiagonal(): number;\n\n// ---cut---\nconst area = {\n  width: 3,\n  height: 4,\n  diagonal: lengthOfDiagonal,\n};\n\nconsole.log(area.diagonal());\n// @log: 5\n```\n\nこのとき、打ち間違いで`width`を`witch`としてしまったとするとこの関数は意図した結果を返さなくなります。\n\n```ts twoslash\ndeclare function lengthOfDiagonal(): number;\n\n// ---cut---\nconst area = {\n  witch: 3,\n  height: 4,\n  diagonal: lengthOfDiagonal,\n};\n\nconsole.log(area.diagonal());\n// @log: NaN\n```\n\nこのオプションを有効にすると`any`型として認識されてしまっている`this`がどの型であるかを明確にできない限り実行することができなくなります。\n\n```ts twoslash\n// @noImplicitThis: true\n// @errors: 2683\nfunction lengthOfDiagonal(): number {\n  return (this.width ** 2 + this.height ** 2) ** (1 / 2);\n}\n```\n\nこれを回避するためには`this`が何かを明示します。引数の`this`については関数のページに詳細がありますので併せてご参照ください。\n\n[this引数 (this parameter)](../functions/this-parameters.md)\n\n```ts twoslash\ntype Area = {\n  width: number;\n  height: number;\n  diagonal(): number;\n};\n\nfunction lengthOfDiagonal(this: Area): number {\n  return (this.width ** 2 + this.height ** 2) ** (1 / 2);\n}\n\nconst area: Area = {\n  width: 3,\n  height: 4,\n  diagonal: lengthOfDiagonal,\n};\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/noimplicitthis"
    },
    {
      "title": "strictFunctionTypes",
      "content": "---\ndescription: 引数型の変性のチェックを厳しくする\ntags: [strict]\n---\n\n# strictFunctionTypes\n\n`strictFunctionTypes`は引数型の変性のチェックを厳しくするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 2.6\n- TypeScript公式が有効化推奨\n\n## 引数の双変性は安心できない\n\nTypeScriptの関数には引数の双変性(parameter bivariance)という性質があります。どういうことか、順を追って見ていきましょう。\n\nまず、次の3つの型の範囲を考えてみましょう。\n\n1. `number`\n2. `number | null`\n3. `number | null | undefined`\n\n`number`は`number | null`より狭い型です。`number | null`の範囲には`1`や`0.5`などのnumber型とnull型があります。`number`型の範囲にあるのはnumber型だけです。最後の`number | null | undefined`はこの中でもっとも範囲が広い型です。\n\n| 型                                               | 範囲の広さ | 取れる値の例                       |\n| ------------------------------------------------ | ---------- | ---------------------------------- |\n| `number`                                         | 狭い       | `1`、`0.5`...                      |\n| <code>number &#124; null</code>                  | 広い       | `1`、`0.5`...、`null`              |\n| <code>number &#124; null &#124; undefined</code> | より広い   | `1`、`0.5`...、`null`、`undefined` |\n\n続いて、次の変数`func`について考えてみましょう。この変数の型は、引数に`number | null`を取る関数です。\n\n```ts twoslash\nlet func: (n: number | null) => any;\n```\n\nこの変数`func`に代入できる値はどんな型でしょうか。当然、型注釈と同じ関数は問題なく代入できます。\n\n```ts twoslash\nlet func: (n: number | null) => any;\n// ---cut---\nfunc = (n: number | null) => {}; // OK\n```\n\n引数`number | null`より広い`number | null | undefined`を受ける関数は代入できるでしょうか。これも大丈夫です。\n\n```ts twoslash\nlet func: (n: number | null) => any;\n// ---cut---\nfunc = (n: number | null | undefined) => {}; // OK\n```\n\nこのような引数型の範囲を広められる特性を**引数の反変性(parameter contravariance)**と言います。\n\n引数`number | null`より狭い`number`を取る関数は代入できるでしょうか。これもTypeScriptでは代入できます。\n\n```ts twoslash\n// @strictFunctionTypes: false\nlet func: (n: number | null) => any;\n// ---cut---\nfunc = (n: number) => {}; // OK\n```\n\nこのような引数型の範囲を狭められる特性を**引数の共変性(parameter covariance)**と言います。\n\nTypeScriptの関数型は、引数の反変性と引数の共変性の両特性を持っています。この両特性は一言で、**引数の双変性**と言います。\n\n引数の双変性は危険な側面があります。`null`が渡せる`func`関数に、`number`だけが来ることを前提とした関数を代入しているためです。もしも、`func`に`null`を渡すと、実行時エラーが発生します。\n\n```ts twoslash\n// nullも来る可能性がある関数型\nlet func: (n: number | null) => any;\n// numberを前提とした関数を代入\nfunc = (n: number) => n.toString();\n// funcにはnullが渡せる → 矛盾が実行時エラーを生む\nfunc(null);\n// @error: Cannot read properties of null (reading 'toString')\n// @strictFunctionTypes: false\n```\n\nこうした実行時エラーが起きないようにするには、引数型は反変だけが許されるべきです。そして、もし共変ならコンパイルエラーで知らせてほしいところです。ところが、TypeScriptは引数型は双変(つまり共変もOK)であるため、安心できない仕様になっています。\n\n## 引数の共変性を許さない`strictFunctionTypes`\n\n上の課題を解決するのが、コンパイラオプション`strictFunctionTypes`です。これを`true`にすると、引数が反変になります。もし、共変の引数にした場合、TypeScriptが警告を出します。\n\n```ts twoslash\n// @errors: 2322\nlet func: (n: number | null) => any;\n// 不変\nfunc = (n: number | null) => {}; // OK\n// 反変\nfunc = (n: number | null | undefined) => {}; // OK\n// 共変\nfunc = (n: number) => {}; // NG\n```\n\n`strictFunctionTypes`は思いがけない実行時エラーを防ぐのに役立ちます。`strictFunctionTypes`は`true`を設定するのがお勧めです。\n\n## メソッド型はチェックされない\n\n`strictFunctionTypes`のチェックが働くのは関数型だけです。メソッド型には働きません。\n\n```ts twoslash\ninterface Obj {\n  // メソッド型\n  method(n: number | null): any;\n}\nconst obj: Obj = {\n  method: (n: number) => {}, // チェックされない\n};\n```\n\nインターフェースのメソッドでも、**関数型で定義されたメソッド**は`strictFunctionTypes`のチェックが働きます。\n\n```ts twoslash\n// @errors: 2322\ninterface Obj {\n  // 関数型\n  method: (n: number | null) => any;\n}\nconst obj: Obj = {\n  method: (n: number) => {}, // チェックが働く\n};\n```\n\n<PostILearned>\n\n⚙️TypeScriptのstrictFunctionTypesは、引数型の変性のチェックを厳しくするコンパイルオプション\n☹️TypeScriptの引数は双変で安心できない\n🔥実行時エラーが起こることも\n✅strictFunctionTypesは反変にしてくれる\n👍有効化推奨のオプション\n\n</PostILearned>\n\n## 関連情報\n\n[strict](./strict.md)\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/strictfunctiontypes"
    },
    {
      "title": "noImplicitReturns",
      "content": "---\ndescription: 関数戻り値の型注釈を必須にする\n---\n\n# noImplicitReturns\n\n`noImplicitReturns`は関数戻り値の型注釈を必須にするコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 1.8\n\n## 解説\n\n戻り値が`void`型以外の関数ですべての条件分岐において値を返しているかを厳密に評価します。\n\n```ts twoslash\n// @noErrors\nfunction negaposi(num: number): string {\n  if (num > 0) {\n    return \"positive\";\n  } else if (num < 0) {\n    return \"negative\";\n  }\n}\n```\n\nこのオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noImplicitReturns: true\n// @errors: 2366\nfunction negaposi(num: number): string {\n  if (num > 0) {\n    return \"positive\";\n  } else if (num < 0) {\n    return \"negative\";\n  }\n}\n```\n\nこれを回避するためには条件分岐の場合分けのときに値を返し忘れないように設計します。\n\n```ts twoslash\nfunction negaposi(num: number): string {\n  if (num > 0) {\n    return \"positive\";\n  } else if (num < 0) {\n    return \"negative\";\n  }\n\n  return \"this is 0\";\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/noimplicitreturns"
    },
    {
      "title": "noFallthroughCasesInSwitch",
      "content": "---\ndescription: switch文のfallthroughを禁止する\n---\n\n# noFallthroughCasesInSwitch\n\n`noFallthroughCasesInSwitch`はswitch文のfallthroughを禁止するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 1.8\n\n## 解説\n\n`fallthrough`とは`switch`における`case`文で`break`または`return`を行わないことを意味します。`case`文が空でない場合に限り`break`や`return`が行われているかを厳密に評価します。\n\n```ts twoslash\nfunction daysOfMonth(month: number): number {\n  let days: number = 31;\n\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      break;\n    case 2:\n      days = 28;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      days = 30;\n    default:\n      throw new Error(\"INVALID INPUT\");\n  }\n\n  return days;\n}\n```\n\nある月の日数を求める関数`daysOfMonth()`を定義しましたがこの関数には`fallthrough`が存在します。このオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noFallthroughCasesInSwitch: true\n// @errors: 7029\nfunction daysOfMonth(month: number): number {\n  let days: number = 31;\n\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      break;\n    case 2:\n      days = 28;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      days = 30;\n    default:\n      throw new Error(\"INVALID INPUT\");\n  }\n\n  return days;\n}\n```\n\n`case 1, case 3, case 5, ....`が`fallthrough`とみなされないのは`case`文の実行部分が`break`だけで何もしないからです。\n\nこれを回避するためには`case`では漏れなく`break`あるいは`return`をするように設計します。\n\n```ts twoslash\nfunction daysOfMonth(month: number): number {\n  let days: number = 31;\n\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      break;\n    case 2:\n      days = 28;\n      break;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      days = 30;\n      break;\n    default:\n      throw new Error(\"INVALID INPUT\");\n  }\n\n  return days;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/nofallthroughcasesinswitch"
    },
    {
      "title": "noUnusedLocals",
      "content": "---\ndescription: 使われていない変数を禁止する\n---\n\n# noUnusedLocals\n\n`noUnusedLocals`は使われていない変数を禁止するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 2.0\n\n## 解説\n\n宣言したにもかかわらず使用されていない変数を禁止します。\n\n```ts twoslash\nfunction add(n1: number, n2: number): number {\n  const message: string = `the sum is ${n1 + n2}`;\n\n  return n1 + n2;\n}\n```\n\nこのオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noUnusedLocals: true\n// @errors: 6133\nfunction add(n1: number, n2: number): number {\n  const message: string = `the sum is ${n1 + n2}`;\n\n  return n1 + n2;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/nounusedlocals"
    },
    {
      "title": "tsconfig.jsonを設定する",
      "content": "# tsconfig.jsonを設定する\n\nNode.jsはそれ自身ではTypeScriptをサポートしているわけではないため、TypeScriptの導入をする時はTypeScriptの設定ファイルであるtsconfig.jsonが必要です。\n\n## 初めてのtsconfig.json\n\ntypescriptがpackage.jsonのdependencies(devDependencies)に入っているプロジェクトで以下を実行してください。\n\n```bash\nnpx tsc --init\n```\n\ntypescriptがグローバルインストールされていれば次のように実行することもできます。\n\n```bash\ntsc --init\n```\n\ntsconfig.jsonが作成されます。すでにtsconfig.jsonがある時は上書きされませんのでいったん既存のtsconfig.jsonを別名に変更するなど、一度tsconfig.jsonと名のつくファイルが存在しないようにしてください。\n\n公式にあるtsconfig.jsonの説明はこちらです。\n\n<https://www.typescriptlang.org/docs/handbook/tsconfig-json.html>\n\nすべてのオプションの解説をすると余白が足りないので、ここでは用途を抽出して、次の観点で説明します。\n\n- `target`の決め方\n- フロントエンドとバックエンド\n- 2020年版スクラッチからつくるなら\n\n## `target`\n\nTypeScriptは最終的にJavaScriptにコンパイルされます。このオプションはそのときにどのバージョンのJavaScript向けに出力するかといったものです。\n\n`target`を設定すれば、TypeScriptはその`target`の時点で使用できるオブジェクト、関数の定義ファイルが読み込まれます。つまり、あまりにも古いバージョンの`target`を指定すると昨今当然のように使っているオブジェクトや関数を使うことができないかもしれません。\n\n`target`を最新にしても、動作する環境が古いままだと使うことはできません。TypeScriptはコーディング中はあたかもそのオブジェクト、関数があるかのように入力補完をしますが、実際に動く`js`の実行環境がそのバージョンのオブジェクトや関数を持っているかどうかは別問題だからです。とはいえ構文に新たな記法が生まれた場合、生まれるより前の`target`に設定すると新たな記法で書いていたとしてもコンパイル時にその`target`で有効な構文に変換してくれます。有名な例では関数の表記です。たとえば`\"target\": \"es5\"`を指定した場合は`() => {}`といった`\"target\": \"es2015\"`から使えるアロー関数などの構文を`ES5`でも動く`function() {}`という形式にコンパイルしてくれます。\n\n### `lib`\n\n使いたい`target`には使いたい機能がない、でも使いたい。そのような時は`lib`オプションを指定することで使うことができるようになります。\n\nこのような最新バージョンにはある、または現時点では実装には至っていないが提案中(proposal)である機能を取り入れて使えるようにする物を通称ポリフィルと言います。ポリフィルについてさらに詳しく知りたい方は、[What is a polyfill?](https://remysharp.com/2010/10/08/what-is-a-polyfill) (この単語の創案者である Remy Sharp による記事)をご覧ください。\n\n`lib`は必ず指定する必要はありません。`target`を指定すればその`target`で使われているライブラリは自動的に追加されます。指定した`target`では実装されていないライブラリや、必要がないライブラリを除外したいときに使います。\n\n指定は必ずしも必要ないとは申しあげましたがNode.jsでは構文(`syntax`)のサポートよりもAPIのサポートが先に行われることがあるため`target`ではまだサポートしていないがNode.jsで使えるようになっているAPIを`lib`を指定することによって使えるようにすることがあります。\n\n#### `lib`を指定する上での注意\n\n`lib`を指定すると、明示的にどの`target`の`lib`を使うかも明記しなければいけません。\n\n次のような`lib`を指定しない`target`の書き方は問題がありません。\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2018\"\n    // \"lib\": []\n  }\n}\n```\n\n`lib`を指定すると、明示的にどの`target`の`lib`を使うかも明記しなければいけません。\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"lib\": [\n      \"es2018\",\n      \"esnext.AsyncIterable\",\n      \"esnext.Array\",\n      \"esnext.Intl\",\n      \"esnext.Symbol\"\n    ]\n  }\n}\n```\n\n`lib`の先頭要素の`\"es2018\"`を省いてしまうとライブラリの多くが存在しない状態になります。\n\n### `target`は何を指定したらいいか\n\nあえて古いコードで動かしている、または古いNode.jsを使っているといった事情がなければ最新に近い物を指定することは問題ありません。2020/09現在はLTSとしてNode.js 14.xが登場しています。Node.js 14.xであれば`\"target\": \"es2020\"`は無難な選択肢です。\n\nまたBabelなどの専用のコンパイラやモジュールバンドラに処理を任せたい場合は`target`に`\"esnext\"`を指定して、そこからバージョンに合わせたコンパイルを各々にお願いすることになります。\n\nNode.jsのバージョンごとにサポートされているEcmaScriptの機能は [node.green](https://node.green) で確認することができます。\n\n## フロントエンドとバックエンド\n\nフロントエンドとバックエンドはモジュールの読み込み方法が異なっています。詳細は`import / export / require`のページをご覧ください。次の設定は使う場面で切り替えるべき項目です。\n\n[import / export /require](../import-export-require.md)\n\nここで登場するモジュールという言葉ですが、この言葉に馴染みのない方はそのコードのファイルが読み込む他のファイルの中にあるコードぐらいに捉えてください。それらは同じプロジェクト内の他のファイルの中のコードでもあれば`npm install`したものでもあります。とくに`npm install`したものであればこれらをパッケージと呼びます。\n\n### `module`\n\nこのオプションは出力されるJavaScriptがどのようにモジュールを読み込むか指定します。\n\nモジュール読み込みの仕組みが異なっているライブラリの互換性は一般的にはないものと考えてください。そしてこれは**フロントエンドとバックエンドでは異なります**。\n\n#### `commonjs`\n\nバックエンド(サーバーサイド)で使われているモジュール読み込みの解決方法です。作成しているモジュールやパッケージがバックエンドでの動作だけを保証したい場合はもっとも無難な選択です。\n\n#### `es2015, es2020, esnext`\n\n通称`esmodule`と呼ばれるモジュール読み込みの解決方法です。フロントエンドで使われています。Node.jsは13.2.0でバックエンドでも同様にこのモジュール解決方法をサポートしましたが2020年現在は対応しているパッケージは少ないです。\n\nこのような違いがあるため、使う場面がバックエンドなら`commonjs`を、フロントエンドなら`es2015, es2020, esnext`を指定することが望ましいです。\n\n## 2020年版スクラッチから作るなら\n\nスクラッチから作るということは現在の資産との整合性の都合、しがらみが一切ない状態です。ここから作るならこれだけは満たしておけば型に満ちたプログラミングができるという紹介です。\n\nしがらみがないという条件のもと、Node.jsは14.xを使っているものとします。\n\n### バックエンドの場合\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"es2020\"],\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \"src\",\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"dist\", \"node_modules\"],\n  \"compileOnSave\": false\n}\n```\n\n### フロントエンドの場合\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"esnext\",\n    \"lib\": [\"es2020\", \"dom\"],\n    \"jsx\": \"react\",\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \"src\",\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"dist\", \"node_modules\"],\n  \"compileOnSave\": false\n}\n```\n\n### 異なる箇所について\n\nこれらふたつのtsconfig.jsonの設定で異なるのは`module, lib, jsx`です。フロントエンドであれば`lib`に`dom`を加えることもあります(ただし、これは`\"target\": \"es2020\"`に組み込まれています)。さらに`jsx`を使うのであれば`tsx`をどのようにしてjsのファイルに出力コンパイルしたいかを`jsx`オプションで指定します。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/tsconfig.json-settings"
    },
    {
      "title": "noImplicitOverride",
      "content": "---\ndescription: メソッドオーバーライドにoverrideキーワードを必須にする\n---\n\n# noImplicitOverride\n\n`noImplicitOverride`はメソッドオーバーライドにoverrideキーワードを必須にするコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 4.3\n\n## 解説\n\nサブクラスがスーパークラスのメソッドを拡張したときに`override`のキーワードをメソッドの前に書くことを強制します。これはスーパークラスの拡張しているメソッドが取り除かれたり、名称が変更されたことを検知することに役立ちます。\n\nたとえば、トグルボタン (クリックするとオン、オフを繰り返すボタン) のクラスが次のようになっているとします。\n\n```ts twoslash\nclass ToggleButton {\n  protected _active: boolean;\n\n  public constructor() {\n    this._active = false;\n  }\n\n  public get active(): boolean {\n    return this._active;\n  }\n\n  public enable(): void {\n    this._active = true;\n  }\n\n  public disable(): void {\n    this._active = false;\n  }\n\n  public push(): void {\n    if (this._active) {\n      this.disable();\n      // ...\n      return;\n    }\n    this.enable();\n    // ...\n  }\n}\n```\n\nここで値のオンオフの切り替えを何回したかを数えられるサブクラス`ToggleCountButton`を考えます。すると`ToggleCountButton`は次のようになります。\n\n```ts twoslash\nclass ToggleButton {\n  protected _active: boolean;\n\n  public constructor() {\n    this._active = false;\n  }\n\n  public get active(): boolean {\n    return this._active;\n  }\n\n  public enable(): void {\n    this._active = true;\n  }\n\n  public disable(): void {\n    this._active = false;\n  }\n\n  public push(): void {\n    if (this.active) {\n      this.disable();\n      // ...\n      return;\n    }\n    this.enable();\n    // ...\n  }\n}\n// ---cut---\nclass ToggleCountButton extends ToggleButton {\n  private _counter: number;\n\n  public constructor() {\n    super();\n    this._counter = 0;\n  }\n\n  public enable(): void {\n    this._counter++;\n    this._active = true;\n  }\n\n  public disable(): void {\n    this._counter++;\n    this._active = false;\n  }\n\n  public get counter(): number {\n    return this._counter;\n  }\n}\n```\n\nここでスーパークラスの`ToggleButton`が「オンオフの切り替えにメソッドはふたつも要らない！セッターで十分だ」と変更されたとします。\n\n```ts twoslash\nclass ToggleButton {\n  protected _active: boolean;\n\n  public constructor() {\n    this._active = false;\n  }\n\n  public get active(): boolean {\n    return this._active;\n  }\n\n  public set active(active: boolean) {\n    this._active = active;\n  }\n\n  public push(): void {\n    this._active = !this._active;\n    // ...\n  }\n}\n```\n\nするとサブクラスでオーバーライドしたはずのメソッド`enable(), disable()`が意味のないメソッドとして残ることになります。\n\n`noImplicitOverride`はオーバーライドしているメソッドに`override`キーワードをつけることによってスーパークラスに同名のメソッドがないかを確認させます。`override`キーワードがついているにもかかわらずオーバーライド元となるメソッドが存在しないと次のようなエラーが発生します。\n\n```ts twoslash\nclass ToggleButton {\n  protected _active: boolean;\n\n  public constructor() {\n    this._active = false;\n  }\n\n  public get active(): boolean {\n    return this._active;\n  }\n\n  public set active(active: boolean) {\n    this._active = active;\n  }\n\n  public push(): void {\n    this._active = !this.active;\n    // ...\n  }\n}\n// ---cut---\n// @noImplicitOverride: true\n// @errors: 4113\nclass ToggleCountButton extends ToggleButton {\n  private _counter: number;\n\n  public constructor() {\n    super();\n    this._counter = 0;\n  }\n\n  public override enable(): void {\n    this._counter++;\n    this._active = true;\n  }\n\n  public override disable(): void {\n    this._counter++;\n    this._active = false;\n  }\n\n  public get counter(): number {\n    return this._counter;\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/noimplicitoverride"
    },
    {
      "title": "isolatedModules",
      "content": "---\ndescription: 個別にコンパイルされるモジュールをサポートする\n---\n\n# isolatedModules\n\n`isolatedModules`は、各ファイルを独立して変換する際に、解釈できないコードがある場合に警告するコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 1.5\n\n## `isolatedModules`はトランスパイラ向けのオプション\n\nTypeScriptをJavaScriptに変換する際、複数のファイルが関連することがあります。しかし、Babelのようなトランスパイラは、1ファイルずつ処理するため、一部コードが正しく解釈されないことがあります。\n\n具体的には、`const enum`や`namespace`などの機能を使用すると、実行時に問題が発生することがあります。`isolatedModules`は、このような問題を回避するために、正しく解釈できないコードがある場合に警告します。\n\n## `isolatedModules`が有効な場合に機能しないコード\n\n以下は、`isolatedModules`が有効な場合に機能しないコードの例です。\n\n### 値でない識別子のエクスポート\n\nTypeScriptでは、インポートした型を再エクスポートすることができます。\nこれは、複数のモジュールから型や関数をまとめてエクスポートする際に便利です。ただし、`isolatedModules`が有効な場合、型を再エクスポートする際に`export type`を使わないとエラーが発生します。\n\n**問題のあるコード:**\n\n```ts title=\"someModule.ts\" twoslash\nexport type SomeType = any;\nexport function hello() {\n  console.log(\"hello\");\n}\n```\n\n```ts twoslash title=\"index.ts\"\n// @filename: \"someModule.ts\"\nexport type SomeType = any\nexport function hello() {\n  return { console.log(\"hello\") };\n}\n// @filename: \"index.ts\"\n// ---cut---\nimport { SomeType, hello } from \"./someModule\";\n\n// someTypeは値?それとも型?トランスパイラには判断できない\nexport { SomeType, hello };\n// @error: Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.\n```\n\n**解決策：**\n\n`export type`を使用して型を再エクスポートすることで、エラーを回避できます。\n\n```ts title=\"index.ts\" twoslash\n// @filename: \"someModule.ts\"\nexport type SomeType = any\nexport function hello() {\n  return { console.log(\"hello\") };\n}\n// @filename: \"index.ts\"\n// ---cut---\nimport { SomeType, hello } from \"./someModule\";\n\nexport type { SomeType }; // 型だと判定できる\nexport { hello };\n```\n\n### モジュールでないファイル\n\n`isolatedModules` が設定されている場合、すべての実装ファイルは モジュールでなければなりません。モジュールとは、`import`や`export`の構文を使用していることを意味します。ファイルがモジュールでない場合、エラーが発生します。\n\n**問題のあるコード:**\n\n```ts title=\"index.ts\" twoslash\nfunction fn() {}\n// @error: 'index.ts' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.\n```\n\n**解決策：**\n\nファイルをモジュール化するために、空の`export {}`文を追加します。\n\n```ts title=\"index.ts\" twoslash\nfunction fn() {}\n\n// 空の export文を追加することでモジュール化する\nexport {};\n```\n\n### const enum メンバーへの参照\n\nTypeScriptでは、`const enum`のメンバーに参照すると、生成されるJavaScriptではその参照が実際の値に置き換えられます。しかし、他のトランスパイラは、メンバー値に関する情報がないため、参照を置き換えることができません。そのため、実行時にエラーが発生します。\n\n**問題のあるコード:**\n\n```ts title=\"index.ts\" twoslash\ndeclare const enum Numbers {\n  Zero = 0,\n  One = 1,\n}\n\nconsole.log(Numbers.Zero + Numbers.One);\n// @error: Cannot access ambient const enums when the '--isolatedModules' flag is provided.\n```\n\n**解決策:**\n\n`const enum`の代わりに、通常の`enum`を使用することで、エラーを回避できます。\n\n```ts title=\"numbers.ts\" twoslash\nenum Numbers {\n  Zero = 0,\n  One = 1,\n}\n\n// 通常の enum への参照は許可されます\nconsole.log(Numbers.Zero + Numbers.One);\n```\n\n`isolatedModules`は、このような問題を回避するためのコンパイラオプションです。\n警告を出してくれることにより、コンパイラが正しく解釈できないコードの存在に気がつくことができます。\n\n## `create-react-app`や`create-next-app`で生成されたtsconfig.jsonの`isolatedModules`をfalseにしてはいけない\n\nReactやNext.jsの雛形生成ツールによって作成されたtsconfig.jsonでは、`isolatedModules`が有効化されています。これは、ReactやNextが内部でBabelを使用しているためです。`isolatedModules`をfalseに変えてしまうとビルドできなくなる可能性があるため、設定を変更しないようにしましょう。\n\n<PostILearned>\n\n✅isolatedModulesはファイル単位での変換を前提に解釈できないコードをチェックする\n🚧Babelなどのトランスパイラとの互換性向上のために存在する\n👍isolatedModulesは有効にしよう\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/isolatedModules"
    },
    {
      "title": "noUncheckedIndexedAccess",
      "content": "---\ndescription: インデックス型のプロパティや配列要素を参照したときundefinedのチェックを必須にする\n---\n\n# noUncheckedIndexedAccess\n\n`noUncheckedIndexedAccess`はインデックス型のプロパティや配列要素を参照したときundefinedのチェックを必須にするコンパイラオプションです。\n\n- デフォルト: `false`\n- 追加されたバージョン: 4.1\n\n## 解説\n\nインデックス型や配列で宣言されたオブジェクトが持つプロパティへのアクセスを厳密に評価します。\n\n[インデックス型 (index signature)](../values-types-variables/object/index-signature.md)\n\n```ts twoslash\ntype ObjectLiteralLike = {\n  en: string;\n  fr: string;\n  it: string;\n  [lang: string]: string;\n};\n\ntype ArrayObjectLike = {\n  0: string;\n  1: string;\n  [num: number]: string;\n};\n\nfunction log(s: string): void {\n  console.log(s);\n}\n\nconst butterfly: ObjectLiteralLike = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n\nconst phoneticCodes: ArrayObjectLike = {\n  0: \"alpha\",\n  1: \"bravo\",\n  2: \"charlie\",\n};\n```\n\n`ObjectLiteralLike, ArrayObjectLike`は共に`string`型のプロパティを持つオブジェクトの型として宣言されています。\n\n```ts twoslash\ntype ObjectLiteralLike = {\n  en: string;\n  fr: string;\n  it: string;\n  [lang: string]: string;\n};\n\ntype ArrayObjectLike = {\n  0: string;\n  1: string;\n  [num: number]: string;\n};\n\nfunction log(s: string): void {\n  console.log(s);\n}\n\nconst butterfly: ObjectLiteralLike = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n\nconst phoneticCodes: ArrayObjectLike = {\n  0: \"alpha\",\n  1: \"bravo\",\n  2: \"charlie\",\n};\n// ---cut---\nconst spanish: string = butterfly.es;\nconst third: string = phoneticCodes[2];\n\nconsole.log(spanish);\nconsole.log(third);\n```\n\nこれらのオブジェクトのプロパティにアクセスするときは完全な型安全ではありません。このオプションを有効にすると次のようなエラーが発生します。\n\n```ts twoslash\n// @noUncheckedIndexedAccess: true\n// @errors: 2322\ntype ObjectLiteralLike = {\n  en: string;\n  fr: string;\n  it: string;\n  [lang: string]: string;\n};\n\ntype ArrayObjectLike = {\n  0: string;\n  1: string;\n  [num: number]: string;\n};\n\nfunction log(s: string): void {\n  console.log(s);\n}\n\nconst butterfly: ObjectLiteralLike = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n\nconst phoneticCodes: ArrayObjectLike = {\n  0: \"alpha\",\n  1: \"bravo\",\n  2: \"charlie\",\n};\n// ---cut---\nconst spanish: string = butterfly.es;\nconst third: string = phoneticCodes[2];\n```\n\nこのように厳密に定義されていないプロパティは`undefined`型とのユニオン型として解釈されるようになります。\n\n```ts twoslash\n// @noUncheckedIndexedAccess: true\n// @errors: 2322\ntype ObjectLiteralLike = {\n  en: string;\n  fr: string;\n  it: string;\n  [lang: string]: string;\n};\n\ntype ArrayObjectLike = {\n  0: string;\n  1: string;\n  [num: number]: string;\n};\n\nfunction log(s: string): void {\n  console.log(s);\n}\n\nconst butterfly: ObjectLiteralLike = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n};\n\nconst phoneticCodes: ArrayObjectLike = {\n  0: \"alpha\",\n  1: \"bravo\",\n  2: \"charlie\",\n};\n// ---cut---\nconst spanish: string | undefined = butterfly.es;\nconst third: string | undefined = phoneticCodes[2];\n```\n\n配列はインデックス記法でアクセスをすると`undefined`型とのユニオン型と解釈されますが`for-of, array.forEach()`はこの制約を受けないため積極的に使用を検討してください。\n\n```ts twoslash\nconst phoneticCodes: string[] = [\"alpha\", \"bravo\", \"charlie\"];\n\nfor (const p of phoneticCodes) {\n  // ...\n}\n\nphoneticCodes.forEach((p: string) => {\n  // ...\n});\n```\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/nouncheckedindexedaccess"
    },
    {
      "title": "useUnknownInCatchVariables",
      "content": "---\ndescription: 例外捕捉catch(e)のeをunknown型として扱う\ntags: [strict]\n---\n\n# useUnknownInCatchVariables\n\n`useUnknownInCatchVariables`は例外捕捉`catch(e)`の`e`をunknown型として扱うコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 4.4\n- TypeScript公式が有効化推奨\n\n## 解説\n\nJavaScript はいかなる値も例外として投げることができます。そのため捕捉した値は`any`型でした。\n\n```ts twoslash\n// @useUnknownInCatchVariables: false\n// case 1\ntry {\n  throw new Error();\n} catch (err) {\n  //       ^?\n}\n\n// case 2\ntry {\n  throw \"This is an error!\";\n} catch (err) {\n  //       ^?\n}\n\n// case 3\ntry {\n  throw undefined;\n} catch (err) {\n  //       ^?\n}\n```\n\nこの混沌は TypeScript4.0 でようやく整理されることとなりました。捕捉した値に対して`unknown`型を明記することによって捕捉した値の型はわからないものの型安全を獲得できるようになりました。\n\n```ts twoslash\n// @useUnknownInCatchVariables: false\n// case 1\ntry {\n  throw new Error();\n} catch (err) {\n  //       ^?\n}\n\n// case 2\ntry {\n  throw \"This is an error!\";\n} catch (err: unknown) {\n  //       ^?\n}\n\n// case 3\ntry {\n  throw undefined;\n} catch (err: unknown) {\n  //       ^?\n}\n```\n\n今回のオプションはこの機能を常時有効にするものです。例外が捕捉した値は型の明記をすることなくすべてが`unknown`型として解釈されるようになります。\n\n```ts twoslash\n// case 1\ntry {\n  throw new Error();\n} catch (err) {\n  //       ^?\n}\n\n// case 2\ntry {\n  throw \"This is an error!\";\n} catch (err) {\n  //       ^?\n}\n\n// case 3\ntry {\n  throw undefined;\n} catch (err) {\n  //       ^?\n}\n```\n\nまた、この制限を緩くしたい。つまり`unknown`型ではなく`any`型にしたいのであれば捕捉した値に対し`any`型を明記してください。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/useunknownincatchvariables"
    },
    {
      "title": "オプションの一覧",
      "content": "---\ndescription: TSConfigのオプション一覧\n---\n\n# オプションの一覧\n\n最新の情報は[TypeScriptのTSConfigリファレンス](https://www.typescriptlang.org/ja/tsconfig)もご参照ください。\n\n## ルートオプション\n\nTSConfigのルートのオプションです。これらは、型チェックを対象とするファイルなどのプロジェクト全体に関する設定です。\n\n| オプション名 | 追加されたバージョン |\n| ------------ | -------------------- |\n| files        | -                    |\n| extends      | 2.1                  |\n| include      | 2.0                  |\n| exclude      | -                    |\n| references   | -                    |\n\n## 型チェック\n\n型チェックに関する設定です。\n\n| オプション名                                                                  | 追加されたバージョン |\n| ----------------------------------------------------------------------------- | -------------------- |\n| allowUnreachableCode                                                          | 1.8                  |\n| allowUnusedLabels                                                             | 1.8                  |\n| [alwaysStrict](./alwaysstrict.md)                                             | 2.1                  |\n| [exactOptionalPropertyTypes](./exactoptionalpropertytypes.md)                 | 4.4                  |\n| [noFallthroughCasesInSwitch](./nofallthroughcasesinswitch.md)                 | 1.8                  |\n| [noimplicitany](./noimplicitany.md)                                           | -                    |\n| [noimplicitoverride](./noimplicitoverride.md)                                 | 4.3                  |\n| [noImplicitReturns](./noimplicitreturns.md)                                   | 1.8                  |\n| [noimplicitthis](./noimplicitthis.md)                                         | 2.0                  |\n| [nopropertyaccessfromindexsignature](./nopropertyaccessfromindexsignature.md) | 4.2                  |\n| [nouncheckedindexedaccess](./nouncheckedindexedaccess.md)                     | 4.1                  |\n| [nounusedlocals](./nounusedlocals.md)                                         | 2.0                  |\n| [nounusedparameters](./nounusedparameters.md)                                 | 2.0                  |\n| [strict](./strict.md)                                                         | 2.3                  |\n| [strictbindcallapply](./strictbindcallapply.md)                               | 3.2                  |\n| [strictfunctiontypes](./strictfunctiontypes.md)                               | 2.6                  |\n| [strictnullchecks](./strictnullchecks.md)                                     | 2.0                  |\n| [strictpropertyinitialization](./strictpropertyinitialization.md)             | 2.7                  |\n| [useunknownincatchvariables](./useunknownincatchvariables.md)                 | 4.4                  |\n\n## モジュール解決\n\nTypeScriptコンパイラーのモジュール解決に関する設定です。\n\n| オプション名               | 追加されたバージョン |\n| -------------------------- | -------------------- |\n| allowArbitraryExtensions   | -                    |\n| allowImportingTsExtensions | -                    |\n| allowUmdGlobalAccess       | 3.5                  |\n| baseUrl                    | -                    |\n| customConditions           | -                    |\n| module                     | 1.0                  |\n| moduleResolution           | -                    |\n| moduleSuffixes             | 4.7                  |\n| noResolve                  | -                    |\n| paths                      | -                    |\n| resolveJsonModule          | -                    |\n| resolvePackageJsonExports  | -                    |\n| resolvePackageJsonImports  | -                    |\n| rootDir                    | 1.5                  |\n| rootDirs                   | 2.0                  |\n| typeRoots                  | -                    |\n| types                      | -                    |\n\n## 型定義ファイル・JavaScriptファイルの出力\n\n型定義ファイルやJavaScriptファイルをどのように出力するかの設定です。\n\n| オプション名           | 追加されたバージョン |\n| ---------------------- | -------------------- |\n| declaration            | 1.0                  |\n| declarationDir         | 2.0                  |\n| declarationMap         | 2.9                  |\n| downlevelIteration     | 2.3                  |\n| emitBOM                | -                    |\n| emitDeclarationOnly    | 2.8                  |\n| importHelpers          | -                    |\n| importsNotUsedAsValues | 3.8                  |\n| inlineSourceMap        | 1.5                  |\n| inlineSources          | 1.5                  |\n| mapRoot                | -                    |\n| newLine                | 1.5                  |\n| noEmit                 | -                    |\n| noEmitHelpers          | 1.5                  |\n| noEmitOnError          | 1.4                  |\n| outDir                 | -                    |\n| outFile                | 1.0                  |\n| preserveConstEnums     | -                    |\n| preserveValueImports   | 4.5                  |\n| removeComments         | -                    |\n| sourceMap              | -                    |\n| sourceRoot             | -                    |\n| stripInternal          | -                    |\n\n## JavaScriptのサポート\n\n生のJavaScriptの取り扱いに関する設定です。\n\n| オプション名         | 追加されたバージョン |\n| -------------------- | -------------------- |\n| allowJs              | 1.8                  |\n| checkJs              | 2.3                  |\n| maxNodeModuleJsDepth | -                    |\n\n## エディターサポート\n\nエディター上でのTypeScriptの挙動の設定です。\n\n| オプション名     | 追加されたバージョン |\n| ---------------- | -------------------- |\n| disableSizeLimit | -                    |\n| plugins          | -                    |\n\n## 相互運用性の成約\n\nESModuleとCommonJS間の相互運用や異なるファイルシステムでの開発を想定したファイルの大文字小文字の区別など相互運用性に関する設定です。\n\n| オプション名                            | 追加されたバージョン |\n| --------------------------------------- | -------------------- |\n| allowSyntheticDefaultImports            | 1.8                  |\n| esModuleInterop                         | 2.7                  |\n| forceConsistentCasingInFileNames        | -                    |\n| [isolatedModules](./isolatedModules.md) | 1.5                  |\n| preserveSymlinks                        | -                    |\n| verbatimModuleSyntax                    | -                    |\n\n## 下位互換性のサポート\n\nTypeScriptの下位バージョンをサポートするための設定です。\n\n| オプション名                   | 追加されたバージョン |\n| ------------------------------ | -------------------- |\n| charset                        | -                    |\n| keyofStringsOnly               | 2.9                  |\n| noImplicitUseStrict            | -                    |\n| noStrictGenericChecks          | 2.4                  |\n| out                            | -                    |\n| suppressExcessPropertyErrors   | -                    |\n| suppressImplicitAnyIndexErrors | -                    |\n\n## 言語と環境設定\n\nデコレーターなどの実験的な言語機能やJSX構文に関する設定です。\n\n| オプション名            | 追加されたバージョン |\n| ----------------------- | -------------------- |\n| emitDecoratorMetadata   | -                    |\n| experimentalDecorators  | -                    |\n| jsx                     | 2.2                  |\n| jsxFactory              | -                    |\n| jsxFragmentFactory      | 4.0                  |\n| jsxImportSource         | 4.1                  |\n| lib                     | 2.0                  |\n| moduleDetection         | 4.7                  |\n| noLib                   | -                    |\n| reactNamespace          | -                    |\n| target                  | 1.0                  |\n| useDefineForClassFields | 3.7                  |\n\n## コンパイラの診断情報\n\nコンパイルのプロファイリングなどのコンパイラの診断情報に関する設定です\n\n| オプション名        | 追加されたバージョン |\n| ------------------- | -------------------- |\n| diagnostics         | -                    |\n| explainFiles        | 4.2                  |\n| extendedDiagnostics | -                    |\n| generateCpuProfile  | 3.7                  |\n| listEmittedFiles    | -                    |\n| listFiles           | -                    |\n| traceResolution     | 2.0                  |\n\n## プロジェクト\n\nTypeScriptのProject Referencesに関する設定です。\n\n| オプション名                            | 追加されたバージョン |\n| --------------------------------------- | -------------------- |\n| composite                               | 3.0                  |\n| disableReferencedProjectLoad            | 4.0                  |\n| disableSolutionSearching                | 3.8                  |\n| disableSourceOfProjectReferenceRedirect | 3.7                  |\n| incremental                             | 3.4                  |\n| tsBuildInfoFile                         | 3.4                  |\n\n## 出力フォーマット\n\n出力フォーマットに関する設定です。\n\n| オプション名        | 追加されたバージョン |\n| ------------------- | -------------------- |\n| noErrorTruncation   | -                    |\n| preserveWatchOutput | -                    |\n| pretty              | -                    |\n\n## 型チェックの完全性\n\n型チェックの厳密性に関する設定です。\n\n| オプション名        | 追加されたバージョン |\n| ------------------- | -------------------- |\n| skipDefaultLibCheck | -                    |\n| skipLibCheck        | 2.0                  |\n\n## ファイル監視\n\nファイルの監視に関する設定です。\n\n| オプション名                              | 追加されたバージョン |\n| ----------------------------------------- | -------------------- |\n| assumeChangesOnlyAffectDirectDependencies | 3.8                  |\n| watchFile                                 | 3.8                  |\n| watchDirectory                            | 3.8                  |\n| fallbackPolling                           | 3.8                  |\n| synchronousWatchDirectory                 | -                    |\n| excludeDirectories                        | -                    |\n| excludeFiles                              | -                    |\n\n## 型の取得\n\nJavaScriptプロジェクトでの型のダウンロードに関する設定です。\n\n| オプション名                        | 追加されたバージョン |\n| ----------------------------------- | -------------------- |\n| enable                              | -                    |\n| include                             | -                    |\n| exclude                             | -                    |\n| disableFilenameBasedTypeAcquisition | 4.1                  |\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/option-list"
    },
    {
      "title": "alwaysStrict",
      "content": "---\ndescription: JavaScriptのstrictモードを有効にする\ntags: [strict]\n---\n\n# alwaysStrict\n\n`alwaysStrict`はJavaScriptのstrictモードを有効にするコンパイラオプションです。\n\n- デフォルト: [strict](./strict.md)が有効の場合は`true`、それ以外は`false`\n- 追加されたバージョン: 2.1\n- TypeScript公式が有効化推奨\n\n## 解説\n\n`'use strict'`を各ファイルの先頭に付加します。\n",
      "url": "https://typescriptbook.jp/reference/tsconfig/alwaysstrict"
    },
    {
      "title": "セッターとゲッター (set, get)",
      "content": "---\nsidebar_label: セッターとゲッター\n---\n\n# セッターとゲッター (set, get)\n\nプロパティへのインターセプター(参照・代入・監視などの意味)としGetter/Setterがあります。\n\n記述方法のサンプルは次のようになります。\n\n```ts twoslash\nclass Human {\n  private _name: string;\n\n  public constructor(name: string) {\n    this._name = name;\n  }\n\n  // Getter宣言\n  get name(): string {\n    return this._name;\n  }\n\n  // Setter宣言\n  set name(name: string) {\n    this._name = name;\n  }\n}\n\nconst human = new Human(\"\");\n// Setterを利用\nhuman.name = `田中太郎`;\n// Getterを利用\nconsole.log(human.name);\n// @log: 田中太郎\n```\n\nメソッドと違い、getter/setterを呼ぶ場合は`()`は不要です。\n\n```ts twoslash\nclass Human {\n  private _name: string;\n\n  public constructor(name: string) {\n    this._name = name;\n  }\n\n  get name(): string {\n    return this._name;\n  }\n\n  set name(name: string) {\n    this._name = name;\n  }\n}\n\nconst human = new Human(\"田中太郎\");\n// ---cut---\n// @errors: 2349 6234\n// Getter\nconsole.log(human.name); // 正しいGetterの使用方法\n// @log: \"田中太郎\"\nconsole.log(human.name()); // エラー :human.name is not a function\n\n// Setter\nhuman.name = \"田中太郎\"; // 正しいSetterの使用方法\nhuman.name(\"田中太郎\");\n```\n\n## Getter\n\nGetterの記述方法を日本語で表すと次のようになります。\n\n```ts\nget 名前(): 型 {\n  必要ならば処理();\n  return 戻り値;\n}\n```\n\nGetterに引数を指定することはできません。また戻り値を必ず指定する必要があります。\n\n## Setter\n\nSetterの記述方法を日本語で表すと次のようになります。\n\n```ts\nset 名前(変数 : 型) {\n  必要ならば処理();\n  保存処理();\n}\n```\n\n引数が必ずひとつ必要です。また戻り値を指定することはできません。\n",
      "url": "https://typescriptbook.jp/reference/advanced-topics/getters-and-setters"
    },
    {
      "title": "ジェネレーター (generator)",
      "content": "---\nsidebar_label: ジェネレーター\n---\n\n# ジェネレーター (generator)\n\nGeneratorを使用した関数はアロー関数での表記ではなく、必ず`function*() {}`と書く必要があります。次は可能なGeneratorの記述方法です。\n\n```ts twoslash\nfunction* generatorFunction1() {\n  // ...\n}\n\nconst generatorFunction2 = function* () {\n  // ...\n};\n\nclass GeneratorSample {\n  public *generatorFunction3() {\n    // ...\n  }\n}\n```\n\nGeneratorは反復可能(`Iterable<T>`)な反復子(`Iterator<T>`)であるインターフェース`IterableIterator<T>`を実装したクラスのオブジェクトのことです。条件を満たしたクラスはGenerator関数の中で`yield`キーワードを使えます。`yield`は呼ばれたときに一度その値を呼び出し元へ返却し、次に呼ばれたときはその続きから処理を開始します。\n\n`Promise`が一般化する以前、非同期処理を代わりに担当する目的でGeneratorが使われていたことはありますが、前述の`Promise`に加えて`async / await`が一般的に使われるようになってから非同期処理の目的でGeneratorを使う機会は減りました。現在でも大量のデータを取得したいときに一度ではなく、小出しに取得したいときにGeneratorは使い道があります。\n",
      "url": "https://typescriptbook.jp/reference/advanced-topics/generator"
    },
    {
      "title": "デュアルパッケージ開発者のためのtsconfig (Dual Package)",
      "content": "---\nsidebar_label: デュアルパッケージ開発者のためのtsconfig\n---\n\n# デュアルパッケージ開発者のためのtsconfig (Dual Package)\n\nフロントエンドでもバックエンドでもTypeScriptこれ一本！Universal JSという考えがあります。確かにフロントエンドを動的にしたいのであればほぼ避けて通れないJavaScriptと、バックエンドでも使えるようになったJavaScriptで同じコードを使いまわせれば保守の観点でも異なる言語を触る必要がなくなり、統一言語としての価値が大いにあります。\n\nしかしながらフロントエンドとバックエンドではJavaScriptのモジュール解決の方法が異なります。この差異のために同じTypeScriptのコードを別々に分けなければいけないかというとそうではありません。ひとつのモジュールを`commonjs, esmodule`の両方に対応した出力をするDual Packageという考えがあります。\n\n## Dual Packageことはじめ\n\n名前が仰々しいですが、やることは`commonjs`用のJavaScriptと`esmodule`用のJavaScriptを出力することです。つまり出力する`module`の分だけtsconfig.jsonを用意します。\n\nプロジェクトはおおよそ次のような構成になります。\n\n```text\n./\n├── tsconfig.base.json\n├── tsconfig.cjs.json\n├── tsconfig.esm.json\n└── tsconfig.json\n```\n\n- tsconfig.base.json\n  - 基本となるtsconfig.jsonです\n- tsconfig.cjs.json\n  - tsconfig.base.jsonを継承した`commonjs`用のtsconfig.jsonです\n- tsconfig.esm.json\n  - tsconfig.base.jsonを継承した`esmodule`用のtsconfig.jsonです\n- tsconfig.json\n  - IDEはこの名前を優先して探すので、そのためのtsconfig.jsonです\n\ntsconfig.base.jsonとtsconfig.jsonを分けるかどうかについては好みの範疇です。まとめてしまっても問題はありません。\n\n### tsconfig.jsonの継承\n\ntsconfig.jsonは他のtsconfig.jsonを継承する機能があります。上記はtsconfig.cjs.json, tsconfig.esm.jsonは次のようにしてtsconfig.base.jsonを継承しています。\n\n```json\n// tsconfig.cjs.json\n{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist/cjs\"\n    // ...\n  }\n}\n```\n\n```json\n// tsconfig.esm.json\n{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"outDir\": \"./dist/esm\"\n    // ...\n  }\n}\n```\n\n`outDir`はコンパイルした`js`と、型定義ファイルを出力していれば(後述)それを出力するディレクトリを変更するオプションです。\n\nこのようなtsconfig.xxx.jsonができていれば、あとは次のようにファイル指定してコンパイルをするだけです。\n\n```bash\ntsc -p tsconfig.cjs.json\ntsc -p tsconfig.esm.json\n```\n\n## Dual Packageのためのpackage.json\n\npackage.jsonもDual Packageのための設定が必要です。\n\n### `main`\n\npackage.jsonにあるそのパッケージのエントリーポイントとなるファイルを指定する項目です。Dual Packageのときはここに`commonjs`のエントリーポイントとなる`js`ファイルを設定します。\n\n### `module`\n\nDual Packageのときはここに`esmodule`のエントリーポイントとなる`js`ファイルを設定します。\n\n### `types`\n\n型定義ファイルのエントリーポイントとなる`ts`ファイルを設定します。型定義ファイルを出力するようにしていれば`commonjs, esmodule`のどちらのtsconfig.jsonで出力したものでも問題ありません。\n\npackage.jsonはこのようになっているでしょう。\n\n```json\n{\n  \"name\": \"YYTS\",\n  \"version\": \"1.0.0\",\n  \"license\": \"CC BY-SA 3.0\",\n  \"main\": \"./cjs/index.js\",\n  \"module\": \"./esm/index.js\",\n  \"types\": \"./esm/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"yarn build:cjs && yarn build:esm\",\n    \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n    \"build:esm\": \"tsc -p tsconfig.esm.json\"\n  }\n}\n```\n\nコンパイル後の`js`のファイルの出力先はあくまでも例です。tsconfig.jsonの`outDir`を変更すれば出力先を変更できるのでそちらを設定後、package.jsonでエントリーポイントとなる`js`ファイルの設定をしてください。\n\n## Tree Shaking\n\n`module bundler`の登場により、フロントエンドは今までのような`<script>`でいろいろな`js`ファイルを読み込む方式に加えてを全部載せ`js`にしてしまうという選択肢が増えました。この全部載せ`js`は開発者としては自分ができるすべてをそのまま実行環境であるブラウザに持っていけるので楽になる一方、ひとつの`js`ファイルの容量が大きくなりすぎるという欠点があります。特にそれがSPA(Single Page Application)だと問題です。SPAは読み込みが完了してから動作するのでユーザーにしばらく何もない画面を見せることになってしまいます。\n\nこの事態を避けるために`module bundler`は容量削減のための涙ぐましい努力を続けています。その機能のひとつとして題名のTree Shakingを紹介するとともに、開発者にできるTree Shaking対応パッケージの作り方を紹介します。\n\n### Tree Shakingとは\n\nTree Shakingとは使われていない関数、クラスを最終的な`js`ファイルに含めない機能のことです。使っていないのであれば入れる必要はない。というのは至極当然の結論ですがこのTree Shakingを使うための条件があります。\n\n- `esmodule`で書かれている\n- 副作用(side effects)のないコードである\n\n各条件の詳細を見ていきましょう。\n\n## `esmodule`で書かれている\n\n`commonjs`と`esmodule`では外部ファイルの解決方法が異なります。\n\n`commonjs`は`require()`を使用します。`require()`はファイルのどの行でも使用ができますが`esmodule`の`import`はファイルの先頭でやらなければならないという決定的な違いがあります。\n\n`require()`はあるときはこの`js`を、それ以外のときはあの`js`を、と読み込むファイルをコードで切り替えることができます。つまり、次のようなことができます。\n\n```ts twoslash\ndeclare function shouldCallPolice(): boolean;\n// ---cut---\nlet police = null;\nlet firefighter = null;\n\nif (shouldCallPolice()) {\n  police = require(\"./police\");\n} else {\n  firefighter = require(\"./firefighter\");\n}\n```\n\n一方、先述のとおり`esmodule`はコードに読み込みロジックを混ぜることはできません。\n\n上記例で`shouldCallPolice()`が常に`true`を返すように作られていたとしても`module bundler`はそれを検知できない可能性があります。本来なら必要のない`firefighter`を読み込まないという選択を取ることは難しいでしょう。\n\n最近では`commonjs`でもTree Shakingができる`module bundler`も登場しています。\n\n## 副作用のないコードである\n\nここで言及している副作用とは以下が挙げられます。\n\n- `export`するだけで効果がある\n- プロトタイプ汚染のような、既存のものに対して影響を及ぼす\n\nこれらが含まれているかもしれないと`module bundler`が判断するとTree Shakingの効率が落ちます。\n\n### 副作用がないことを伝える\n\n`module bundler`に制作したパッケージに副作用がないことを伝える方法があります。package.jsonにひとつ加えるだけで完了します。\n\n### `sideEffects`\n\nこのプロパティをpackage.jsonに加えて、値を`false`とすればそのパッケージには副作用がないことを伝えられます。\n\n```json\n{\n  \"name\": \"YYTS\",\n  \"version\": \"1.0.0\",\n  \"license\": \"CC BY-SA 3.0\",\n  \"sideEffects\": false,\n  \"main\": \"./cjs/index.js\",\n  \"module\": \"./esm/index.js\",\n  \"types\": \"./esm/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"yarn build:cjs && yarn build:esm\",\n    \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n    \"build:esm\": \"tsc -p tsconfig.esm.json\"\n  }\n}\n```\n\n副作用があり、そのファイルが判明しているときはそのファイルを指定します。\n\n```json\n{\n  \"name\": \"YYTS\",\n  \"version\": \"1.0.0\",\n  \"license\": \"CC BY-SA 3.0\",\n  \"sideEffects\": [\"./xxx.js\", \"./yyy.js\"],\n  \"main\": \"./cjs/index.js\",\n  \"module\": \"./esm/index.js\",\n  \"types\": \"./esm/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"yarn build:cjs && yarn build:esm\",\n    \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n    \"build:esm\": \"tsc -p tsconfig.esm.json\"\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/advanced-topics/tsconfig-for-dual-package-developers"
    },
    {
      "title": "NPMパッケージ開発者のためのtsconfig",
      "content": "# NPMパッケージ開発者のためのtsconfig\n\n## パッケージを使う人にもTypeScriptによる型の享受を目指す\n\nパッケージを公開するときは、動作する形で公開するのが前提なので`js`にする必要があります。つまりコンパイルは必須です。ですがせっかくTypeScriptで作ったのだからパッケージの型情報も提供しましょう。\n\n### 型定義ファイルも出力する\n\n型定義ファイルを一緒に出力しましょう。そのためにはtsconfig.jsonにある`declaration`の項目を`true`に変更します。\n\n```json\n\"declaration\": true,\n/* Generates corresponding '.d.ts' file. */\n```\n\nこのように設定するとコンパイルで出力した`js`ファイルと同じディレクトリに同名で拡張子が`d.ts`のファイルも出力されるようになります。これが型情報のファイルです。なおこの型定義ファイルだけをコンパイルで出力された`js`と別のディレクトリに出力するためのオプションは存在しません。\n\n変哲もない`number`型のプロパティ持つ`Value Object`を作ったとします。\n\n```ts twoslash\nclass NumericalValueObject {\n  private value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public equals(other: NumericalValueObject): boolean {\n    return this.value === other.value;\n  }\n\n  public toString(): string {\n    return `${this.value}`;\n  }\n}\n```\n\nこれをコンパイルし、型定義を生成するとこのようになっています。\n\n```ts twoslash\ndeclare class NumericalValueObject {\n  private value;\n  constructor(value: number);\n  equals(other: NumericalValueObject): boolean;\n  toString(): string;\n}\n```\n\n内容自体はちょうどインターフェースのようなファイルとなっています。\n\n### 宣言元へのジャンプでの`ts`ファイルを参照できるようにする\n\nIDEを使っているときに有用で、実際のTypeScriptのソースコードがどのようにコーディングされているかを閲覧することができるようになります。tsconfig.jsonにある`declarationMap`の項目を`true`に変更します。\n\n```json\n\"declarationMap\": true,\n/* Generates a sourcemap for each corresponding '.d.ts' file. */\n```\n\nこのように設定するとコンパイルで出力した`js`ファイルと同じディレクトリに同名で拡張子が`d.ts.map`のファイルも出力されるようになります。このファイルは元の`ts`と実際に動作する`js`の対応付けをしてくれます。ただしこの設定だけでは不十分で、参照元となる元の`ts`ファイルも一緒にパッケージとして公開する必要があります。\n\n### 元の`ts`も公開する\n\n特に設定していなければ元の`ts`ファイルも公開されますが、公開する内容を調整している場合は逆にpackage.jsonの`files`プロパティを変更して元の`ts`ファイルも公開するように変更が必要です。tsconfig.jsonの`declarationMap`を設定しても元の`ts`ファイルを参照できないときはここで公開する内容を制限していないか確認してください。\n\n```json\n{\n  \"name\": \"YYTS\",\n  \"version\": \"1.0.0\",\n  \"license\": \"CC BY-SA 3.0\",\n  \"sideEffects\": false,\n  \"main\": \"./cjs/index.js\",\n  \"module\": \"./esm/index.js\",\n  \"types\": \"./esm/index.d.ts\",\n  \"files\": [\"dist\", \"src\"],\n  \"scripts\": {\n    \"build\": \"yarn build:cjs && yarn build:esm\",\n    \"build:cjs\": \"tsc -p tsconfig.cjs.json\",\n    \"build:esm\": \"tsc -p tsconfig.esm.json\"\n  }\n}\n```\n\nこの例は`dist`にコンパイルした結果の`js, d.ts, d.ts.map`があり、`src`に元の`ts`があるものと想定しています。\n\n実際にパッケージとなるファイルにどのようなファイルが含まれているかについては次のコマンドを実行してください。\n\n```sh\nnpm publish --dry-run\n```\n\n### JavaScriptの`sourceMap`も出力する\n\n`sourceMap`とはAltJSがコンパイルされたJavaScriptとの行を一致させるものです。これがあることによってデバッグやトレースをしているときに、元の`ts`ファイルの何行目で問題が発生しているかわかりやすくなります。`module bundler`を使用するときはこのオプションを有効にしていないと基本的に何もわかりません。このオプションはパッケージを公開しないとしても有効にしておくことが望ましいでしょう。\n\ntsconfig.jsonにある`sourceMap`の項目を`true`に変更します。\n\n```json\n\"sourceMap\": true,\n/* Generates corresponding '.map' file. */\n```\n\nこちらもコンパイルで出力した`js`ファイルと同じディレクトリに同名で拡張子が`js.map`のファイルも出力されるようになります。\n",
      "url": "https://typescriptbook.jp/reference/advanced-topics/tsconfig-for-npm-package-developers"
    },
    {
      "title": "型の再利用",
      "content": "---\nslug: /reference/type-reuse\n---\n\n# 型の再利用\n\nTypeScriptでは型から別の型を導き出す機能があります。既存の型を再度利用して、新たな型を生み出すことを本書では「型の再利用」と呼ぶことにします。\n\n## 型の再利用のメタファー\n\n多くのプログラミング言語では、変数を処理して別の変数を導き出せます。たとえば、あるオブジェクトのキーの配列が欲しいとき、キーの配列を別途宣言してもよいです。しかし、オブジェクトからキーを導きだしたほうが変更に強いコードになります。\n\n```ts twoslash\nconst obj = { a: 1, b: 2, c: 3 };\nconst keys1 = [\"a\", \"b\", \"c\"];\nconst keys2 = Object.keys(obj); // keys1より保守性が高い\n```\n\n上は変数の再利用の例です。TypeScriptには変数の再利用の型バージョンがあります。それが型の再利用です。たとえば、あるオブジェクトの型からキーの型を導き出すことができます。\n\n```ts twoslash\ntype Obj = { a: string; b: string; c: string };\ntype Keys = keyof Obj;\n//=> \"a\" | \"b\" | \"c\"\n```\n\n型の再利用とは、変数の再利用のメタファーなのです。\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/README"
    },
    {
      "title": "Extract&lt;T, U>の型引数",
      "content": "---\ndescription: 任意の型だけを抽出する\ntitle: \"Extract<T, U>\"\n---\n\n`Extract<T, U>`は、ユニオン型`T`から`U`で指定した型だけを抽出した型を返すユーティリティ型です。\n\n## Extract&lt;T, U>の型引数\n\n### T\n\n型引数`T`には、抽出されるほうのユニオン型を渡します。\n\n### U\n\n型引数`U`には、抽出したい型を渡します。\n\n## Extractの使用例\n\n```ts twoslash\ntype Grade = \"A\" | \"B\" | \"C\" | \"D\" | \"E\";\ntype FailGrade = Extract<Grade, \"D\" | \"E\">;\n//   ^?\n```\n\nExtractは2つのユニオン型の共通部分を導き出すことにも使えます。\n\n```ts twoslash\ntype CommonTypes = Extract<\"a\" | \"b\" | \"c\", \"b\" | \"c\" | \"d\">;\n//   ^?\n```\n\n## 関連情報\n\n[Exclude&lt;T, U>](exclude.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/extract"
    },
    {
      "title": "Required&lt;T>の型引数",
      "content": "---\ndescription: 全プロパティを必須にする\ntitle: Required<T>\n---\n\n`Required<T>`は、`T`のすべてのプロパティからオプショナルであることを意味する`?`を取り除くユーティリティ型です。\n\n## Required&lt;T>の型引数\n\n### T\n\n型引数`T`にはオブジェクトの型を表す型を代入します。\n\n## Requiredの使用例\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\ntype RequiredPerson = Required<Person>;\n//    ^?\n```\n\n上の`RequiredPerson`は次と同じ型になります。\n\n```ts twoslash\ntype RequiredPerson = {\n  surname: string;\n  middleName: string;\n  givenName: string;\n};\n```\n\n## 関連情報\n\n[Partial&lt;T>](partial.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/required"
    },
    {
      "title": "Exclude&lt;T, U>の型引数",
      "content": "---\ndescription: 任意の型を除外する\ntitle: \"Exclude<T, U>\"\n---\n\n`Exclude<T, U>`は、ユニオン型`T`から`U`で指定した型を取り除いたユニオン型を返すユーティリティ型です。\n\n## Exclude&lt;T, U>の型引数\n\n### T\n\n型引数`T`には、ユニオン型を渡します。\n\n### U\n\n型引数`U`には、`T`から取り除きたい型を渡します。\n\n## Excludeの使用例\n\n```ts twoslash\ntype Grade = \"A\" | \"B\" | \"C\" | \"D\" | \"E\";\ntype PassGrade = Exclude<Grade, \"E\">;\n```\n\n上のPassGradeは次の型と同じになります。\n\n```ts twoslash\ntype PassGrade = \"A\" | \"B\" | \"C\" | \"D\";\n```\n\n`Exclude`の第2引数をユニオン型にすると、複数の型を取り除くこともできます。\n\n```ts twoslash\ntype Grade = \"A\" | \"B\" | \"C\" | \"D\" | \"E\";\ntype PassGrade = Exclude<Grade, \"D\" | \"E\">;\n//   ^?\n```\n\n## Excludeの注意点\n\n`U`は`T`の部分集合である制限がありません。つまり、`T`に存在しない型を`U`に入れてしまったり、タイポなどに気をつけなければいけません。次の例は、Pull Requestに関する型と解釈してください。\n\n```ts twoslash\ntype PullRequestState = \"draft\" | \"reviewed\" | \"rejected\";\ntype MergeableState = Exclude<PullRequestState, \"draft\" | \"rejected\">;\n//   ^?\n```\n\n`MergeableState`は`reviewed`を意味しますが、この`Exclude`の使い方には2つの潜在的な問題があります。\n\n### `PullRequestState`に新しい状態が追加された時\n\n`PullRequestState`に`testFailed`という`MergeableState`に含めたくない状態を追加したとします。するとこの修正に伴って`MergeableState`の第2引数も同時に修正しないといけません。これを忘れると`testFailed`は`MergeableState`に含まれてしまいます。\n\n```ts twoslash\ntype PullRequestState = \"draft\" | \"reviewed\" | \"rejected\" | \"testFailed\";\ntype MergeableState = Exclude<PullRequestState, \"draft\" | \"rejected\">;\n//   ^?\n```\n\n### 変更した場合\n\n`PullRequestState`の`draft`を`open`に変更しました。この場合も、`Exclude`の第2引数の修正を忘れると`MergeableState`に`open`が含まれてしまいます。\n\n```ts twoslash\ntype PullRequestState = \"open\" | \"reviewed\" | \"rejected\";\ntype MergeableState = Exclude<PullRequestState, \"draft\" | \"rejected\">;\n//   ^?\n```\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/exclude"
    },
    {
      "title": "Pick&lt;T, Keys>の型引数",
      "content": "---\ndescription: 任意のプロパティだけを持つオブジェクト型を作る\ntitle: \"Pick<T, Keys>\"\n---\n\n`Pick<T, Keys>`は、型`T`から`Keys`に指定したキーだけを含むオブジェクトの型を返すユーティリティ型です。\n\n## Pick&lt;T, Keys>の型引数\n\n### T\n\n型引数`T`にはオブジェクトの型を代入します。\n\n### Keys\n\n`Keys`にはオブジェクトの型`T`のプロパティキーを指定します。object型`T`に存在しないプロパティーキーを指定するとコンパイルエラーになります。\n\n## Pickの使用例\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype Person = Pick<User, \"surname\" | \"middleName\" | \"givenName\">;\n```\n\n上の`Person`は次の型と同じになります。\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\n```\n\n## Pickで型の変更に追従する例\n\n書籍を扱うサービスを作ったとして、書籍を意味するオブジェクト`Book`が次のように定義されているとします。\n\n```ts twoslash\ntype Book = {\n  id: number;\n  title: string;\n  author: string;\n  createdAt: Date;\n  updatedAt: Date;\n};\n```\n\nこれを参考にして`Book`を作成するための入力データとして`BookInputData`を作るとします。これは外部からのリクエストで作成され、`id, createdAt, updatedAt`はこのサービスで後付けで割り当てられるとすれば`BookInputData`は次になります。\n\n```ts twoslash\ntype BookInputData = {\n  title: string;\n  author: string;\n};\n```\n\nここで`author`プロパティが`string`ではなく`Person`になる必要があったとします。`Book, BookInputData`を独立して定義しているとこの変更のために都度、各々の`author`プロパティを変更する必要があります。\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\n// ---cut---\ntype Book = {\n  id: number;\n  title: string;\n  author: Person; // 変更箇所\n  createdAt: Date;\n  updatedAt: Date;\n};\n\ntype BookInputData = {\n  title: string;\n  author: Person; // 変更箇所\n};\n```\n\nこれらの定義が近くにある状態ならまだしも、異なるファイルにあれば非常に探し辛くなります。\n\nそこで`BookInputData`を`Pick<T, K>`を使って定義しなおします。\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\ntype Book = {\n  id: number;\n  title: string;\n  author: Person;\n  createdAt: Date;\n  updatedAt: Date;\n};\n// ---cut---\ntype BookInputData = Pick<Book, \"title\" | \"author\">;\n```\n\nこのようにすれば`BookInputData`は少なくとも`Book`とコード上の繋がりができる上に、`author`プロパティの型変更を自動で追従してくれるようになります。\n\n## 関連情報\n\n[Omit&lt;T, Keys>](omit.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/pick"
    },
    {
      "title": "NoInfer&lt;T>の型引数",
      "content": "---\ndescription: 型推論を防ぐ\ntitle: NoInfer<T>\n---\n\n`NoInfer<T>`は、`T`の型推論を防ぐためのユーティリティ型です。\n\n## NoInfer&lt;T>の型引数\n\n### T\n\n型引数`T`には推論を防ぎたい型を代入します。\n\n## NoInferの使用例\n\nまずはNoInferを使用しなかった場合の例です。ジェネリクスを使って`getIndexFromArray`という関数を定義します\n\n```ts\nfunction getIndexFromArray<T extends string>(elements: T[], item: T): number {\n  return elements.findIndex((element) => element === item);\n}\n\ntype Fruit = \"grape\" | \"apple\" | \"banana\";\nconst fruits: Fruit[] = [\"grape\", \"apple\", \"banana\"];\ngetIndexFromArray(fruits, \"apple\");\ngetIndexFromArray(fruits, \"peach\");\n```\n\nこのとき`T`は`\"grape\" | \"apple\" | \"banana\" | \"peach\"`と推論されてしまいます。しかし第二引数には配列に含まれている要素のみを許容したいです。そこで`NoInfer`を利用することにより`T`の型推論を防ぐことができます。\n\n```ts twoslash\nfunction getIndexFromArray<T extends string>(\n  elements: T[],\n  item: NoInfer<T>\n): number {\n  return elements.findIndex((element) => element === item);\n}\n\ntype Fruit = \"grape\" | \"apple\" | \"banana\";\nconst fruits: Fruit[] = [\"grape\", \"apple\", \"banana\"];\ngetIndexFromArray(fruits, \"apple\");\n// @errors: 2345\ngetIndexFromArray(fruits, \"peach\");\n```\n\n## 関連情報\n\n[Infer](../../values-types-variables/type-inference.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/no-infer"
    },
    {
      "title": "Partial&lt;T>の型引数",
      "content": "---\ndescription: 全プロパティをオプショナルにする\ntitle: Partial<T>\n---\n\n`Partial<T>`は、オブジェクトの型`T`のすべてのプロパティをオプションプロパティにするユーティリティ型です。\n\n## Partial&lt;T>の型引数\n\n### T\n\n型引数`T`にはオブジェクトの型を渡します。\n\n## Partialの使用例\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\ntype PartialPerson = Partial<Person>;\n//    ^?\n```\n\nこの`PartialPerson`は次の型と同じになります。\n\n```ts twoslash\ntype PartialPerson = {\n  surname?: string;\n  middleName?: string;\n  givenName?: string;\n};\n```\n\n## Partialを用いたOptions Objectパターンの例\n\n`Partial`をOptions Objectパターンに応用すると、省略可能でありながら見やすい関数を実装できます。\n\n[キーワード引数とOptions Objectパターン](../../functions/keyword-arguments-and-options-object-pattern.md)\n\nユーザーの検索をかける関数を作ります。プロパティはそれぞれ引数となっており、対応する引数に値を与えると検索ができる関数`findUsers()`があるとします。ここでは例のため引数をすべてオプション引数にします。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\n\nfunction findUsers(\n  surname?: string,\n  middleName?: string,\n  givenName?: string,\n  age?: number,\n  address?: string,\n  nationality?: string\n) {\n  // ...\n}\n```\n\nこの`findUsers()`のシグネチャだと**年齢だけがXX才の**ユーザーが欲しい時は引数の順番を維持するために他の引数は`undefined`を入力しなければいけません。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\n\ndeclare function findUsers(\n  surname?: string,\n  middleName?: string,\n  givenName?: string,\n  age?: number,\n  address?: string,\n  nationality?: string\n): Promise<User[]>;\n// ---cut---\nfindUsers(undefined, undefined, undefined, 22);\n```\n\nこの例では引数は6個しかなく`age`以降の引数は省略できるためそこまで見辛くありませんが、多い引数の関数になるとどこが対応する引数なのかを探すだけでも面倒です。これを`Partial<T>`を使って見た目をよくできます。\n\nまず引数はすべてオブジェクトで受け渡しされるものとしてそのオブジェクトの型を定義します。さらにプロパティを省略可能にするために`Partial<T>`をつけます。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\n// ---cut---\ntype FindUsersArgs = Partial<User>;\n```\n\nこれを関数`findUsers()`の引数にします。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype FindUsersArgs = Partial<User>;\n// ---cut---\nfunction findUsers({\n  surname,\n  middleName,\n  givenName,\n  age,\n  address,\n  nationality,\n}: FindUsersArgs) {\n  // ...\n}\n```\n\nこれだけではまだ呼び出し側は省略ができません。`findUsers()`を使用する時は仮に何も設定する必要がなくても引数に`{}`を与えなければいけません。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype FindUsersArgs = Partial<User>;\n\ndeclare function findUsers(findUser: FindUsersArgs): unknown;\n// ---cut---\nfindUsers({});\n```\n\n引数を省略できるようにするためにデフォルト引数を使い省略時に`{}`が代入されるようにします。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype FindUsersArgs = Partial<User>;\n// ---cut---\nfunction findUsers({\n  surname,\n  middleName,\n  givenName,\n  age,\n  address,\n  nationality,\n}: FindUsersArgs = {}) {\n  // ...\n}\n\nfindUsers();\nfindUsers({ age: 22 });\n```\n\n`FindUsersArgs`の右の`= {}`がそれにあたります。これにより`findUsers()`は引数がなくても呼び出せるようになります。特定の引数だけ値を指定することもできます。`findUsers({ age: 22 })`がその例です。\n\nさらに`FindUsersArgs`側にもデフォルト型を設定することで初期値を代入することもできます。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype FindUsersArgs = Partial<User>;\n// ---cut---\nfunction findUsers({\n  surname = \"Doe\",\n  givenName = \"John\",\n  nationality = \"Araska\",\n  age = 22,\n}: FindUsersArgs = {}) {\n  // ...\n}\n```\n\n## 関連情報\n\n[Required&lt;T>](required.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/partial"
    },
    {
      "title": "Record&lt;Keys, Type>の型引数",
      "content": "---\ndescription: キー・バリューからオブジェクト型を作る\ntitle: \"Record<Keys, Type>\"\n---\n\n`Record<Keys, Type>`はプロパティのキーが`Keys`であり、プロパティの値が`Type`であるオブジェクトの型を作るユーティリティ型です。\n\n## Record&lt;Keys, Type>の型引数\n\n### Keys\n\nオブジェクトのプロパティーキーを指定します。`Keys`に代入できる型は、`string`、`number`、`symbol`とそれぞれのリテラル型です。\n\n### Type\n\nオブジェクトのプロパティの値の型を指定します。任意の型が代入できます。\n\n## Recordの使用例\n\nキーが`string`で値が`number`のインデックス型を定義する。\n\n```ts twoslash\ntype StringNumber = Record<string, number>;\nconst value: StringNumber = { a: 1, b: 2, c: 3 };\n```\n\nキーが`firstName`、`middleName`、`familyName`で、値が文字列になるオブジェクトの型を定義する。\n\n```ts twoslash\ntype Person = Record<\"firstName\" | \"middleName\" | \"lastName\", string>;\nconst person: Person = {\n  firstName: \"Robert\",\n  middleName: \"Cecil\",\n  lastName: \"Martin\",\n};\n```\n\n## 関連情報\n\n[インデックス型 (index signature)](../../values-types-variables/object/index-signature.md)\n\n[マップ型 (Mapped Types)](../mapped-types.md)\n\n[Map<K, V>](../../builtin-api/map.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/record"
    },
    {
      "title": "Readonly&lt;T>の型引数",
      "content": "---\ndescription: 全プロパティを読み取り専用にする\ntitle: Readonly<T>\n---\n\n`Readonly<T>`は、オブジェクトの型`T`のプロパティをすべて読み取り専用にするユーティリティ型です。\n\n## Readonly&lt;T>の型引数\n\n### T\n\n型引数`T`にはオブジェクトの型を代入します。\n\n## Readonlyの使用例\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\ntype ReadonlyPerson = Readonly<Person>;\n//    ^?\n```\n\n上の`ReadonlyPerson`は次の型と同じになります。\n\n```ts twoslash\ntype ReadonlyPerson = {\n  readonly surname: string;\n  readonly middleName?: string;\n  readonly givenName: string;\n};\n```\n\n## Readonlyの効果は再帰的ではない\n\n`Readonly<T>`が読み取り専用にするのは、オブジェクトの型`T`直下のプロパティのみです。プロパティがオブジェクトだった場合、それが持つプロパティまでは読み取り専用にならないので注意してください。\n\n## 関連情報\n\n[オブジェクト型のreadonlyプロパティ (readonly property)](../../values-types-variables/object/readonly-property.md)\n\n[クラスのreadonly修飾子](../../object-oriented/class/readonly-modifier-in-classes.md)\n\n[インターフェースのreadonly修飾子](../../object-oriented/interface/readonly-modifier-in-interfaces.md)\n\n[readonlyとconstの違い](../../values-types-variables/object/readonly-vs-const.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/readonly"
    },
    {
      "title": "Omit&lt;T, Keys>の型引数",
      "content": "---\ndescription: 任意のプロパティを除いたオブジェクト型を作る\ntitle: \"Omit<T, Keys>\"\n---\n\n`Omit<T, Keys>`は、オブジェクトの型`T`から`Keys`で指定したプロパティを除いたobject型を返すユーティリティ型です。\n\n## Omit&lt;T, Keys>の型引数\n\n### T\n\n型引数`T`にはオブジェクトの型を渡します。\n\n### Keys\n\n`Keys`には引数`T`のプロパティキーを指定します。ここで指定したプロパティキーと一致するプロパティを`T`から除去します。\n\n## Omitの使用例\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype Optional = \"age\" | \"address\" | \"nationality\" | \"createdAt\" | \"updatedAt\";\ntype Person = Omit<User, Optional>;\n```\n\n上の`Person`型は次の型と同じになります。\n\n```ts twoslash\ntype Person = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n};\n```\n\n## Omitの注意点\n\n`Omit<T, Keys>`の`Keys`に`T`には無いプロパティキーを指定しても、TypeScriptコンパイラーは指摘しません。たとえば、`Keys`にタイポがあっても検出できないので注意が必要です。\n\n```ts twoslash\ntype User = {\n  surname: string;\n  middleName?: string;\n  givenName: string;\n  age: number;\n  address?: string;\n  nationality: string;\n  createdAt: string;\n  updatedAt: string;\n};\ntype Optional = \"createdat\" | \"updatedat\" | \"age\" | \"address\" | \"nationality\";\n//                      ^^ typo       ^^ typo\ntype Person = Omit<User, Optional>;\n//   ^?\n// このPersonは下の型になる\n```\n\n`User`の`createdAt`,、`updatedAt`の`At`は大文字から始まりますが、これに気づかずに小文字で書いてしまったため、`Omit`の結果は`createdAt`と`updatedAt`を含んでしまいます。\n\n## 関連情報\n\n[Pick&lt;T, Keys>](pick.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/utility-types/omit"
    },
    {
      "title": "keyof型演算子",
      "content": "# keyof型演算子\n\n`keyof`はオブジェクトの型からプロパティ名を型として返す型演算子です。たとえば、`name`プロパティを持つ型に対して、`keyof`を使うと文字列リテラル型の`\"name\"`が得られます。\n\n```ts twoslash\ntype Person = {\n  name: string;\n};\ntype PersonKey = keyof Person;\n//    ^?\n```\n\n2つ以上のプロパティがあるオブジェクトの型に`keyof`を使った場合は、すべてのプロパティ名がユニオン型で返されます。\n\n```ts twoslash\n// @noErrors\ntype Book = {\n  title: string;\n  price: number;\n  rating: number;\n};\ntype BookKey = keyof Book;\n// 上は次と同じ意味になる\ntype BookKey = \"title\" | \"price\" | \"rating\";\n```\n\nインデックス型に`keyof`を使うと、インデックスキーの型が返ります。\n\n```ts twoslash\ntype MapLike = { [K: string]: any };\ntype MapKeys = keyof MapLike;\n//    ^?\n```\n\nキーが`string`のインデックス型は、`string`ではなく`string | number`が返ります。number型のキーアクセスの`obj[0]`は`obj[\"0\"]`と同じになるからです。\n\nMapped Typesに`keyof`を使うと、そのキーの型が返ります。\n\n```ts twoslash\ntype MapLike = { [K in \"x\" | \"y\" | \"z\"]: any };\ntype MapKeys = keyof MapLike;\n//    ^?\n```\n\nプロパティを持たないオブジェクトの型に`keyof`を使うと`never`型が返ります。\n\n```ts twoslash\ntype What = keyof {};\n//   ^?\n```\n\n`any`型に`keyof`を使うと`string | number | symbol`型が返ります。\n\n```ts twoslash\ntype AnyKeys = keyof any;\n//    ^?\n```\n\n## keyofのメリット\n\n`keyof`のメリットは、保守性が上がる点です。オブジェクトの型とは別にプロパティ名のユニオン型を定義していると、オブジェクトの型のプロパティを変更したときに、そのユニオン型のほうも修正が必要になります。`keyof`を使って、オブジェクトの型からキーを導出するようにしておけば、変更箇所はオブジェクトの型のところだけになります。\n\n加えて、プロパティが何十個もあるようなオブジェクトを想像してみてください。そのプロパティ名のユニオン型を定義する必要が出てきたとします。その際に、プロパティ名をすべて転記するとなると、転記漏れや書き間違いもあるでしょう。そういう場合は`keyof`を使うとそもそも書き写す必要がないため、便利な上に安全なコーディングができます。\n\n## keyofはMapped Typesと一緒に使われる\n\nkeyofは単体で使うことよりMapped Typesと組み合わせて使われることが多いです。\n\n[マップ型 (Mapped Types)](mapped-types.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/keyof-type-operator"
    },
    {
      "title": "Conditional Types",
      "content": "---\nsidebar_label: Conditional Types\n---\n\n# Conditional Types\n\nConditional Typesは日本語では条件付き型、型の条件分岐、条件型などと呼ばれ、ちょうど三項演算子のように`?`と`:`を使って`T extends U ? X : Y`のように書きます。これは`T`が`U`に割り当て可能である場合、`X`になり、そうでない場合は`Y`になります。\n\nこのような場合だと型は`true`になります。\n\n```ts twoslash\ntype IsString<T> = T extends string ? true : false;\n\nconst a: IsString<\"a\"> = true;\n//    ^?\n```\n\nたとえば、あるobject型のプロパティを読み取り専用にする`Readonly<T>`というユーティリティ型があります。`Readonly<T>`はそのオブジェクトの直下のプロパティを読み取り専用にしますが、ネストしたオブジェクトのプロパティは読み取り専用にしません。たとえば、次のようなオブジェクトがあるとします。\n\n```ts twoslash\ntype Person = {\n  name: string;\n  age: number;\n  address: {\n    country: string;\n    city: string;\n  };\n};\n```\n\nこのとき`Readonly<Person>`では`address`プロパティ自体は読み取り専用になっており書き換えることはできませんが、`address`のプロパティの`country`と`city`は読み取り専用になっていません。上書きが可能です。\n\n```ts twoslash\ntype Person = {\n  name: string;\n  age: number;\n  address: {\n    country: string;\n    city: string;\n  };\n};\n// ---cut---\n// @errors: 2540\nconst kimberley: Readonly<Person> = {\n  name: \"Kimberley\",\n  age: 24,\n  address: {\n    country: \"Canada\",\n    city: \"Vancouver\",\n  },\n};\n\nkimberley.name = \"Kim\";\nkimberley.age = 25;\nkimberley.address = {\n  country: \"United States\",\n  city: \"Seattle\",\n};\nkimberley.address.country = \"United States\";\nkimberley.address.city = \"Seattle\";\n```\n\nこれを解決するには`Readonly<T>`を再帰的に適用する必要があります。このような場合にMapped TypesとConditional Typesを組み合わせて使います。\n\n```ts twoslash\ntype Freeze<T> = Readonly<{\n  [P in keyof T]: T[P] extends object ? Freeze<T[P]> : T[P];\n}>;\n```\n\nこのような`Freeze<T>`を作ってみました。まずはこれを使ってみましょう。\n\n```ts twoslash\ntype Person = {\n  name: string;\n  age: number;\n  address: {\n    country: string;\n    city: string;\n  };\n};\n\ntype Freeze<T> = Readonly<{\n  [P in keyof T]: T[P] extends object ? Freeze<T[P]> : T[P];\n}>;\n// ---cut---\n// @errors: 2540\nconst kimberley: Freeze<Person> = {\n  name: \"Kimberley\",\n  age: 24,\n  address: {\n    country: \"Canada\",\n    city: \"Vancouver\",\n  },\n};\n\nkimberley.name = \"Kim\";\nkimberley.age = 25;\nkimberley.address = {\n  country: \"United States\",\n  city: \"Seattle\",\n};\nkimberley.address.country = \"United States\";\nkimberley.address.city = \"Seattle\";\n```\n\n`Readonly<T>`とは異なり、`address.country`と`address.city`が書き換え不可能になりました。これは`Freeze<T>`が再帰的に適用されているからです。\n\n`[P in keyof T]`の部分についてはMapped Typesのページで説明していますのでここでは簡潔に説明します。`keyof T`はオブジェクトのキーをユニオン型に変更するものです。`kimberley`の場合は`\"name\" | \"age\" | \"address\"`になります。`in`はその中のどれかを意味します。\n`T[P]`でオブジェクトのあるキーにおけるプロパティの型を取得します。その型が`object`であれば再起的に`Freeze<T[P]>`を適用し、そうでなければ`T[P]`をそのまま使います。\n\n[Mapped Types](../type-reuse/mapped-types.md)\n\nこれによってオブジェクトを再帰的に凍結することができました。\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/conditional-types"
    },
    {
      "title": "infer",
      "content": "---\nsidebar_label: infer\n---\n\n# infer\n\ninferはConditional Typesの中で使われる型演算子です。`infer`は「推論する」という意味で`extends`の右辺にのみ書くことができます。\n\n## ユーティリティ型`ReturnType<T>`の例から`infer`を知る\n\nある関数の戻り値の型を取得するユーティリティ型`ReturnType<T>`があります。`ReturnType<T>`は次のように定義されています。\n\n```ts twoslash\n// @noErrors\ntype ReturnType<T extends (...args: any) => any> = T extends (\n  ...args: any\n) => infer R\n  ? R\n  : any;\n```\n\n試しに使ってみましょう。\n\n```ts twoslash\nconst request = (url: string): Promise<string> => {\n  return fetch(url).then((res) => res.text());\n};\n\ntype X = ReturnType<typeof request>;\n//   ^?\n```\n\n`typeof`は変数から型を取得する演算子です。JavaScriptの`typeof`とは異なるので注意してください。\n\n[typeof型演算子](./typeof-type-operator.md)\n\nこのように関数`request`の型から戻り値の型を取得することができました。\n\n### `ReturnType<T>`の解説\n\n`ReturnType<T>`の構造を知るためにはまず`T extends (...args: any) => any`が何かを知る必要があります。これは一般的な関数の型を示しています。任意の個数で任意の型の引数を受け取り、任意の型の値を返すことを示しています。`T`は任意の関数を示しています。\nそして戻り値の部分が`=> infer R ? R : any`となっており、`T`が関数である場合は戻り値の型である`R`、そうでない場合は`any`を返すという意味になっています。\n総合的に`ReturnType<T>`は`T`が関数に割り当て可能である場合は`R`、そうでない場合は`any`を返します。\n\n`infer`を使うことによってある型`T`が配列である場合はその要素の型、そうでない場合は`never`を返す`Flatten<T>`を作ってみましょう。\n\n```ts twoslash\ntype Flatten<T> = T extends (infer U)[] ? U : never;\n```\n\nこの`Flatten<T>`を使ってみましょう。\n\n```ts twoslash\ntype Flatten<T> = T extends (infer U)[] ? U : never;\n// ---cut---\ntype A = Flatten<string>;\n//   ^?\ntype B = Flatten<string[]>;\n//   ^?\ntype C = Flatten<string[][]>;\n//   ^?\ntype D = Flatten<[string, number]>;\n//   ^?\n```\n\n2次元配列に`Flatten<T>`を適用すると1次元配列が返ってくることが、タプル型に`Flatten<T>`を適用するとユニオン型が返ってくることがわかります。\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/infer"
    },
    {
      "title": "Mapped Types",
      "content": "---\nsidebar_label: Mapped Types\n---\n\n# Mapped Types\n\nインデックス型では設定時はどのようなキーも自由に設定できてしまい、アクセス時は毎回`undefined`かどうかの型チェックが必要です。入力の形式が決まっているのであればMapped Typesの使用を検討できます。\n\nMapped Typesは主にユニオン型と組み合わせて使います。先ほどシステムがサポートする言語を定義しました。\n\n```ts twoslash\ntype SystemSupportLanguage = \"en\" | \"fr\" | \"it\" | \"es\";\n```\n\nこれをインデックス型と同じようにキーの制約として使用することができます。\n\n```ts twoslash\ntype SystemSupportLanguage = \"en\" | \"fr\" | \"it\" | \"es\";\n// ---cut---\ntype Butterfly = {\n  [key in SystemSupportLanguage]: string;\n};\n```\n\nこのように`Butterfly`を定義するとシステムがサポートしない言語、ここでは`de`が設定、使用できなくなります。\n\n```ts twoslash\ntype SystemSupportLanguage = \"en\" | \"fr\" | \"it\" | \"es\";\ntype Butterfly = {\n  [key in SystemSupportLanguage]: string;\n};\n// ---cut---\n// @errors: 2353\nconst butterflies: Butterfly = {\n  en: \"Butterfly\",\n  fr: \"Papillon\",\n  it: \"Farfalla\",\n  es: \"Mariposa\",\n  de: \"Schmetterling\",\n};\n```\n\nプロパティを読み取り専用にする`readonly`をそのオブジェクトのすべてのプロパティに適用する`Readonly<T>`というユーティリティ型があります。他にもユーティリティ型はありますが、それらについては専門のページがありますのでここでは割愛します。\n\n[Readonly&lt;T>](utility-types/readonly.md)\n\n`Readonly<T>`もこの機能で実現されています。`Readonly<T>`は次のように実装されています。\n\n```ts twoslash\n// @noErrors\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n```\n\n`keyof T`という見慣れない表現が登場しましたが、これはオブジェクトのキーをユニオン型に変更するものだと解釈してください。`keyof`の詳細は型演算子をご覧ください。\n\n[keyof型演算子](keyof-type-operator.md)\n\n## Mapped Typesには追加のプロパティが書けない\n\nMapped Typesは追加のプロパティが定義できません。ここは、[インデックス型]とは異なる点です。\n\n<!--prettier-ignore-->\n```ts twoslash\n// @errors: 7061\ntype KeyValuesAndName = {\n  [K in string]: string;\n  name: string; // 追加のプロパティ\n};\n```\n\n追加のプロパティがある場合は、その部分をオブジェクトの型として定義し、Mapped Typesと[インターセクション型]を成す必要があります。\n\n```ts twoslash\ntype KeyValues = {\n  [K in string]: string;\n};\ntype Name = {\n  name: string; // 追加のプロパティ\n};\ntype KeyValuesAndName = KeyValues & Name;\n```\n\n上の例は、ひとつの型にまとめることもできます。\n\n```ts twoslash\ntype KeyValuesAndName = {\n  [K in string]: string;\n} & {\n  name: string; // 追加のプロパティ\n};\n```\n\n[インデックス型]: ../values-types-variables/object/index-signature.md\n[インターセクション型]: ../values-types-variables/intersection.md\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/mapped-types"
    },
    {
      "title": "ユニオン分配 (union distribution)",
      "content": "---\nsidebar_label: ユニオン分配\n---\n\n# ユニオン分配 (union distribution)\n\nユニオン分配はジェネリクスで使われる型変数`T`に対しユニオン型が指定された場合、その各要素に対してジェネリクスの型変数を適用することを指します。\n\nたとえば、次のような型エイリアスがあります。\n\n```ts twoslash\ntype Wrapper<T> = {\n  value: T;\n};\n```\n\n単なる値をオブジェクト包んだだけですが、この`T`にユニオン型を代入してみると次のようになります。\n\n```ts twoslash\ntype Wrapper<T> = {\n  value: T;\n};\n\n// ---cut---\ntype IntOrStr = Wrapper<number | string>;\n//    ^?\n```\n\n予想通りの結果が出ますが、実はこれはユニオン分配によって`Wrapper<number> | Wrapper<string>`として評価されたあとの結果を示しています。\n\nただ、この例だけだと`Wrapper<number | string> = Wrapper<number> | Wrapper<string>`なのでいまいち理解が難しいかもしれませんが、Conditional Typesと併せて使うことによって、より複雑な型を作ることができます。\n\n## Distributive Conditional Types\n\n```ts twoslash\ntype IsString<T> = T extends string ? true : false;\n```\n\nこの型を使って`string`と`number`のユニオン型を持つ変数`T`に対して`IsString`を適用すると、次のようになります。\n\n```ts twoslash\ntype IsString<T> = T extends string ? true : false;\n// ---cut---\ntype A = IsString<string>;\n//   ^?\ntype B = IsString<number>;\n//   ^?\ntype C = IsString<string | number>;\n//   ^?\n```\n\n`IsString<T>`に`string`型を代入した型エイリアス`A`は`true`となります。一方`string`型以外の型を代入した型エイリアス`B`は`false`となります。\n\nそして`string | number`型を代入した型エイリアス`C`は`string | number`型としていっぺんに評価するのではなく、`string`型と`number`型が個別に評価されます。つまり`C`は`IsString<string> | IsString<number>`を評価していることと同じになり、結果として`true | false`が得られ`boolean`型となります。\n\nもし`string | number`型がユニオン分配されず`IsString`に適用されたとすると`string | number`型は`string`型の部分型ではないため、代入することができません。\n\n## ユニオン分配を起こさせない方法\n\nユニオン分配を意図的に起こさせない方法があります。方法は簡単で型変数を`[]`で囲むだけです。\n\n```ts twoslash\ntype NotDistribute<T> = [T] extends [string] ? true : false;\n```\n\nこの`NotDistribute`型は`string`型に対しては`true`を返しますが、`string | number`型に対しては`false`を返します。`string | number`型は`string`型の部分型ではないためです。\n\n```ts twoslash\ntype NotDistribute<T> = [T] extends [string] ? true : false;\n// ---cut---\ntype A = NotDistribute<string>;\n//   ^?\ntype B = NotDistribute<number>;\n//   ^?\ntype C = NotDistribute<string | number>;\n//   ^?\n```\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/union-distribution"
    },
    {
      "title": "typeof型演算子",
      "content": "# typeof型演算子\n\nTypeScriptの`typeof`は変数から型を抽出する型演算子です。次は、変数`point`に`typeof`型演算子を用いて、`Point`型を定義する例です。このPoint型は次のような型になります。\n\n```ts twoslash\nconst point = { x: 135, y: 35 };\ntype Point = typeof point;\n//   ^?\n```\n\nここで説明したのはTypeScriptのtypeof**型**演算子です。JavaScriptのtypeof演算子と同じ名前ですが、まったく別のものなので注意してください。\n\n[typeof演算子 (typeof operator)](../values-types-variables/typeof-operator.md)\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/typeof-type-operator"
    },
    {
      "title": "インデックスアクセス型 (indexed access types)",
      "content": "---\nsidebar_label: インデックスアクセス型\n---\n\n# インデックスアクセス型 (indexed access types)\n\nTypeScriptのインデックスアクセス型(indexed access type)は、プロパティの型や配列要素の型を参照する方法を提供します。\n\n```ts twoslash\ntype A = { foo: number };\ntype Foo = A[\"foo\"];\n//   ^?\n```\n\n## インデックスアクセス型の構文\n\nインデックスアクセス型は、型に対してブラケット表記法を使います。\n\n```ts\nオブジェクト型[\"プロパティ名\"];\n配列型[number];\n```\n\n## オブジェクトの型とインデックスアクセス型\n\nインデックスアクセス型には[ユニオン型](../values-types-variables/union.md)も使えます。\n\n```ts twoslash\ntype Person = { name: string; age: number };\ntype T = Person[\"name\" | \"age\"];\n//   ^?\n```\n\n[`keyof`型演算子](keyof-type-operator.md)と組み合わせると、オブジェクトの全プロパティの型がユニオン型で得られます。\n\n```ts twoslash\ntype Foo = { a: number; b: string; c: boolean };\ntype T = Foo[keyof Foo];\n//   ^?\n```\n\nもしもオブジェクトの型に存在しないプロパティ名を指定すると、コンパイラが警告を出します。\n\n```ts twoslash\n// @errors: 2339\ntype Account = { name: string };\ntype T = Account[\"password\"];\n```\n\n## 配列型とインデックスアクセス型\n\n[配列型](../values-types-variables/array/type-annotation-of-array.md)の要素の型を参照するのにもインデックスアクセス型が使えます。要素の型を参照するには、配列型に`[number]`をつけます。\n\n```ts twoslash\ntype StringArray = string[];\ntype T = StringArray[number];\n//   ^?\n```\n\n要素がユニオン型の配列型に対しても使えます。\n\n```ts twoslash\ntype MixedArray = (string | undefined)[];\ntype T = MixedArray[number];\n//   ^?\n```\n\n[`typeof`型演算子](typeof-type-operator.md)と組み合わせると、配列の値から要素の型を導くこともできます。\n\n```ts twoslash\nconst array = [null, \"a\", \"b\"];\ntype T = (typeof array)[number];\n//   ^?\n```\n\n## タプル型とインデックスアクセス型\n\nインデックスアクセス型は[タプル型](../values-types-variables/tuple.md)の要素の型を参照するのにも使えます。タプル型の要素の型を参照するには、ブラケット記法に[数値リテラル型](../values-types-variables/literal-types.md)を書きます。\n\n```ts twoslash\ntype Tuple = [string, number];\ntype T = Tuple[0];\n//   ^?\n```\n\n[`typeof`型演算子](typeof-type-operator.md)と組み合わせると、タプル型の値から要素の型を導くこともできます。\n\n```ts twoslash\nconst stateList = [\"open\", \"closed\"] as const;\ntype State = (typeof stateList)[number];\n//   ^?\n```\n\n<PostILearned>\n\nTypeScriptのインデックスアクセス型は、プロパティや配列要素の型を参照できる\n\n✏️構文1: オブジェクトの型[\"プロパティ名\"]\n✏️構文2: 配列型[number]\n🔑keyofと組み合わせると全プロパティの型が取れる\n🧲typeofと組み合わせると配列値から要素型が取れる\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/type-reuse/indexed-access-types"
    },
    {
      "title": "JSXとECMAScriptの違い",
      "content": "---\ntitle: JSX\nslug: /reference/jsx\n---\n\nJSX（JavaScript XML）は、コンポーネント指向のJavaScriptライブラリやフレームワーク（特にReact）で一般的に採用されている、JavaScriptの拡張構文です。JSXを用いると、JavaScriptのコード内にHTMLタグのような構文が埋め込み可能となり、より直感的かつ読みやすい形でUIのコードを表現することができます。それによって、開発者のコーディング体験や開発、デバッグの効率が上がります。\n\n## JSXとECMAScriptの違い\n\nJavaScriptの文法はECMAScriptという言語仕様で規定されています。一方、JSXはJavaScriptの構文を独自に拡張した言語です。そのため、JSXはECMAScriptの言語仕様に盛り込まれていません。ブラウザがJavaScriptエンジンを実装する場合は、ECMAScript(標準)に準拠するため、ブラウザで直接JSXを解釈し、実行することができない現状があります。この問題を解消するためには、JSXをブラウザが認識できるJavaScriptに変換する、いわゆるトランスパイルという過程が必要となります。このトランスパイル作業を助けるツールとして、BabelやTypeScriptコンパイラーが使われます。\n\n## JSX構文とHTML構文の違い\n\n初見では異なると気づきにくいかもしれませんが、実はJSXとHTMLはまったく同じではありません。構文のレベルにおいてJSXとHTMLの間には複数の違いが存在します。一例を挙げると、属性名の表記方法や、スタイルの指定方法、自己終了タグの書き方などが異なります。これらの詳細については後程の「属性」セクションでより詳しく説明します。覚えておくべき重要なポイントとしては、JSXがHTMLとJavaScriptのハイブリッドであるため、両者の規則や慣例を調和させる形で設計されているという点です。\n\n## JSX構文\n\n### 要素\n\nJSXでもっとも一般的な形式は、ネスト可能な要素（タグ）を使ってコンポーネントを表現するものです。\n\n```tsx twoslash\nconst element = <br />;\n// 描画結果: <br/>\n```\n\n### 入れ子の要素\n\nJSX要素はHTMLのようにネストすることができます。たとえば、`div`要素内に2つの`br`要素がネストされている状況を考えてみましょう。\n\n```tsx twoslash\nconst element = (\n  <div>\n    <br />\n    <br />\n  </div>\n);\n// 描画結果: <div><br/><br/></div>\n```\n\nこれらは簡単な例ですが、属性や子要素を追加してより複雑なコンポーネントを表現することも可能です。\n\n### テキスト要素\n\nJSX内では、要素に直接テキストを書くことができます。\n\n```tsx twoslash\nconst element = <h1>I'm a text element.</h1>;\n// 描画結果: <h1>I&#x27;m a text element.</h1>\n```\n\n上記のように、要素の中に直接テキストを書くと、そのテキストはそのままの形で出力されます。\n\n#### 空白と要素\n\nJSXでは、要素間のスペースは自動的に無視されます。たとえば、\n\n<!--prettier-ignore-->\n```tsx twoslash\nconst element = (\n  <p>\n    This is a\n    <strong>pen</strong>\n    .\n  </p>\n);\n// 描画結果: <p>This is a<strong>pen</strong>.</p>\n```\n\n上記のコードは「This is a**pen**.」として「a」と「pen」の分かち書きがない状態でレンダリングされてしまいます。\n\nこれを回避するには、文字列をJavaScriptの式として書くことです。\n\n<!--prettier-ignore-->\n```tsx twoslash\nconst element = (\n  <p>\n    This is a{\" \"}\n    <strong>pen</strong>\n    .\n  </p>\n);\n// 描画結果: <p>This is a<!-- --> <strong>pen</strong>.</p>\n```\n\nこうすると、正しく「This is a pen.」としてレンダリングされます。\n\n### 属性\n\nJSX属性の名前は、JavaScriptの命名規則に従いcamelCaseで記述することが推奨されています。この命名規則は、HTML内のアトリビュートとは異なる点に注意が必要です。\n\n### 標準HTML属性\n\nJSXでは、HTML属性と同じように要素に属性を与えることができます。\n\n```tsx twoslash\nconst element1 = <img src=\"image.jpg\" alt=\"A beautiful scene\" />;\nconst element2 = <a href=\"http://example.com\">Visit our website</a>;\n```\n\nただし、`class`属性はJavaScriptの予約語であるため、代わりに`className`を使用します。たとえば、次のコードでは`h1`要素に`className`属性を適用しています。\n\n```tsx twoslash\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n// 描画結果: <h1 class='greeting'>Hello, world!</h1>\n```\n\nJSXで用いる属性は、JavaScriptのDOMのプロパティ名です。したがって、いくつかのHTML属性はJSXでは異なる名前を持ちます。次の表は、いくつかの一般的なHTML属性と対応するJSX属性名を示しています。\n\n| HTML          | JSX           |\n| ------------- | ------------- |\n| `class`       | `className`   |\n| `tabindex`    | `tabIndex`    |\n| `for`         | `htmlFor`     |\n| `colspan`     | `colSpan`     |\n| `maxlength`   | `maxLength`   |\n| `cellpadding` | `cellPadding` |\n| `cellspacing` | `cellSpacing` |\n| `rowspan`     | `rowSpan`     |\n\n### スタイル属性\n\nHTMLでは、スタイル属性は一般的に文字列です。\n\n```html\n<div style=\"background-color: yellow; color: blue;\">Hello!</div>\n```\n\n一方、JSXではスタイル属性はオブジェクトでなければなりません。\n\n```jsx\n<div style={{ backgroundColor: \"yellow\", color: \"blue\" }}>Hello!</div>;\n// 描画結果: <div style='background-color:yellow;color:blue'>Hello!</div>\n```\n\n### 真偽属性\n\n真偽属性は要素に特定の特性を指定します。たとえば、input要素には\"disabled\"というboolean型の属性があり、その値に真を指定するとinput要素は無効になります。\n\n```tsx twoslash\nconst element = <input disabled />;\n// 描画結果: <input disabled=''/>\n```\n\n属性の値として`{true}`を付けて明示的に指定することもできます。\n\n```tsx twoslash\nconst element = <input disabled={true} />;\n// 描画結果: <input disabled=''/>\n```\n\nしかし、一般的には属性値がtrueの場合、値の部分を省略することが推奨されます。このように記述すると、コードが短くシンプルになるためです。したがって、上記の例のように属性名のみを指定することで、その属性を有効にすることができます。\n\n### 式\n\nJSX内ではJavaScriptの式を埋め込むことが可能です。これにより、動的な値をJSX内に簡単に導入することができます。\n\n### 基本的な式\n\nJavaScriptの式をJSX内部に埋め込むためには、波カッコ`{}`を使います。次の例では、変数`name`の値を`<h1>`要素内に埋め込んでいます。\n\n```tsx twoslash\nconst name = \"Josh Perez\";\nconst greeting = <h1>Hello, {name}</h1>;\n// 描画結果: <h1>Hello, <!-- -->Josh Perez</h1>\n```\n\nここでは、JavaScriptの変数を埋め込んでいますが、式としての評価結果が挿入されるので、JavaScriptの演算やメソッドの呼び出しも可能です。\n\n```tsx twoslash\nconst a = 10;\nconst b = 20;\nconst sum = <h1>{a + b}</h1>;\n// 描画結果: <h1>30</h1>\n\nconst name = \"Josh Perez\";\nconst greeting = <h1>Hello, {name.toUpperCase()}</h1>;\n// 描画結果: <h1>Hello, <!-- -->JOSH PEREZ</h1>\n```\n\n### 条件式\n\nJavaScriptのif文は式ではなく文であるため、JSXの式の中に直接書くことはできません。条件式が必要な場合には三項演算子を用います。\n\n```tsx twoslash\nconst isUser = true;\nconst greeting = isUser ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>;\n```\n\nこのように、三項演算子`条件式 ? 真の場合の値 : 偽の場合の値`を使うことで、JSX内で条件によって表示を切り替えることが可能です。\n\n### 短絡評価\n\nJavaScriptの論理演算子を使用して、短絡評価を行うことも可能です。これを使用すると、特定の条件下でのみ要素を表示したり、デフォルトの値を提供したりします。\n\n### 論理AND演算子(`&&`)による短絡評価\n\n論理AND演算子`&&`は、最初の要素が`false`またはfalsyな値（`false`、`null`、`undefined`、`\"\"`、`0`、`NaN`）の場合その値をそのまま返し、それ以外の場合には2番目の値を返します。\n\n```tsx twoslash\ndeclare const isLoggedIn: boolean;\n// ---cut---\nconst message = isLoggedIn && <h1>Welcome back!</h1>;\n```\n\nこの例では、`isLoggedIn`がtruthyの場合にのみ、`<h1>Welcome back!</h1>`が表示されます。\n\n### 論理OR演算子(`||`)による短絡評価\n\n論理OR演算子 `||`は、最初のオペランドがtruthyな値の場合にその値をそのまま返し、それ以外の場合には2番目の値を返します。\n\n```tsx twoslash\ndeclare const isLoggedIn: boolean;\n// ---cut---\nconst message = isLoggedIn || <h1>Please sign up.</h1>;\n```\n\nこの例では、`isLoggedIn`がfalsyな値（`undefined`、`null`、`\"\"`、`0`、`NaN`）の場合にのみ、`<h1>Please sign up.</h1>`が表示されます。\n\n### Null合体演算子(`??`)による短絡評価\n\nNull合体演算子(nullish coalescing operator)`??`は、最初のオペランドが`null`または`undefined`の場合にのみ2番目の値を返します。そのため、最初のオペランドが`false`、`0`、`NaN`、空文字列であっても、その値が保持されます。\n\n```tsx twoslash\ndeclare const input: { name?: string };\n// ---cut---\nconst message = input.name ?? <p>No input provided.</p>;\n```\n\nこの例では、`input.name`が`null`または`undefined`の場合にのみ、`<p>No input provided.</p>`が表示されます。\n\n### ループ(反復処理)\n\nJavaScriptの`for-of`ループなど、JSX内では文を直接使用することができないため、配列の反復処理を行う際は`Array.prototype.map`関数のような式を使用します。式とは、値を返すコードの片段のことで、それに対して文は値を生成しません。JSXは基本的には式ベースのシンタックスですので、式が使われます。\n\n`Array.prototype.map`関数は配列の各要素に対して関数を適用し、その結果で新たな配列を作成します。これを利用して、一連の要素を作ることができます。次にサンプルコードを示します。\n\n```tsx twoslash\nconst numbers = [1, 2, 3];\nconst list = (\n  <ul>\n    {numbers.map((number) => (\n      <li key={number.toString()}>{number}</li>\n    ))}\n  </ul>\n);\n// 描画結果: <ul><li>1</li><li>2</li><li>3</li></ul>\n```\n\nこの例では、`numbers`という配列の各要素に対して関数が適用され、その結果から新たな`<li>`要素で構成された配列が作成されます。そして、その配列は`<ul>`要素に展開され`list`に代入されます。\n\nまた、Reactでは配列内の要素に一意な`key`プロパティを追加することが推奨されます。これは、ReactがDOMの変更を効率的に追跡するために使用されます。上記の例では、`key`として数値を文字列に変換したものを使用しています。\n\n### 自己終了タグ\n\nJSXでは、XMLのように自己終了タグ(self-closing tags)が使用できます。これは、開始タグと終了タグの間に何も内容を持たない要素について使用します。\n\n```tsx twoslash\nconst element = <img src=\"myImage.jpg\" alt=\"\" />;\n```\n\nその要素が内容を持たない場合でも、`<img></img>`のように書くことは文法的には可能です。しかし、一般的には`<img />`のように自己終了タグを書くことが推奨されます。これは可読性の観点から、タグが内容を持たないことを明示するためです。\n\n### フラグメント\n\n一般的にJSX要素は、ひとつの親要素内にすべての子要素をネストしなければなりません。これは、JSXが最終的にひとつのルートノードを返すことを要求するためです。しかし、この要求はしばしばReactのDOM構造に余計な要素を追加することを強制してしまいます。これを解決するためにReactが提供する機能が「フラグメント」です。\n\nフラグメントを使うと、ひとつの親要素なしに、複数の要素を同時に返すことができます。これにより、無駄なDOMノードの生成を防ぎつつ、構造をくずさずに複数の要素をレンダリングすることができます。\n\n### JSXでのフラグメントの使用\n\nフラグメントは`<React.Fragment>`タグを使って明示的に表現することができます。次の例では、`h1`と`h2`要素がフラグメント内にまとめられています。\n\n```tsx twoslash\nconst element = (\n  <React.Fragment>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </React.Fragment>\n);\n// 描画結果: <h1>Hello!</h1><h2>Good to see you here.</h2>\n```\n\nただ、より簡潔にフラグメントを表現するために`<>...</>`というショートハンド（短縮形）がよく使われます。次の例では、`<React.Fragment>`タグが`<>...</>`に置き換えられています。\n\n```tsx twoslash\nconst element = (\n  <>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </>\n);\n// 描画結果: <h1>Hello!</h1><h2>Good to see you here.</h2>\n```\n\nいずれの形式でも、フラグメントを使うことで`h1`と`h2`要素は同一階層に配置され、それらをラップする余計なHTML要素を追加せずにレンダリングされます。フラグメントは、Reactアプリケーションのレンダリングパフォーマンスを持続的に向上させるツールとなります。\n\n### JSX内のコメント\n\nコメントはコードの読み易さを向上させる重要な要素です。しかし、JSX内のコメントは少し特殊で、明示的にJavaScriptのブロック、つまり波カッコ `{}` 内に書く必要があります。\n\n### 一行コメント\n\nJSX内では一行コメントを書く方法は次の通りです。\n\n```tsx twoslash\nconst element = <div>{/* This is a comment */}</div>;\n// 描画結果: <div></div>\n```\n\nこのように、コメントは `{/* */}` の形式で書かれます。この書き方により、コメントはブラウザに表示されず、ただ開発者を支援するために存在します。\n\n### ジェネリクス\n\nジェネリクスを活用することで、一度定義したコンポーネントや関数を、各種の型に対応可能な形で再利用できます。ここではジェネリクス型を用いたReactコンポーネントの定義とその利用について、詳しく見ていきましょう。\n\n[ジェネリクス](../generics/README.md)\n\n### ジェネリックコンポーネントの定義\n\nまず初めに、型変数`T`を用いたコンポーネントを定義します。ここでは`ItemType`という名前で型を作り、それがプロパティ`prop`を介して型`T`を受け取るように設計します。\n\n```tsx twoslash\ntype ItemType<T> = {\n  prop: T;\n};\n\nconst Item = <T,>({ prop }: ItemType<T>) => <>{prop}</>;\n```\n\n上記の`Item`という名前のコンポーネントには、ジェネリクス型を適用しています。そのため、あらゆる型を`prop`として受け取ることが可能になります。\n\n注目すべき点として、`<T>`の書き方について説明します。もしジェネリクスとして `<T>`だけを記述する場合、TypeScriptはそれがJSXのタグと混同してしまう可能性があります。これは、TypeScriptのパーサーが `<T>`と読み取ったとき、それがジェネリクス開始を示すものなのかJSX要素の開始を示すものなのかを特定するのが難しいためです。この混同を避けるためには、ジェネリクスの開始を示す `<T>`に `,`を追加し、`<T,>`と記述する必要があります。\n\n### ジェネリックコンポーネントの利用\n\nここで、上記で定義したジェネリクス型のコンポーネントを利用してみます。\n\n```tsx twoslash\n// @errors: 2322\ntype ItemType<T> = {\n  prop: T;\n};\nconst Item = <T,>({ prop }: ItemType<T>) => <>{prop}</>;\n// ---cut---\nconst item1 = <Item<string> prop=\"a\" />; // OK\nconst item2 = <Item<number> prop=\"a\" />; // Error\n```\n\n`Item`コンポーネントに対して`string`という型引数を渡し、その`prop`プロパティとして`a`という文字列値を渡しています。これは問題ありません。しかし、次の行では、`Item`コンポーネントに対して`number`という型引数を渡しているのに、その`prop`プロパティとして`a`という文字列値を渡しています。これにより、TypeScriptは型エラーを発生させます。これで、型安全性が確保されていることが確認できます。\n\n## JSXのベストプラクティス\n\nJSXにおけるベストプラクティスは、効果的で読みやすいコードを書くために役立ちます。次にいくつかの主要なベストプラクティスを示します。\n\n### コンポーネント名は常に大文字ではじめる\n\nReactは小文字で始まるコンポーネントをDOMタグとして認識します。したがって、コンポーネント名は常に大文字ではじめることを推奨します。\n\n```tsx twoslash\n// Good\nconst MyComponent = () => {\n  return <div />;\n};\n\n// Bad\nconst myComponent = () => {\n  return <div />;\n};\n```\n\n### マルチラインのJSXはカッコで囲む\n\n複数行に渡るJSXは可読性を上げるためにカッコで囲むことを推奨します。\n\n```tsx {3-7,12-14} twoslash\n// Good\nconst Good = () => {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n    </div>\n  );\n};\n\n// Bad\nconst Bad = () => {\n  // prettier-ignore\n  return <div>\n    <h1>Hello, world!</h1>\n  </div>;\n};\n```\n\n### 自己終了タグを利用する\n\n通常、JSX要素は開始タグと終了タグの間に子要素を配置して記述します。しかし内容が空の場合、すなわち子要素を持たない場合、自己終了タグという短縮形を使用することができます。自己終了タグでは、開始タグと終了タグをひとつのタグにまとめることができます。\n\n次の2つの表現は同等です：\n\n```tsx twoslash\n// 長いバージョン\nconst a = <input></input>;\n// 短いバージョン（自己終了タグ）\nconst b = <input />;\n```\n\n前者の例では、`<input></input>`という形で開始タグと終了タグを明示的に記述しています。一方、後者の例では、`<input />`という形で開始タグと終了タグをひとつにまとめた自己終了タグを利用しています。どちらの記述も完全に同じ動作をしますが、後者の形が簡潔であり一般的に好まれます。\n\n### `true`の場合は真偽属性を省略する\n\nJSXでは、属性の値が`true`の場合、その属性名だけ記述することで属性の値を省略することが可能です。この書き方を真偽属性と呼びます。\n\n次の2つの表現は同等です：\n\n```tsx twoslash\n// 長いバージョン\nconst a = <input required={true} />;\n// 短いバージョン（真偽属性）\nconst b = <input required />;\n```\n\n前者の例では、`required`という属性に対して`{true}`（即ち真）を明示的に設定しています。一方、後者の例では、属性が真であることを示すために`required`という属性名だけを記述しています。どちらの記述も完全に同じ動作をしますが、後者の形が簡潔であり一般的に好まれます。\n\n### マップ関数内で一意の`key`プロパティを使用する\n\n`map`関数を使用してリストを作成する際には、各要素に一意の`key`プロパティを付与することを推奨します。これによりReactは変更、追加、削除を効率的に適用できます。\n\n```tsx twoslash\ndeclare const numbers: number[];\n// ---cut---\nconst listItems = numbers.map((number) => (\n  <li key={number.toString()}>{number}</li>\n));\n```\n\n## JSXとコンパイル\n\nJSXはJavaScriptの一部ではないため、ブラウザで直接実行することはできません。デフォルトでは、JSX構文はJavaScript構文にないものであり、そのまま実行してもブラウザは理解できません。そのため、JSXをJavaScriptにコンパイル（または変換）する必要があります。\n\nTypeScriptでは、こうしたJSXのコンパイル方法を指定するために、\"jsx\"という名前のフラグを `tsconfig.json` 内で設定します。このフラグには次の5つの値を設定することができます。\n\n1. \"react\"：この設定を選択すると、JSXはJavaScriptへと変換されます。そして、出力される.jsファイルでは、それぞれのJSX要素は対応する`React.createElement`呼び出しに変換されます。これはReactというライブラリが、JSXをどのように標準的なJavaScriptに変換するかを指定しています。\n2. \"react-jsx\"：元のJSX要素は`_jsx`呼び出しに変換され、出力された.jsファイルに含まれます。これにより、ある程度のパフォーマンスの向上が期待できます。\n3. \"react-jsxdev\"：こちらも元のJSX要素は`_jsx`呼び出しに変換されますが、このモードは開発環境でのみ使用することを目的としています。ここで生成される`_jsxの`呼び出しは、開発中のデバッグを容易にするような追加のランタイムチェックを含みます。\n4. \"preserve\"：このモードはJSXをそのままの形で出力ファイルに残します。つまり、元のJSX構文は変更されず、出力されるファイル拡張子は.jsxであることが期待されます。さらなる変換ステップ（たとえばBabel等のトランスパイラ）のためにJSXをそのまま保持する必要がある場合に使用します。\n5. \"react-native\"：このオプションもJSXをそのままの形で出力します。ただし、出力するファイル拡張子は.jsのままであることが期待されます。これは主にReact Nativeの開発環境で使用されます。\n\n上記の設定により、JSXの構文をどのようにJavaScriptにコンパイルするかを制御できます。そして、TypeScriptとJSXを一緒に使う際には、これらの設定が不可欠となります。\n\nそれぞれのフラグでどのようにコンパイルされるのか、次のサンプルコードのコンパイル結果を見てみましょう。\n\n```tsx twoslash title=\"コンパイル前のTypeScript\"\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n\n```tsx twoslash title=\"reactのコンパイル結果(JavaScriptコード)\"\n// @jsx: react\n// @showEmit\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n\n```tsx twoslash title=\"react-jsxのコンパイル結果(JavaScriptコード)\"\n// @jsx: react-jsx\n// @showEmit\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n\n```tsx twoslash title=\"react-jsxdevのコンパイル結果(JavaScriptコード)\"\n// @jsx: react-jsxdev\n// @showEmit\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n\n```tsx twoslash title=\"preserveのコンパイル結果(JavaScriptコード)\"\n// @jsx: preserve\n// @showEmit\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n\n```tsx twoslash title=\"react-nativeのコンパイル結果(JavaScriptコード)\"\n// @jsx: react-native\n// @showEmit\nconst HelloWorld = () => <h1>Hello world</h1>;\n```\n",
      "url": "https://typescriptbook.jp/reference/jsx/README"
    },
    {
      "title": "Errorオブジェクトの作り方",
      "content": "---\ntitle: Error\n---\n\n`Error`はJavaScriptの組み込みAPIのひとつで例外を取り扱うためのオブジェクトです。\n\n## Errorオブジェクトの作り方\n\n`Error`オブジェクトを作るには`Error`クラスを`new`します。例外を投げるためには`throw`を使います。\n\n```ts twoslash\nthrow new Error();\n```\n\n## JavaScriptではErrorクラス以外も例外としてthrowできる\n\nとはいえ、JavaScriptでは例外を表す`Error`クラスとそのサブクラスだけを`throw`できるのではなく、どのような値も`throw`できます。\n\n```ts twoslash\nthrow \"id is not string!\";\n```\n\n## Errorクラスのサブクラス\n\n組み込みAPIとして`Error`には次のサブクラスがあります。\n\n- EvalError\n- InternalError\n- RangeError\n- ReferenceError\n- SyntaxError\n- TypeError\n- URIError\n\nまた`Error`を拡張し独自のサブクラスを定義することもできます。\n\n```ts twoslash\nclass CustomeError extends Error {\n  public constructor(message?: string) {\n    super(message);\n  }\n}\n\nconst err: CustomeError = new CustomeError(\"FAILED!\");\n\nconsole.log(err.name);\n// @log: \"Error\"\nconsole.log(err.message);\n// @log: \"FAILED!\"\nconsole.log(err.stack);\n// @log: \"Error: FAILED! ...\"\n```\n\n## 例外を捕捉する\n\n`throw`された例外は`catch`で捕捉できます。ですが先ほど述べたようにJavaScriptはどのような値も`throw`できるので`catch`した値の型は定まらず`any`型か`unknown`型として解釈されます。どちらの型になるかはtsconfig.jsonの`useUnknownInCatchVariables`の設定により決まります。\n\n[useunknownincatchvariables](../tsconfig/useunknownincatchvariables.md)\n\nもし捕捉した値があるクラスのインスタンスまたはある型であるかを判定したい場合は`instanceof`, `keyof`あるいは型ガードを使います。\n\n```ts twoslash\ntry {\n  // ...\n} catch (e) {\n  if (e instanceof Error) {\n    // ...\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/builtin-api/error"
    },
    {
      "title": "はじめに、Dateオブジェクトについて",
      "content": "---\ntitle: Date\n---\n\nDateは時刻のためのJavaScriptの読み込みクラスです。DateオブジェクトはUTC(協定世界時)の1970/01/01からの経過ミリ秒を表す数値を含んでいます。\n\n## はじめに、Dateオブジェクトについて\n\nJavaScriptの組み込み`Date`オブジェクトの使用にはいくつかの注意が必要です。次に、主な問題点を挙げます。\n\n1. **非直感的な動作**: `Date`オブジェクトは、常識的には存在しない日付を解析しようとすると自己補正を試みます。たとえば、存在しない日付である2月30日を`Date`オブジェクトとして表現しようとすると、JavaScriptはこれを3月1日に補正します。これは読み手に混乱をもたらし、予期しない結果を生む可能性があります。\n2. **フォーマットが手間**: `Date`オブジェクトを特定のフォーマットで表示するためには、しばしば独自のフォーマット関数を作成する必要があります。これは手間がかかるだけでなく、バグの原因ともなり得ます。\n3. **タイムゾーンの扱い**: JavaScriptの`Date`オブジェクトは、常にローカルタイムゾーンで時間を表示します。しかし、ユーザーが世界中のさまざまな時間帯に分散している場合、これは非常に混乱を招きます。\n\n以上のような問題を解決するために、`date-fns`や`Day.js`のようなサードパーティのライブラリの使用を推奨します。これらのライブラリは、シンプルで一貫したAPIと豊富な日付操作関数を提供し、タイムゾーンの問題を適切に処理します。また、日付を表示するための多くのフォーマットオプションも提供します。\n\nしたがって、シンプルなタスクにはJavaScriptの組み込み`Date`オブジェクトが適していますが、より複雑な日付や時間の操作が必要な場合は、適切なサードパーティのライブラリを選択することを検討してください。これにより、日付と時間に関連する操作がより確実で効率的になります。\n\n### サードパティーの日付ライブラリ\n\n#### [date-fns](https://date-fns.org/)\n\nオブジェクトというよりは関数として日付の操作をします。直接Dateオブジェクトを操作する上での煩わしい点をカバーします。\n\n#### [Day.js](https://day.js.org/)\n\n軽量な日付操作のためのオブジェクトを提供します。後述するMoment.jsとAPIに互換性があり、Moment.jsを使っているプロジェクトでの乗り換え先に検討されることがあります。\n\n#### [Moment.js](https://momentjs.com/)\n\n日付操作のためのパッケージとして絶大な知名度がありますが現在は新規開発は行われておらず、積極的に新規プロジェクトで導入する必要はありません。\n\n## Dateの操作\n\n### 年を取得する - `Date.prototype.getFullYear()`\n\n年を取得します。誤って`Date.prototype.getYear()`を使用しないでください。\n\n### 年の下2-3桁を取得する - `Date.prototype.getYear()`\n\n**非推奨です**。与えられた日付の年数を表す数値から1900を引いた値を返します。代わりに`Date.prototype.getFullYear()`を使ってください。\n\n### 月を取得する - `Date.prototype.getMonth()`\n\n月を取得しますが、0-11を返すため実際の月にするためには1を加算してください。\n\n### 日を取得する - `Date.prototype.getDate()`\n\n日を取得します。誤って`Date.prototype.getDay()`を使用しないでください。\n\n### 曜日を取得する - `Date.prototype.getDay()`\n\n曜日を取得します。0-6を返します。０が日曜日、1が月曜日のようになっています。\n\n### 時を取得する - `Date.prototype.getHours()`\n\n時を取得します。\n\n### 分を取得する - `Date.prototype.getMinutes()`\n\n分を取得します。\n\n### 秒を取得する - `Date.prototype.getSeconds()`\n\n秒を取得します。\n\n### ミリ秒を取得する - `Date.prototype.getMilliseconds()`\n\nミリ秒を取得します。\n\n### UTC 1970/01/01 00:00:00からの経過ミリ秒を取得する - `Date.prototype.getTime()`\n\n協定世界時の1970/01/01 00:00:00からの経過ミリ秒単位の数値で返します。\n\n### ISO8601に準じた文字列に変換する - `Date.prototype.toJSON()`\n\nISO8601に準じた文字列を返します。ISO8601は`YYYY-MM-DDThh:mm:ss.sssZ`の形式です。\n\n## コラム: Dateの問題点の由来\n\nDateの設計はとてもプリミティブであるため、yyyy年m月d日のような一般的な日付書式への変換には少なくないコードが必要です。\n\n```ts twoslash title=\"Dateの日付フォーマット処理\"\nconst d = new Date();\nconst year = d.getFullYear();\nconst month = d.getMonth() + 1;\nconst day = d.getDate();\nconsole.log(`${year}年${month}月${day}日`);\n```\n\n他にもDateにはタイムゾーンの具体的な識別（例：'America/Los_Angeles'）や、タイムゾーンの変換に便利なメソッドがありません。使い勝手の悪さから、[Moment.js](https://momentjs.com/)や[date-fns](https://date-fns.org/)といったサードパーティの日付ライブラリにお世話になった人も多いのではないでしょうか。あまりの不評もあって、[Temporal](https://tc39.es/proposal-temporal/docs/ja/index.html)というモダンな日付ビルトインAPIも検討されはじめています。\n\nところで、Dateはどうしてこのような微妙な実装になっているのでしょうか。これには歴史が関係します。JavaScriptを実装するのにブレンダン・アイク氏に与えられたのは、わずか10日だったそうです。この工期には日付処理の実装も含まれていました。日付処理は複雑でフルスクラッチで作ったら時間がかかるものです。工期短縮のため、実装は当時のJavaの`java.util.Date`から移植されることになりました[^1]。\n\n[^1]: https://maggiepint.com/2017/04/09/fixing-javascript-date-getting-started/\n\nJavaの日付処理を知っている人なら「Java由来なら、どうしてこんなひどい実装になったんだ！？」と思われるかもしれません。今のJavaの日付処理はとても立派なものです。実は、当時のJavaの`java.util.Date`は今のJavaの日付処理とは、全然異なるものだったのです。それは評判の良くないものだったそうです。\n\n当時の[Java(1.0系)の`java.util.Date`のドキュメント](http://web.mit.edu/java_v1.0.2/www/javadoc/java.util.Date.html)。見てみると、たしかにJavaScriptのDateとインターフェースがそっくりです。移植されたというのが、ここからも垣間見えます。\n\n![Java(1.0系)のjava.util.Dateのリファレンスには、JavaScriptのDateと似たようなインターフェイスが並ぶ](date/java-date.png)\n\nあまりにもそっくり移植されてしまったため、[2000年問題]のバグまで引き継いでしまったそうです[^2]。\n\n[2000年問題]: https://ja.wikipedia.org/wiki/2000%E5%B9%B4%E5%95%8F%E9%A1%8C\n\n![2000年問題の「バグ」をjava.util.Dateから引き継いだと指摘するMozillaによるスライド](date/mozilla-slide.png)\n\n[^2]: https://www.mozilla.org/js/language/ICFP-Keynote.ppt\n\n```js twoslash title=\"2000年問題のバグ\"\nconsole.log(new Date(1999, 3, 1).getYear());\n// @log: 99\nconsole.log(new Date(2000, 3, 1).getYear());\n// @log: 100\n```\n\nバグと言いましたが、今となっては[仕様になっています](https://tc39.es/ecma262/#sec-date.prototype.getyear)。\n\nJavaでは1.0の`java.util.Date`が良くなかったため、Java 1.1のリリースですぐに非推奨になり、新しい日付処理に置き換えられていきました。その結果、Javaの日付ライブラリは十分に使いやすいものになっています。Javaを真似したJavaScriptはその後どうなったかというと、20年以上Dateはそのままです。\n",
      "url": "https://typescriptbook.jp/reference/builtin-api/date"
    },
    {
      "title": "Setオブジェクトの作り方",
      "content": "---\ntitle: Set<T>\n---\n\n`Set`はJavaScriptの組み込みAPIのひとつで、値のコレクションを扱うためのオブジェクトです。`Set`には重複する値が格納できません。`Set`に格納された値は一意(unique)になります。\n\n## Setオブジェクトの作り方\n\n`Set`オブジェクトを新たに作るには、`Set`クラスを`new`します。コンストラクタに配列を渡すと、値が`Set`に格納されます。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nconsole.log(fruits);\n// @log: Set { 'apple', 'orange', 'banana' }\n```\n\nコンストラクタに渡す配列の中に重複がある場合、重複した値は取り除かれます。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"apple\", \"apple\"]);\nconsole.log(fruits);\n// @log: Set { 'apple' }\n```\n\nコンストラクタ引数を省略した場合、空の`Set`オブジェクトが作られます。\n\n```ts twoslash\nconst fruits = new Set();\nconsole.log(fruits);\n// @log: Set {}\n```\n\n空の`Set`オブジェクトのTypeScript上の型は`Set<unknown>`になります。これでは後から`Set`に値を追加できないので、空の`Set`を作るときは、`Set`の型変数を指定する必要があります。\n\n```ts\nconst fruits = new Set<string>();\n//                    ^^^^^^^^ 型変数を指定\n```\n\n## Setの型注釈\n\nTypeScriptで`Set`の型注釈をする場合は、`Set<string>`のようにSet要素の型を型変数に指定します。\n\n```ts twoslash\nfunction doSomething(strings: Set<string>) {\n  // ...\n}\n```\n\n## Setの操作\n\n### 値を追加する - `Set.prototype.add()`\n\n`Set`に値を追加するには`add`メソッドを用います。同じ値は何度追加しても増えないようになっています。\n\n```ts twoslash\nconst fruits = new Set<string>();\nfruits.add(\"apple\");\nfruits.add(\"apple\");\nconsole.log(fruits);\n// @log: Set (1) {\"apple\"}\n```\n\n追加した値は最後に足されます。すでに存在する値は、追加されず順番は変わりません。\n\n```ts twoslash\nconst numbers = new Set<number>();\nnumbers.add(1).add(2).add(3);\nnumbers.add(1);\nconsole.log(numbers);\n// @log: Set (3) {1, 2, 3}\n```\n\n### 値を削除する - `Set.prototype.delete()`\n\n`Set`から値を取り除くには、`delete`メソッドを使います。\n\n```ts twoslash\nconst numbers = new Set([1, 2, 3]);\nnumbers.delete(3);\nconsole.log(numbers);\n// @log: Set (2) {1, 2}\n```\n\n### 値の有無を確認する - `Set.prototype.has()`\n\n`Set`に値が存在するかどうかは`has`メソッドで調べられます。\n\n```ts twoslash\nconst numbers = new Set([1, 2, 3]);\nconsole.log(numbers.has(1));\n// @log: true\nconsole.log(numbers.has(999));\n// @log: false\n```\n\n### 値の個数を取得する - `Set.prototype.size()`\n\n`Set`にいくつ値が登録されているかを調べるには、`size`フィールドの値を見ます。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nconsole.log(fruits.size);\n// @log: 3\n```\n\n### Setを空っぽにする - `Set.prototype.clear()`\n\n`Set`に登録された値をすべて削除するには`clear`メソッドを使います。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nfruits.clear();\nconsole.log(fruits);\n// @log: Set (0) {}\n```\n\n### Setをループする\n\n`Set`オブジェクトはfor-of構文でループできます。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\n\nfor (const fruit of fruits) {\n  console.log(fruit); // \"apple\"、\"orange\"、\"banana\"の順で出力される\n}\n```\n\n[for-of文 - 拡張for文](../statements/for-of.md)\n\n### Setを配列に変換する\n\n`Set`オブジェクトを配列に変換するには、スプレッド構文を用います。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nconst array = [...fruits];\nconsole.log(array);\n// @log: [\"apple\", \"orange\", \"banana\"]\n```\n\n[配列のスプレッド構文「...」(spread syntax)](../values-types-variables/array/spread-syntax-for-array.md)\n\n## Setは直接JSONにできない\n\n`Set`オブジェクトは`JSON.stringify`にかけても、`Set`に登録されている値はJSONになりません。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nconsole.log(JSON.stringify(fruits));\n// @log: \"{}\"\n```\n\nSetオブジェクトのデータをJSON化したい場合は、一度配列にするなどひと手間必要です。\n\n```ts twoslash\nconst fruits = new Set([\"apple\", \"orange\", \"banana\"]);\nconst array = [...fruits];\nconsole.log(JSON.stringify(array));\n// @log: [\"apple\",\"orange\",\"banana\"]\n```\n\n## レシピ\n\n### 配列から重複要素を取り除く\n\n「`Set`に渡した値は重複しない」という特性を使って、配列から値が重複する要素を取り除く処理に応用できます。\n\n```js twoslash\nconst array1 = [0, 0, 1, 1, 2, 2];\nconst array2 = [...new Set(array1)];\nconsole.log(array2);\n// @log: [ 0, 1, 2 ]\n```\n",
      "url": "https://typescriptbook.jp/reference/builtin-api/set"
    },
    {
      "title": "Mapオブジェクトの作り方",
      "content": "---\ntitle: Map<K, V>\n---\n\n`Map`はJavaScriptの組み込みAPIのひとつで、キーと値のペアを取り扱うためのオブジェクトです。`Map`にはひとつのキーについてはひとつの値のみを格納できます。\n\n## Mapオブジェクトの作り方\n\n`Map`オブジェクトを作るには`Map`クラスを`new`します。たとえば、キーが`string`、値が`number`の`Map<string, number>`は次のように作ります。\n\n```ts twoslash\nconst map = new Map<string, number>();\nmap.set(\"a\", 1);\nconsole.log(map.get(\"a\"));\n// @log: 1\n```\n\nコンストラクタにキーと値の[タプル型]`[K, V]`の配列`[K, V][]`を渡すと`Map<K, V>`オブジェクトが作られます。\n\n[タプル型](../values-types-variables/tuple.md)\n\n```ts twoslash\nconst map = new Map<string, number>([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconsole.log(map);\n// @log: Map (3) {\"a\" => 1, \"b\" => 2, \"c\" => 3}\n```\n\n`Map`の型変数を省略した場合、TypeScriptはコンストラクタ引数から`Map<K, V>`の型を推論します。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nmap;\n//^?\n```\n\nコンストラクタ引数を省略した場合、空の`Map`が作られます。\n\n```ts twoslash\nconst map = new Map<string, number>();\nconsole.log(map);\n// @log: Map(0) {}\n```\n\n型引数とコンストラクタ引数の両方を省略した場合、`Map<any, any>`型になります。\n\n```ts twoslash\nconst map = new Map();\n//    ^?\n```\n\n## Mapの型注釈\n\nTypeScriptでMapの型注釈をする場合は、`Map<string, number>`のようにMap要素の型を型変数に指定します。\n\n```ts twoslash\nfunction doSomething(map: Map<string, number>) {}\n```\n\n## Mapのキーは厳密等価で判定される\n\n`Map`のキーが同じかどうかは厳密等価(`===`)で判定します。等価(`==`)ではありません。\n\nたとえば、`null`と`undefined`は等価ですが、厳密等価では等しくありません。\n\n```ts twoslash\nconsole.log(null == undefined);\n// @log: true\nconsole.log(null === undefined);\n// @log: false\n```\n\nそのため、`Map`は`null`と`undefined`を異なるキーとみなします。\n\n```ts twoslash\nconst map = new Map<any, any>([[null, 1]]);\nconsole.log(map.has(null));\n// @log: true\nconsole.log(map.has(undefined));\n// @log: false\n```\n\n`NaN`同士は厳密等価ではありませんが、例外的に同じキーとみなされます。\n\n```js twoslash\n// JavaScript\n\nconsole.log(NaN === NaN);\n// @log: false\n```\n\n```ts twoslash\nconst map = new Map<number, number>();\nmap.set(NaN, 1);\nmap.set(NaN, 2);\nconsole.log(map);\n// @log: Map (1) {NaN => 2}\n```\n\nオブジェクトは等価でも厳密等価でもないため、別のキーとみなされます。\n\n```js twoslash\n// JavaScript\n\nconsole.log({} == {});\n// @log: false\nconsole.log({} === {});\n// @log: false\n// @noErrors\n```\n\n```ts twoslash\nconst map = new Map<object, number>();\nmap.set({}, 1);\nmap.set({}, 2);\nconsole.log(map);\n// @log: Map (2) {{} => 1, {} => 2}\n```\n\n## Mapの操作\n\n### 要素をセットする - `Map.prototype.set()`\n\n`Map`にキーと値のペアを追加するには`set`メソッドを使います。\n\n```ts twoslash\nconst map = new Map<string, number>();\nmap.set(\"a\", 1);\nconsole.log(map);\n// @log: Map (1) {\"a\" => 1}\n```\n\nすでにキーがある場合は、値を上書きします。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nmap.set(\"a\", 5);\nconsole.log(map);\n// @log: Map (1) {\"a\" => 5}\n```\n\n### 値を取得する - `Map.prototype.get()`\n\n`Map`からキーをもとに要素を取得するには`get`メソッドを使います。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconsole.log(map.get(\"a\"));\n// @log: 1\n```\n\n`get`メソッドは、キーが存在しない場合、`undefined`を返します。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconsole.log(map.get(\"b\"));\n// @log: undefined\n```\n\nNull合体演算子と組み合わせることによって`get`メソッドで値を取得できなかったときにデフォルトの値を代入することができます。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconsole.log(map.get(\"b\") ?? 2);\n// @log: 2\n```\n\n### 特定の要素を削除する - `Map.prototype.delete()`\n\n`Map`からキーを指定して要素を削除するには`delete`メソッドを使います。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n]);\nmap.delete(\"a\");\nconsole.log(map);\n// @log: Map (1) {\"b\" => 2}\n```\n\n`delete`の戻り値は、キーが存在した場合`true`、そうでない場合`false`になります。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconsole.log(map.delete(\"a\"));\n// @log: true\nconsole.log(map.delete(\"b\"));\n// @log: false\n```\n\n### キーの有無を確認する - `Map.prototype.has()`\n\n`Map`にキーが存在するかどうかを調べるには`has`メソッドを使います。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconsole.log(map.has(\"a\"));\n// @log: true\nconsole.log(map.has(\"b\"));\n// @log: false\n```\n\n:::tip 存在確認からの要素取得\n\n要素が存在するかを`has`チェックしてから、`get`で要素を取得するコードはTypeScriptではうまく書けません。\n\n```ts twoslash\n// @errors: 18048\nconst map = new Map([[\"a\", 1]]);\nif (map.has(\"a\")) {\n  // TypeScriptは\"a\"があることを認識しない\n  const n = map.get(\"a\");\n  n * 2;\n}\n```\n\nこの場合、`get`で値を取得して、その値が`undefined`でないことをチェックするとうまくいきます。\n\n```ts twoslash\nconst map = new Map([[\"a\", 1]]);\nconst n = map.get(\"a\");\nif (typeof n === \"number\") {\n  n * 2;\n}\n```\n\n:::\n\n### 要素の個数を取得する - `Map.prototype.size()`\n\n`Map`に登録されている要素数を調べるには`size`フィールドの値を見ます。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconsole.log(map.size);\n// @log: 3\n```\n\n### 全要素を削除する - `Map.prototype.clear()`\n\n`Map`に登録されている要素をすべて削除するには`clear`メソッドを使います。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconsole.log(map.size);\n// @log: 3\nmap.clear();\nconsole.log(map.size);\n// @log: 0\n```\n\n### キーを列挙する - `Map.prototype.keys()`\n\n`keys`メソッドはキーの反復可能オブジェクトを返します。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst keys = [...map.keys()];\nconsole.log(keys);\n// @log: [\"a\", \"b\", \"c\"]\n```\n\n### 値を列挙する - `Map.prototype.values()`\n\n`values`メソッドは値の反復可能オブジェクトを返します。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst values = [...map.values()];\nconsole.log(values);\n// @log: [1, 2, 3]\n```\n\n### キーと値のペアを列挙する - `Map.prototype.entries()`\n\n`entries`メソッドはキーと値の反復可能オブジェクトを返します。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst keyValues = [...map.entries()];\nconsole.log(keyValues);\n// @log: [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```\n\n### キーと値のペアを反復する\n\n`Map`は`for...of`で反復できます。反復の順序は登録された順です。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\n\nfor (const [key, value] of map) {\n  console.log(key, value);\n  // \"a\", 1\n  // \"b\", 2\n  // \"c\", 3 の順で出力される\n}\n```\n\n### 複製する\n\n`Map`オブジェクトを複製(シャローコピー)するには、MapオブジェクトをMapコンストラクタに渡します。\n\n```ts twoslash\nconst map1 = new Map([[\"a\", 1]]);\nconst map2 = new Map(map1);\nconsole.log(map2);\n// @log: Map (1) {\"a\" => 1}\n```\n\n## Mapは直接JSONにできない\n\n`Map`オブジェクトはJSON.stringifyにかけても、登録されている要素はJSONになりません。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconsole.log(JSON.stringify(map));\n// @log: \"{}\"\n```\n\n`Map`をJSON化する場合は、一度オブジェクトにする必要があります。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst obj = Object.fromEntries(map);\nconsole.log(JSON.stringify(obj));\n// @log: \"{\"a\":1,\"b\":2,\"c\":3}\"\n```\n\n## 他の型との相互運用\n\n### Mapを配列にする\n\n`Map<K, V>`にスプレッド構文を使うと、タプル型配列`[K, V][]`が得られます。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst keyValues = [...map];\nconsole.log(keyValues);\n// @log: [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```\n\n### オブジェクトをMapにする\n\nオブジェクトを`Map`に変換するには、`Object.entries`の戻り値をMapコンストラクタに渡します。\n\n```ts twoslash\nconst obj = { a: 1, b: 2, c: 3 };\nconst map = new Map(Object.entries(obj));\nconsole.log(map);\n// @log: Map (3) {\"a\" => 1, \"b\" => 2, \"c\" => 3}\n```\n\n### Mapをオブジェクトにする\n\nMapをオブジェクトにするには、`Object.fromEntries`にMapオブジェクトを渡します。\n\n```ts twoslash\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconst obj = Object.fromEntries(map);\nconsole.log(obj);\n// @log: { \"a\": 1, \"b\": 2, \"c\": 3 }\n```\n\n## Mapとオブジェクトの違い\n\nキーと値のペアが表現ができるという点で、`Map`とオブジェクトは似ていますが、次の違いがあります。\n\n| 違い                     | `Map`        | オブジェクト       |\n| ------------------------ | ------------ | ------------------ |\n| プロトタイプキーの上書き | 起きない     | 起こりうる         |\n| キーに使える型           | 任意の型     | `string`か`symbol` |\n| 反復の順序               | 挿入順       | 複雑なロジック     |\n| JSON化                   | 直接できない | 直接できる         |\n\n### プロトタイプキーの上書き\n\nオブジェクトはプロトタイプのキーを上書きする可能性があります。\n\n```js twoslash\nconst obj = {};\nconsole.log(obj.toString);\n// @log: function toString() { [native code] }\nobj.toString = 1;\nconsole.log(obj.toString);\n// @log: 1\n```\n\n`Map`は要素をセットしてもプロトタイプのキーを上書きする心配がありません。要素とプロトタイプは別の領域にあるためです。\n\n```ts twoslash\nconst map = new Map<string, any>();\nconsole.log(map.toString);\n// @log: function toString() { [native code] }\nmap.set(\"toString\", 1);\nconsole.log(map.toString);\n// @log: function toString() { [native code] }\n```\n\n### キーに使える型\n\nオブジェクトのキーに使える型は`string`型か`symbol`型のどちらです。`Map`は任意の型をキーにできます。\n\n### 反復の順序\n\nオブジェクトのプロパティの反復順序は、書いた順や追加した順ではなく、複雑なロジックになっています。\n\n[オブジェクトをループする方法](../values-types-variables/object/how-to-loop-an-object.md)\n\n`Map`の要素の反復順序は要素を追加した順であることが保証されています。\n\n### JSON化\n\nオブジェクトはそのまま`JSON.stringify`でJSON化できます。`Map`は`JSON.stringify`しても要素はJSONになりません。一度`Map`をオブジェクトに変換する必要があります。\n\n### Mapとオブジェクトの書き方比較\n\n`Map`とオブジェクトは似た操作ができます。次がその対応表です。\n\n|                | `Map`                 | オブジェクト              |\n| -------------- | --------------------- | ------------------------- |\n| 型注釈の書き方 | `Map<K, V>`           | `Record<K, V>`            |\n| 初期化         | `new Map([[\"a\", 1]])` | `{ a: 1 }`                |\n| 要素のセット   | `map.set(key, value)` | `obj[key] = value`        |\n| 値の取得       | `map.get(key)`        | `obj[key]`                |\n| 要素の削除     | `map.delete(key)`     | `delete obj.key`          |\n| キーの有無確認 | `map.has(key)`        | `key in obj`              |\n| 要素数の取得   | `map.size`            | `Object.keys(obj).length` |\n| 全要素削除     | `map.clear()`         | -                         |\n| キーの列挙     | `map.keys()`          | `Object.keys(obj)`        |\n| 値の列挙       | `map.values()`        | `Object.values(obj)`      |\n| 要素の列挙     | `map.entries()`       | `Object.entries(obj)`     |\n| 複製           | `new Map(map)`        | `{ ...obj }`              |\n\n[Record<Keys, Type>](../type-reuse/utility-types/record.md)\n\n<PostILearned>\n\n🗺Mapはキーと値のペアを扱うJSビルトインのAPI\n📝TypeScriptではMap<string, number>のように型注釈する\n🔬キーは厳密等価で判定される\n🔪Mapは直接JSON化できない\n\n⚖️Mapとオブジェクトの違い\n→ Mapはキーに任意の型が使える\n→ Mapはキーの順序が挿入順保証\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/builtin-api/map"
    },
    {
      "title": "RegExpの操作",
      "content": "---\ntitle: RegExp\n---\n\nRegExpは正規表現のためのJavaScriptの組み込みクラスです。組み込みなだけあり、リテラルでの表記とコンストラクタを利用した表記の2通りがあります。\nこのページではJavaScriptのRegExp型について触れ、正規表現そのものについては直接触れません。\n\nリテラルでのRegExp型は`/`で検索したい文字を囲み、最後にフラグを書きます。一方コンストラクタでは第1引数が検索したい文字で、第2引数がフラグになります。次のRegExp型は同じものを指しています。\n\n```ts twoslash\nconst regexp1 = /0(8|9)0-[0-9]{4}-[0-9]{4}/g;\nconst regexp2 = new RegExp(\"0(8|9)0-[0-9]{4}-[0-9]{4}\", \"g\");\n```\n\nこのとき`\\`については、コンストラクタを利用する場合はふたつ書く必要があります。次のRegExp型は同じものを指します。\n\n```ts twoslash\nconst regexp1 = /0(8|9)0-\\d{4}-\\d{4}/g;\nconst regexp2 = new RegExp(\"0(8|9)0-\\\\d{4}-\\\\d{4}\", \"g\");\n```\n\nとくに、バックスラッシュ`\\`1文字を検索したい場合、コンストラクタでは`\\\\\\\\`と4文字書く必要があるので注意してください。\n\n動的に検索する対象を切り替えたい場合はコンストラクタを利用し、特に理由がなければリテラル記法を利用するのがよいでしょう。\n\n## RegExpの操作\n\n### 文字列に一致するものがあるかどうかを検査する - `Regexp.prototype.test()`\n\n第1引数の文字列を正規表現で検索するには`test`メソッドを使います。\n一致するものがある場合は`true`、そうでない場合は`false`を返します。\n\n```ts twoslash\nconst regex = /日/;\n\nconsole.log(regex.test(\"日曜日\"));\n// @log: true\n```\n\n### 文字列で一致するものの検索をする - `Regexp.prototype.exec()`\n\n第1引数の文字列を正規表現で検索し、結果を`string[]`型で返します。\n`string[]`の0番目はマッチした文字列を、1番目以降はキャプチャグループを設定したときに限りパターンにマッチした文字列を取得します。\n一致するものがない場合は`null`を返します。\n\n```ts twoslash\nconst regex = /(.日).*(.日).*(.日).*(.日).*(.日)/;\nconst results = regex.exec(\"03月01日は日曜日で祝日、晴れの日でした。\");\n\nconsole.log(results);\n// @log: [\"1日は日曜日で祝日、晴れの日\", \"1日\", \"は日\", \"曜日\", \"祝日\", \"の日\"]\n```\n\n## string型のメソッドでRegExpを使うメソッド\n\n### 文字列を検索する - `String.prototype.match()`\n\n文字列を`RegExp`で検索します。`Regexp.prototype.exec()`と同じように使うことができます。\n結果は`string[]`型で返り、0番目はマッチした文字列を、1番目以降はキャプチャグループを設定したときにパターンにマッチした文字列を取得します。\n一致するものがない場合は`null`を返します。\n\n```ts twoslash\nconst regex = /(.日).*(.日).*(.日).*(.日).*(.日)/;\nconst str = \"03月01日は日曜日で祝日、晴れの日でした。\";\n\nconsole.log(str.match(regex));\n// @log: [\"1日は日曜日で祝日、晴れの日\", \"1日\", \"は日\", \"曜日\", \"祝日\", \"の日\"]\n```\n\n### `String.prototype.match()`で注意すること\n\nRegExpにgのフラグがついている場合、完全一致した文字列の配列を返し、キャプチャグループを返さなくなります。\n\n```ts twoslash\nconst regex1 = /(.日)/;\nconst regex2 = /(.日)/g;\nconst str = \"03月01日は日曜日で祝日、晴れの日でした。\";\n\nconsole.log(str.match(regex1));\n// @log: [\"1日\", \"1日\"]\nconsole.log(str.match(regex2));\n// @log: [\"1日\", \"は日\", \"曜日\", \"祝日\", \"の日\"]\n```\n\n## Named capturing groupsについて\n\nキャプチャグループで名前を指定することができるNamed capturing groupsがありますが、残念ながらTypeScriptとの相性はよくありません。\n次の例ではNamed capturing groupsとして`pref`と`ward`にはそれぞれ`\"静岡県\"`と`\"磐田市\"`がマッチしますがTypeScriptはそのプロパティに値が設定されていることを保証しません。値の取得はオプショナルチェーンを使うとよいでしょう。\n\n```ts twoslash\nconst regex = /(?<pref>.+[都|道|府|県])(?<ward>.+[市|区|町|村])/gu;\nconst str = \"静岡県磐田市気子島\";\nconst match = regex.exec(str);\n\nconsole.log(match?.groups?.pref);\n// @log: \"静岡県\"\nconsole.log(match?.groups?.ward);\n// @log: \"磐田市\"\n\n// @errors: 2532\n```\n\n[オプショナルチェーン](../values-types-variables/object/optional-chaining.md)\n",
      "url": "https://typescriptbook.jp/reference/builtin-api/regexp"
    },
    {
      "title": "アサーション関数 (assertion functions)",
      "content": "---\nsidebar_label: アサーション関数\n---\n\n# アサーション関数 (assertion functions)\n\nユーザー定義の型ガード関数として使われるのはType predicateが主ですが、Assertion functionという方法もあります。\nType predicateはboolean型の戻り値に対して使いましたがこちらは関数が例外を投げるかどうかで判定します。型ガード関数のページで作った関数`isDuck()`をAssertion functionsで書きかえると次のようになります。\n\n```ts twoslash\n// @errors: 2339\nclass Animal {}\nclass Duck {\n  public quacks(): void {}\n}\ndeclare function walksLikeDuck(animal: Animal): boolean;\ndeclare function quacksLikeDuck(animal: Animal): boolean;\n\nconst animal = new Animal();\n// ---cut---\nfunction isDuck(animal: Animal): asserts animal is Duck {\n  if (walksLikeDuck(animal)) {\n    if (quacksLikeDuck(animal)) {\n      return;\n    }\n  }\n\n  throw new Error(\"YOU ARE A FROG!!!\");\n}\n\n// ここではquacks()は存在しない\nanimal.quacks();\n\nisDuck(animal);\n\nanimal.quacks();\n```\n\nこちらはこの関数が呼ばれた後であればいつでも変数`animal`は`Duck`型として解釈されます。\n",
      "url": "https://typescriptbook.jp/reference/functions/assertion-functions"
    },
    {
      "title": "デフォルト引数 (default parameter)",
      "content": "---\nsidebar_label: \"デフォルト引数\"\n---\n\n# デフォルト引数 (default parameter)\n\n引数の値が`undefined`のとき、代わりの値を指定できるのがデフォルト引数(default parameter)です。\n\n## デフォルト引数の構文\n\nJavaScriptのデフォルト引数は、引数の右に`=`とデフォルト値を書きます。\n\n```js twoslash\n// 関数宣言\nfunction 関数名(引数 = デフォルト値) {}\n// アロー関数\n(引数 = デフォルト値) => {};\n```\n\nTypeScriptで、型注釈とデフォルト引数の両方を書く場合は、型注釈のほうを先に書きます。\n\n```ts twoslash\ninterface 型 {}\ndeclare const デフォルト値: 型;\n// ---cut---\n// 関数宣言\nfunction 関数名(引数: 型 = デフォルト値) {}\n// アロー関数\n(引数: 型 = デフォルト値) => {};\n```\n\n## `undefined`のときデフォルト値が使われる\n\nJavaScriptの引数は省略すると`undefined`になります。\n\n```js twoslash\nfunction foo(x) {\n  console.log(x);\n}\nfoo();\n// @log: undefined\n```\n\nデフォルト引数は、引数が`undefined`のときに、その値が変わりに代入されます。たとえば、次の例の関数呼び出しは、引数を渡していないので`x`は`undefined`です。そのため、デフォルト値`1`が代入されます。\n\n```ts twoslash\nfunction foo(x = 1) {\n  console.log(x);\n}\nfoo();\n// @log: 1\n```\n\n次のように、引数に`undefined`を渡す場合も、デフォルト値が代入されます。\n\n```ts twoslash\nfunction foo(x = 1) {\n  console.log(x);\n}\n// ---cut---\nfoo(undefined);\n// @log: 1\n```\n\n引数が`null`のときは、デフォルト引数は適用されません。ご注意ください。\n\n```js twoslash {4}\nfunction foo(x = 1) {\n  console.log(x);\n}\nfoo(null);\n// @log: null\n```\n\n## 引数リストの途中に書ける\n\nJavaScriptのデフォルト引数は、デフォルト値を持たない引数の前に書くこともできます。\n\n```js twoslash\nfunction foo(x, y = 2, z) {\n  console.log(x, y, z);\n}\nfoo(1, undefined, 3);\n// @log: 1 2 3\n```\n\n## 初期化処理が書ける\n\nJavaScriptのデフォルト値には式が書けます。\n\n```js twoslash\nfunction foo(x = 2 * 2) {}\n```\n\n式が書けるので、関数呼び出しも書けます。\n\n```js twoslash\nfunction foo(x = parseInt(\"1.5\")) {}\n```\n\n### 非同期処理は書けない\n\nただし、`await`を使って、非同期関数を呼び出すような処理は書けません。\n\n```ts twoslash\n// @errors: 2524\nasync function foo(x = await Promise.resolve(1)) {}\n```\n\n## 型推論が効く\n\nTypeScriptでは、デフォルト引数があると、引数の型推論が効きます。そのため、デフォルト引数が型注釈を省略することもできます。\n\n```ts twoslash\nfunction foo(x = 1) {}\n//           ^?\n```\n\n<PostILearned>\n\n・JavaScriptのデフォルト引数は引数がundefinedのとき使われる値\n・構文: function 関数名(引数: 型 = デフォルト値) {}\n・nullのときはデフォルト値にならない\n・引数の途中に書ける\n・簡単な初期化処理も書ける\n・TypeScriptでは型推論が効く\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/functions/default-parameters"
    },
    {
      "title": "値渡しと参照渡し",
      "content": "# 値渡しと参照渡し\n\nプログラミング言語によっては、引数の渡し方に値渡し(pass-by-value)と参照渡し(pass-by-reference)の2種類が存在するものがあります。\n\n## 値渡し\n\n値渡しは、変数が関数に渡るタイミングで、変数が別の変数にコピーされます。元々同じ変数でも、関数の呼び出し元と関数の内部処理では、独立した値になります。そのため、関数の処理で引数に値を代入しても、関数呼び出し元の変数に影響しません。次は、C言語の値渡しの例です。変数`a`は`1`で初期化され、関数`change`に`a`が渡されます。`change`では引数に`2`を代入しますが、呼び出し元の変数`a`は`1`のままです。\n\n```c\n#include <stdio.h>\n\nvoid change(int n) {\n    n = 2;\n}\n\nint main() {\n    int a = 1;\n    change(a);\n    printf(\"%d\", a); //=> 1\n}\n```\n\n## 参照渡し\n\n参照渡しは、関数呼び出し元の変数が関数の処理でも共有されます。もし、関数の処理で引数に値を代入すると、関数呼び出し元の変数も変化します。次のコードはC言語の参照渡しの例です。変数`a`は関数`change`に参照渡しされます。`change`は引数に`2`を代入すると、`change`の呼び出し元の変数`a`の値も`2`になります。\n\n```c\n#include <stdio.h>\n\nvoid change(int *n) {\n    *n = 2;\n}\n\nint main() {\n    int a = 1;\n    change(&a);\n    printf(\"%d\", a); //=> 2\n}\n```\n\n## JavaScriptは値渡し\n\nJavaScriptではこのような参照渡しをする機能はありません。関数の引数はすべて値渡しになります。したがって、引数に値を代入する処理を関数に書いても、その影響は関数呼び出し元には影響しません。\n\n```js twoslash\nfunction change(n) {\n  n = 2;\n}\nlet n = 1;\nchange(n);\nconsole.log(n);\n// @log: 1\n```\n\nところが、オブジェクトについては少し特殊です。オブジェクトはどこでも参照になります。どういうことかというと、オブジェクトに別の変数名をつけても、オブジェクトが複製されて新たなオブジェクトができるのではなく、異なる変数名同士でひとつのオブジェクトを指すということです。たとえば、次の例のようにオブジェクト`{ n: 1 }`を変数`x`に代入し、さらに`x`を変数`y`に代入すると、`x`と`y`は同じオブジェクトを参照します。もし、`y`のプロパティ`n`を変更すると、`x`の`n`も変化します。\n\n```js twoslash\nconst x = { n: 1 };\nconst y = x;\ny.n = 2;\nconsole.log(x);\n// @log: { n: 2 }\n```\n\nただし、`y`に別の値を代入した場合は、`x`と`y`は共通のオブジェクトを参照しなくなり、`y`への変更は`x`には影響しなくなります。\n\n```js twoslash\nconst x = { n: 1 };\nlet y = x;\ny = { n: 2 }; // yに別オブジェクトを再代入\ny.n = 3;\nconsole.log(x);\n// @log: { n: 1 }\n```\n\n以上のようにJavaScriptでは、あるオブジェクトに別の変数をつけたとき、そのオブジェクトを共有するようになっています。共有されたオブジェクトはプロパティを変更した場合、他の変数にもその変更が影響します。この仕様は引数にも同じことが言えます。たとえば、次の例です。オブジェクト`{ n: 1 }`を変数`x`に代入し、さらに`x`を関数`change`の引数`y`に代入すると、`x`と`y`は同じオブジェクトを参照します。`y`のプロパティを変更すると、その影響は関数呼び出し元の`x`のプロパティにも影響します。\n\n```js twoslash\nfunction change(y) {\n  y.n = 2;\n}\nconst x = { n: 1 };\nchange(x);\nconsole.log(x);\n// @log: { n: 2 }\n```\n\n引数の場合も、変数の再代入の仕様と同様に、`y`に別の値を代入した場合は、`x`と`y`は同じオブジェクトを参照しなくなるため、`y`への変更は`x`に影響しなくなります。\n\n```js twoslash\nfunction change(y) {\n  y = { n: 2 };\n  y.n = 3;\n}\nconst x = { n: 1 };\nchange(x);\nconsole.log(x);\n// @log: { n: 1 }\n```\n\n以上をまとめると、JavaScriptの関数の引数は値渡しです。注意点として、オブジェクトは変数の場合と同様に、引数と呼び出し元の変数は同じオブジェクトを共有する仕様です。そして、もし引数のオブジェクトのプロパティを変更した場合、その変更は関数呼び出し元に影響します。\n\n<PostILearned>\n\n・JavaScriptの引数は値渡し\n・JavaScriptにはC言語の参照渡しと同等の仕組みはない\n・ただし、オブジェクトは値を共有する\n・共有したオブジェクトを関数で変更した場合、呼び出し元にも影響する\n・オブジェクトの共有は引数に限ったことではない\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/functions/pass-by-value"
    },
    {
      "title": "関数の引数 (function parameter)",
      "content": "---\nsidebar_label: 関数の引数\n---\n\n# 関数の引数 (function parameter)\n\n## 引数の個数\n\nJavaScriptの関数では、関数が期待する引数の個数と、関数を呼び出した際に渡した引数の数が一致していなくても、関数が呼び出せます。つまり、JavaScriptは引数のチェックを行わないということです。たとえば、引数が1つ渡されることを期待する関数を、引数2つで呼び出してもエラーになりません。\n\n```js twoslash\nfunction increment(n) {\n  return n + 1;\n}\nincrement(1, 2); // OK\n```\n\n逆に、JavaScriptでは、引数が少ない場合であっても関数が実行されます。その際、渡されなかった引数の値は`undefined`になります。\n\n```js twoslash\nfunction foo(a, b) {\n  console.log(b);\n}\nfoo(1); // 引数が足りない\n// @log: undefined\n```\n\n基本的に引数が多く渡される分には、関数の実行が問題になることはありません。余分な引数は無視してしまえばよいからです。それでも、引数の個数を厳密にチェックしたいケースでは、変数`arguments`の`length`プロパティで引数の数をチェックします。\n\n```js twoslash\nfunction foo(a, b) {\n  if (arguments.length > 2) {\n    throw new Error(\"引数の数は2つまでです\");\n  }\n}\nfoo(1, 2); // OK\nfoo(1, 2, 3); // エラー\n```\n\nJavaScriptでは、上のように引数の数をチェックするには、そのためのロジックを書く必要があります。\n\nTypeScriptでは、関数の引数の数が一致していないとコンパイルエラーになります。\n\n```ts twoslash\n// @noImplicitAny: false\n// @errors: 2554\nfunction increment(n) {\n  return n + 1;\n}\nincrement(1, 2); // 引数が多い\nincrement(); // 引数が足りない\n```\n\nそのため、TypeScriptではJavaScriptのようにチェックロジックを書く必要はありません。\n\n## 引数の型\n\nJavaScriptは、引数の型についてもチェックを行いません。JavaやPHPなどの他のプログラミング言語の中には、関数の引数の型を定義することで、関数が期待する引数の型と異なる値が渡されたときに、関数実行前にエラーにしてくれる言語があります。JavaScriptにはこのような機能がありません。たとえば、string型の引数を期待する関数に、null型の値を渡しても、JavaScriptの関数は実行されます。\n\n```js twoslash\nfunction len(str) {\n  return str.length;\n}\nconsole.log(len(null));\n```\n\nこの関数`len`の引数`str`はstring型であることを想定していますが、渡される値は`null`です。それでも、関数の実行自体は行われ、`null`に存在しない`length`プロパティへの参照を試みる段階でやっとエラーになります。\n\nJavaScriptでは、引数の型を厳密にする場合、チェック処理を書く必要があります。たとえば、引数がnumber型やstring型などのプリミティブ型かのチェックはこの`typeof`演算子を使って行います。\n\n```js twoslash\nfunction len(str) {\n  if (typeof str !== \"string\") {\n    throw new Error(\"strは文字列型にしてください\");\n  }\n  return str.length;\n}\nlen(\"a\"); // OK\nlen(1); // エラー\n```\n\nTypeScriptでは、関数の引数に型注釈が書けます。型注釈を書いておくと、引数に意図しない型を書くとコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2345\nfunction len(str: string) {\n  return str.length;\n}\nlen(\"a\"); // OK\nlen(1); // エラー\n```\n\nそのため、TypeScriptではJavaScriptのように型チェックの処理を書く必要はありません。\n",
      "url": "https://typescriptbook.jp/reference/functions/function-parameters"
    },
    {
      "title": "関数は値",
      "content": "# 関数は値\n\n他の言語では関数は特別な立ち位置のことがあります。ある言語では、同じ名前の変数を定義してもエラーにならないのに対し、同じ名前の関数定義はエラーになります。またある言語では、関数を変数に代入できなかったりします。\n\nJavaScriptの関数は値です。つまり、PHPのような他の言語と比べると特別扱いの度合いが少ないです。たとえば、関数を変数に代入することができます。\n\n```js twoslash\nfunction hello() {\n  return \"Hello World\";\n}\n\nconst helloWorld = hello; // 関数を変数に代入\n\nhelloWorld(); // 関数呼び出しも問題なくできる\n```\n\nまた、JavaScriptでは定義済みの関数と同じ名前の関数を宣言することができます。これはエラーにはなりません。これは実質、再代入のような振る舞いになります。\n\n```js twoslash\nfunction hello() {\n  return \"HELLO\";\n}\n\n// これは二度目の関数宣言ですが、実質的には再代入です\nfunction hello() {\n  return \"KONNICHIWA\";\n}\n\nhello();\n// @log: KONNICHIWA\n```\n\nこのようにJavaScriptの関数は、booleanの値やstringの値などと同じような値としての性質があります。意図しない再代入はバグの原因になりますが、JavaScriptでは関数宣言では注意して書く以外に方法はありません。\n\nJavaScriptで関数の再代入によるバグを未然に回避したい場合は、`const`と関数式を組み合わせます。関数式については後述します。\n\n```js twoslash\nconst hello = function () {\n  return \"HELLO\";\n};\n```\n\nちなみに、TypeScriptではコンパイラーが重複した関数宣言を警告してくれるので、バグの心配はありません。\n\n## 関数のスコープ\n\n関数は値なので、関数名のスコープも変数と同じようにスコープの概念があります。たとえば、関数スコープの中で定義された関数は、そのローカルスコープでのみ使うことができます。\n\n```js twoslash\nfunction main() {\n  // ローカルスコープの関数\n  function hello() {\n    console.log(\"hello\");\n  }\n\n  hello();\n}\n\nmain();\n// @log: \"hello\"\n\n// ローカルスコープで宣言された関数にはアクセスできない\nhello();\n// @error: ReferenceError: hello is not defined\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/function-is-a-value"
    },
    {
      "title": "従来の関数とアロー関数の違い",
      "content": "# 従来の関数とアロー関数の違い\n\nJavaScriptの関数は、[関数宣言]、[関数式]、[アロー関数]の3通りの方法で作れます。\n\n[関数宣言]: ./function-declaration.md\n[関数式]: ./function-expression.md\n[アロー関数]: ./arrow-functions.md\n\n## アロー関数は後発\n\nJavaScriptの歴史を紐解くと、元々は関数宣言と関数式しかありませんでした。この2つの機能上の違いはほぼありません。この2つはまとめて「従来の関数」と呼びます。アロー関数は、従来の関数の問題点を解決するために、あとで導入されたものです。\n\n## 構文の簡潔さ\n\n従来の関数は構文の長さが問題でした。JavaScriptではよくコールバック関数を書きます。コールバック関数とは、関数の引数として渡される関数を言います。従来の関数は、関数を書くたびに`function`キーワードを書く必要があります。処理が1行だけでも、複数行要するコーディングスタイルもあります。書くのも読むのもわずらわしいコードになりがちです。一方で、アロー関数は短くシンプルな記述になります。\n\n```js twoslash\n// 従来の関数(関数式)\n[1, 2, 3].map(function (n) {\n  return n + 1;\n});\n// アロー関数\n[1, 2, 3].map((n) => n + 1);\n```\n\n## 引き算で再設計されたアロー関数\n\nアロー関数が後発だと聞くと、従来の関数に機能が追加されたものと思われるかもしれません。実は逆です。引き算のアプローチでアロー関数は再設計されました。従来の関数が持つ機能から、関数としては余計な機能を削ったり、複雑な仕様を単純化したりしたものです。そのため、シンプルに「関数らしさ」がより際立つものになっています。どのような機能が間引かれたか見ていきましょう。\n\n### コンストラクタ\n\n関数の機能の本質は、入力から計算結果を返すことです。JavaScriptの従来の関数にはこの本質以外に、オブジェクトを生成するコンストラクタの役割も担います。関数をコンストラクタとして扱うには`new`演算子を用います。\n\n```js twoslash\nfunction Cat(name) {\n  this.name = name;\n}\n// Catオブジェクトを生成する\nconst cat = new Cat(\"ミケ\");\nconsole.log(cat);\n// @log: Cat { name: 'ミケ' }\n```\n\n関数にコンストラクタ機能がついているのは、一見すると便利そうです。しかし、関数に`new`演算子をつけるべきかどうかを、使い手が判断する必要がでてしまいます。それを判断するには、関数の処理内容を読んでみるまで分かりません。コンストラクタとして実行すべき関数を、普通の関数として呼び出ししてまうとバグの原因になりえます。\n\nアロー関数はコンストラクタになれません。もしもJavaScriptで`new`演算子を使うと実行エラーになります。誤用の心配がありません。\n\n```js twoslash\nconst Cat = (name) => {};\nconst cat = new Cat(\"ミケ\");\n// @error: TypeError: Cat is not a constructor\n```\n\nTypeScriptでは、従来の関数でもコンストラクタとして使えないようになっています。もし、関数を誤って`new`したとしても、コンパイルエラーで警告されるので安心です。\n\n```ts twoslash\n// @errors: 7009\nfunction Cat(name: string) {\n  /* ... */\n}\nconst cat = new Cat(\"ミケ\");\n```\n\nまとめると、JavaScriptではコンストラクタになれるかどうかは意識する必要がありますが、TypeScriptではコンパイルエラーで気づけるので、JavaScriptほど注意を払う必要はないということになります。\n\n### thisの指すもの\n\n従来の関数では、変数`this`の指すものが実行時の文脈で決まるという仕様があります。言い換えると、同じ関数であっても、関数の呼び出し方や呼び出される環境によって`this`が別のものを参照するようになります。次の`this`をコンソールに表示する従来の関数を例に見てみましょう。\n\n```js twoslash\nfunction showThis() {\n  console.log(this);\n}\n```\n\nこの`showThis`関数を普通に実行した場合、`this`が指すのはグローバルオブジェクトです。グローバルオブジェクトとはブラウザでは`Window`オブジェクトです。`Window`オブジェクトはページのサイズやURL、表示するHTML(DOM)などを操作するAPIを提供するオブジェクトです。\n\n```js twoslash\nshowThis();\n// @log: Window\n```\n\nJavaScriptにはstrictモードがあります。これは危険な処理ができないよう制約する実行モードです。strictモードを有効にするには`\"use strict\"`をコードの冒頭に書きます。strictモードで`showThis`を実行すると、`this`の値は`undefined`になります。\n\n```js twoslash\n\"use strict\";\nshowThis();\n// @log: undefined\n```\n\nちなみにTypeScriptでは、コンパイラオプション[`alwaysStrict`](../tsconfig/alwaysstrict.md)を有効にすると、コンパイル後のJavaScriptがstrictモードになります。\n\nまた、JavaScriptにはスクリプトモードとモジュールモードがあります。モジュールモードのJavaScriptでは、`export`や`import`の構文が使えます。このモードでは自動的にstrictモードになります。そのため、モジュールモードで`showThis`を実行すると、`this`の値は`undefined`になります。\n\n```js twoslash\nexport {};\nshowThis();\n// @log: undefined\n```\n\n関数はオブジェクトのメソッドとして呼び出すこともできます。`showThis`関数をメソッド呼び出しした場合、`this`が指す値はメソッドが紐づくオブジェクトになります。\n\n```js twoslash\nconst foo = { name: \"Foo\" };\n// 関数をオブジェクトのメンバーにする\nfoo.showThis = showThis;\n// メソッドとして呼び出す\nfoo.showThis();\n// @log: {name: \"Foo\", showThis: function}\n```\n\n従来の関数はコンストラクタとして呼び出せることを説明しましたが、コンストラクタとして呼び出した場合、`this`は生成中のオブジェクトを指します。\n\n```js twoslash\nfunction showThis() {\n  this.name = \"Foo\";\n  console.log(this);\n}\nnew showThis();\n// @log: {name: \"Foo\"}\n```\n\n上で例示してきたとおり、従来の関数は実行の文脈で`this`の内容が動的に決まります。そのため、従来の関数は呼び出し方に注意を払う必要があります。使い方を誤るとバグに繋がる危険性があります。\n\n<figure><figcaption>従来の関数のthisが指すもの</figcaption>\n\n| 文脈                                           | thisの値                            |\n| ---------------------------------------------- | ----------------------------------- |\n| 通常の呼び出し<br/>`showThis()`                | グローバルオブジェクト(`Window`)    |\n| 通常の呼び出し + strictモード<br/>`showThis()` | `undefined`                         |\n| メソッド呼び出し<br/>`obj.showThis()`          | メソッドが属するオブジェクト(`obj`) |\n| コンストラクタ呼び出し<br/>`new showThis()`    | 生成中のオブジェクト                |\n\n</figure>\n\nアロー関数の`this`はレキシカルスコープで静的です。つまり、定義したときに`this`が指すものが決定し、関数の呼び出し方(文脈)に左右されません。`this`の値は明瞭です。\n\nたとえば、次の`timer`オブジェクトは1秒後にメッセージを表示する`start`メソッドを持ちます。`start`メソッドで1秒後に`timer`の`message`フィールドの値を出力する処理を予約しています。\n\n`start`関数の`this`は`timer`を指します(❶)。1秒経つと、`this.message`を出力しようとします。従来の関数は、`this`がグローバルオブジェクトの`Window`を指すため、`undefined`が出力されます(❷)。一方のアロー関数は、`this`がレキシカルスコープの`this`を指します(❸)。この`this`は`timer`です。よって、`message`フィールドの値`\"時間です！\"`が正常に出力されます。\n\n```js twoslash\nconst oneSecond = 1000;\nconst timer = {\n  message: \"時間です！\",\n  start: function () {\n    console.log(this); // ❶\n\n    // 従来の関数\n    setTimeout(function () {\n      console.log(this.message); // ❷\n    }, oneSecond);\n\n    // アロー関数\n    setTimeout(() => {\n      console.log(this.message); // ❸\n    }, oneSecond);\n  },\n};\ntimer.start();\n```\n\n### `call`、`apply`、`bind`の振る舞い\n\nJavaScriptの関数はオブジェクトで、`call`、`apply`、`bind`の3つのメソッドが生えています。このメソッドは関数を呼び出すものですが、従来の関数では、第一引数に`this`が何を指すかを指定できます。\n\n```js twoslash\nfunction showThis() {\n  console.log(this);\n}\nconst obj = { name: \"foo\" };\nshowThis.bind(obj)(); // objをthisにバインドして、関数呼び出し\n// @log: { name: 'foo' }\n```\n\nアロー関数にも、`call`、`apply`、`bind`が生えていますが、第一引数に値を渡しても`this`は上書きされません。\n\n```js twoslash\nconst showThis = () => {\n  console.log(this);\n};\nconst obj = { name: \"foo\" };\nshowThis.bind(obj)();\n// @log: {}\n```\n\n### arguments変数の有無\n\n従来の関数では、`arguments`という特殊な変数が自動的に定義されます。この値は引数の配列です。\n\n```js twoslash\nfunction foo() {\n  console.log(arguments);\n}\nfoo(1, 2, 3);\n// @log: [1, 2, 3]\n```\n\n`arguments`は可変長引数を実現するには便利ですが、関数を実装する多くの場合、利用することのない余計な変数という見方もできます。アロー関数には`arguments`がありません。アロー関数で可変長引数を実現したい場合は、[残余引数](./rest-parameters.md)`...`を用います。\n\n```js twoslash\nconst foo = (...args) => {\n  console.log(args);\n};\nfoo(1, 2, 3);\n// @log: [1, 2, 3]\n```\n\n### ジェネレーター\n\nJavaScriptにはジェネレーターという複数の値を生成できる特殊な関数があります。ジェネレーターは、`function`キーワードにアスタリスクをつけ、`yield`文で生成する値を記述します。\n\n```js twoslash\nfunction* generateNumbers() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\nジェネレーターの値はfor-ofなどの反復処理で取り出せます。\n\n```js twoslash\nfor (const value of generateNumbers()) {\n  console.log(value); // 1、2、3の順で出力される\n}\n```\n\nジェネレーターを定義できるのは従来の関数だけです。アロー関数はそもそもジェネレーター構文をサポートしていないため、ジェネレーターを定義することはできません。\n\n## 安全性が強化されたアロー関数\n\nアロー関数は、従来の関数にあった危険な仕様が改善されています。\n\n### 引数名の重複\n\nJavaScriptの従来の関数は、引数名の重複が許されます。引数が重複した場合、最後の引数に渡された値が採用されます。\n\n```js twoslash\nfunction foo(a, a, a) {\n  console.log(a);\n}\nfoo(1, 2, 3);\n// @log: 3\n```\n\nこの仕様はバグを引き起こしやすいものですが、従来の関数でもstrictモードにすることで、引数名の重複を構文エラーにできます。\n\n```js twoslash\n\"use strict\";\nfunction foo(a, a) {}\n//              ^構文エラー\n// @error: SyntaxError: Duplicate parameter name not allowed in this context\n```\n\nアロー関数が導入される際には、こうした危険な仕様が最初から省かれました。アロー関数で引数名が重複した場合、strictモードのオンオフにかかわらず常に構文エラーになります。\n\n```js twoslash\nconst foo = (a, a) => {};\n//              ^構文エラー\n// @error: SyntaxError: Duplicate parameter name not allowed in this context\n```\n\nTypeScriptでは、従来の関数でも引数名の重複はコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2300\nfunction foo(a: number, a: number) {}\n```\n\nそのため、TypeScriptにおいては、従来の関数とアロー関数の間に、そもそも安全面での差はありません。\n\n### 関数名の重複\n\nJavaScriptでは変数宣言するときに`const`と`let`、`var`のいずれかで行います。`var`はJavaScriptの初期から存在する宣言方法ですが、`const`と`let`は2015年に追加されたものです。大きな違いは、`const`は宣言時にのみ値が代入できる宣言方法で、`let`は宣言後でも値を変更できる宣言方法です。\n\n`const`と`let`は、`var`の問題点を解決するために導入されました。`var`の問題点のひとつが何度も同じ変数名で変数宣言できる点でした。たとえば、`value`という変数がすでに宣言されていたとしても、もう一度`var value`で変数宣言しなおすと、特にエラーになることはなく実行できてしまいます。\n\n```js twoslash\nvar value = 1;\nvar value = 2;\nconsole.log(value);\n// @log: 2\n```\n\nこの仕様は、意図しない変数の上書きに気づきにくく、不具合の要因になることがしばしばあります。`const`や`let`は変数名が重複している場合は、エラーになります。つまり、`var`よりも安全なコーディングが行えます。\n\n```js twoslash\n// @errors: 2451\nlet value = 1;\nlet value = 2; // 構文エラー\n```\n\n関数宣言で作った関数は`var`に相当します。そのため、重複した関数名で関数が作れてしまいます。\n\n```js twoslash\nfunction foo() {\n  console.log(\"1つ目の関数\");\n}\nfunction foo() {\n  console.log(\"2つ目の関数\");\n}\nfoo();\n// @log: \"2つ目の関数\"\n```\n\nアロー関数は、変数宣言と同じ構文で作るため、`var`を避けて`let`または`const`を使うコーディングをしている限り、関数名の重複が起こりえません。\n\n```js twoslash\n// @errors: 2451\nconst foo = () => {};\nconst foo = () => {};\n```\n\nもちろん、アロー関数でも`var`を用いて関数を作った場合は、関数名が重複できてしまいます。しかし、最近のJavaScriptのベストプラクティスでは、`var`を使わないことが推奨されています。そのため、関数宣言と比べて、アロー関数のほうがずっと関数名重複のミスを低減できる状況が多いです。\n\nTypeScriptでは、関数宣言でも重複した関数名がコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2393\nfunction foo() {}\nfunction foo() {}\n```\n\nしたがって、関数名の重複問題に関しては、TypeScriptでは安全性の差がありません。\n\n## 巻き上げと関数定義と呼び出しの順序\n\n関数宣言とアロー関数では[巻き上げ(hoisting)](./function-declaration-and-hoisting.md)が起こるか否かの違いがあります。巻き上げとは、変数が宣言される前のコードで、その変数を参照できる仕様です。\n\n巻き上げとは、変数スコープの途中で宣言された変数が、変数スコープの冒頭に変数宣言を自動的に持ってくる仕様です。巻き上げられた変数は`undefined`で初期化された状態になります。次の例では、`value`の変数宣言よりも先に、変数`value`を参照していますが、これはエラーにならず`undefined`が出力されます。\n\n```js twoslash\nconsole.log(value);\n// @log: undefined\nvar value = 1;\n```\n\nこれは変数`value`に巻き上げが起こり、`console.log(value)`よりも手前で`value`の変数宣言がなされるためです。上のコードは、実質的に次のコードと同じ意味になります。\n\n```js twoslash\nvar value;\nconsole.log(value);\nvalue = 1;\n```\n\n関数宣言でも類似の巻き上げが起こります。`var`の巻き上げと異なる点は、関数は`undefined`で初期化されるのではなく、関数の実装も合わせて巻き上げられる点です。そのため、関数宣言よりも手前で関数呼び出しが行えます。\n\n```js twoslash\nfoo();\n// @log: 実行しました\nfunction foo() {\n  console.log(\"実行しました\");\n}\n```\n\nコードに書かれた順序が、関数呼び出し、関数宣言の順になるだけで、関数の巻き上げには問題点はありません。\n\n<PostILearned>\n\nJavaScriptのアロー関数の特徴\n\n・構文が短い\n・thisがレキシカルスコープ\n・コンストラクタになれない\n・ジェネレータになれない\n・引数の重複が起こらない\n・関数の宣言重複が起きにくい\n・巻き上げが起きにくい\n\n</PostILearned>\n\n## 従来の関数とアロー関数の使い分け\n\n上では、従来の関数(関数宣言と関数式)とアロー関数の機能上の違いを見てきました。違いを踏まえた上で、この2つはどちらを使ったほうがよいのでしょうか。もしどちらも使う場合、どのような基準で使い分けたらよいのでしょうか。\n\n従来の関数を使うべきか、アロー関数を使うべきかは、意見が分かれるところです。アロー関数は従来の関数の問題点を解決した新しい機能であるため、できるだけアロー関数を使うべきという考えの人もいます。一方で、関数宣言とアロー関数は適度に使い分けるべきという意見の人もいます。アロー関数よりも関数宣言を積極的に使うべきと考える人もいるでしょう。どこでアロー関数を使い、どこで従来の関数を使うか。こうした基準は議論が尽きないところです。どのような判断基準が正しいと断言できるものではありません。\n\nそれでも、従来の関数とアロー関数の使い分け方は、個人やチームといったひとつのソースコードを共有する範囲では、一貫した決まりで使い分けることが重要です。ここからは、自分なりの使い分けを考えられるようになるために、判断材料の手がかりを示したいと思います。ここで提示することが普遍的に正しいとは限りません。読んだ上で自分なりの使い分け方を考えてみてください。\n\n特に理由がない場合、アロー関数を使うほうが無難です。なぜかと言うと、アロー関数は関数としての最低限の機能をもったシンプルな関数だからです。上で見たように、従来の関数にはコンストラクタや`this`の動的な解釈などさまざまな機能があり、それらの機能を使わない場合は余計な機能になります。機能が多い分、コーディング時に考慮しないといけないことが増えます。アロー関数はミニマムな機能に抑えられているので、細かいことを気にせず書ける利点があります。\n\nアロー関数が特に相性がいいところはコールバック関数です。たとえば、配列オブジェクトの`Array`には、各要素に対して処理をかけるメソッドがいくつかあります。これらのメソッドは引数に関数を渡す必要があります。次の例は、数値の配列に対して`filter`メソッドを用い、偶数だけを抽出するコードです。このコードでは関数式をコールバック関数に渡しています。\n\n```js twoslash\nconst nums = [1, 2, 3, 4];\nconst even = nums.filter(function (n) {\n  return n % 2 === 0;\n});\nconsole.log(even);\n// @log: [2, 4]\n```\n\nこれをアロー関数に置き換えると、次のようにシンプルな記述になります。\n\n```js twoslash\nconst nums = [1, 2, 3, 4];\nconst even = nums.filter((n) => n % 2 === 0);\nconsole.log(even);\n// @log: [2, 4]\n```\n\nこうしたコールバック関数ではアロー関数を積極的に使うことで、コードの記述量が減ったり、コードが意図する処理が目立つといったメリットが出てきます。\n\n従来の関数も出番がないわけではありません。HTMLのボタンがクリックされたときに何らかの処理をしたい場合、`addEventListener`メソッドを使います。任意の処理をコールバック関数としてこのメソッドに渡すことで、好きな処理が行なえます。\n\n```js twoslash\nbutton.addEventListener(\"click\", コールバック関数);\n```\n\n処理の中でクリックされたボタンを参照する場合、渡す関数が従来の関数なら変数`this`でボタンを参照できます。下の例では、クリックした「保存」ボタンの表示を「保存中…」に変えるコードです。`this.innerText`でボタン表示を変更しています。このような`this`の使い方をしたい場合はアロー関数では書くことができません。\n\n```html\n<button id=\"save\">保存</button>\n<script>\n  const button = document.getElementById(\"save\");\n  button.addEventListener(\"click\", function () {\n    this.innerText = \"保存中…\";\n  });\n</script>\n```\n\n上の場合でも、`button`を参照すればアロー関数も使えます。なので、従来の関数でなければならない決定打ではありません。\n\n```html {4-5}\n<button id=\"save\">保存</button>\n<script>\n  const button = document.getElementById(\"save\");\n  button.addEventListener(\"click\", () => {\n    button.innerText = \"保存中…\";\n    // ^^^buttonを参照\n  });\n</script>\n```\n\nオブジェクトのメソッドとして関数を作る場合は、従来の関数を選ぶ理由になります。`this`でオブジェクトを参照できるからです。たとえば、次の例`fullName1`メソッドのように、メソッドでオブジェクトのプロパティを用いる場合、`this`で参照するのが便利です。\n\n```js twoslash\nconst taroYamada = {\n  firstName: \"Taro\",\n  lastName: \"Yamada\",\n  // 従来の関数\n  fullName1: function () {\n    return this.firstName + \" \" + this.lastName;\n  },\n  // アロー関数\n  fullName2: () => {\n    return this.firstName + \" \" + this.lastName;\n  },\n};\nconsole.log(taroYamada.fullName1());\n// @log: \"Taro Yamada\"\nconsole.log(taroYamada.fullName2());\n// @log: undefined undefined\n```\n\nアロー関数を用いた`fullName2`は`this`がオブジェクトを指さないため、期待どおりの動作になりません。もし、アロー関数を使う場合は、`this`ではなく`taroYamada.firstName`のようにオブジェクトの変数名を参照する必要があります。\n\n```js twoslash\nconst taroYamada = {\n  firstName: \"Taro\",\n  lastName: \"Yamada\",\n  fullName: () => {\n    return taroYamada.firstName + \" \" + taroYamada.lastName;\n  },\n};\nconsole.log(taroYamada.fullName());\n// @log: \"Taro Yamada\"\n```\n\n従来の関数には巻き上げがあるおかげで、理解しやすいコードになる場合もあります。たとえば、プログラムを処理過程ごとに関数でグルーピングし、プログラムの冒頭で関数呼び出しを羅列することで、そのプログラムの処理の概要が読み始めのところでわかりやすくなることがあります。\n\n```js twoslash\n// プログラムの概要\nstep1();\nstep2();\nstep3();\n\n// 各処理の詳細\nfunction step1() {\n  /* 処理の詳細 */\n}\nfunction step2() {\n  /* 処理の詳細 */\n}\nfunction step3() {\n  /* 処理の詳細 */\n}\n```\n\nアロー関数は、`const`や`let`、`var`で作る必要があるため、関数の巻き上げが起こりません。そのため、上のサンプルコードのように先に処理の概要を示すようなパターンはそのまま書くことができません。\n\n```js twoslash\nstep1();\n// @error: ReferenceError: Cannot access 'step1' before initialization\nstep2();\nstep3();\nconst step1 = () => {};\nconst step2 = () => {};\nconst step3 = () => {};\n```\n\nもし上の書き方と近い表現をアロー関数で行う場合、処理の概要を書いた関数を定義し、その関数をプログラムの最後で呼び出す書き方になります。\n\n```js twoslash\nconst main = () => {\n  step1();\n  step2();\n  step3();\n};\nconst step1 = () => {};\nconst step2 = () => {};\nconst step3 = () => {};\nmain();\n```\n\n関数が関数であることを目立たせたい場合に、関数宣言を使うという選択もあります。アロー関数は、変数宣言と同じ書き方で書くので、それが値なのか関数なのかがひと目では分かりにくいと感じる人も中にはいます。変数宣言の間に、アロー関数と関数宣言がある次の例を見比べてください。どちらがぱっと見て関数であると分かりやすいでしょうか。\n\n```js twoslash\n// 変数宣言の間にあるアロー関数\nconst str = \"foo\";\nconst obj = { value: str };\nconst func = (n) => n + 1;\nconst nums = [1, 2, 3];\n```\n\n```js twoslash\n// 変数宣言の間にある関数宣言\nconst str = \"foo\";\nconst obj = { value: str };\nfunction func(n) {\n  return n + 1;\n}\nconst nums = [1, 2, 3];\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/function-expression-vs-arrow-functions"
    },
    {
      "title": "型ガード関数 (type guard function)",
      "content": "---\nsidebar_label: 型ガード関数\n---\n\n# 型ガード関数 (type guard function)\n\n型ガードを使用することによって`if`のブロックで特定の型に絞りこむことができます。\nTypeScriptに元々用意されている型ガードとしては`typeof`や`instanceof`がありますが、これ以外にもユーザーが独自に型ガードを定義することができます。\n\n## ユーザー定義の型ガード関数\n\nユーザー定義の型ガード関数を作るためにはType predicateを使用します。Type predicateの宣言は戻り値がboolean型の関数に対して適用でき、戻り値の型の部分を次のように書き替えます。\n\n```ts twoslash\nclass Animal {}\nclass Duck {}\n// ---cut---\nfunction isDuck(animal: Animal): animal is Duck {\n  return animal instanceof Duck;\n}\n```\n\n`animal is Duck` の部分がType predicateです。これで関数`isDuck()`が`true`を返す時の`if`のブロックの中では`animal`は`Duck`型として解釈されるようになります。\n\n```ts twoslash\n// @errors: 2339\nclass Animal {}\nclass Duck {\n  public quacks(): void {}\n}\ndeclare function isDuck(animal: Animal): animal is Duck;\n\nconst animal = new Animal();\n// ---cut---\n// ここではquacks()は存在しない\nanimal.quacks();\n\nif (isDuck(animal)) {\n  animal.quacks();\n  // ...\n}\n```\n\nしかしながら、これはあくまでもその型であるとTypeScriptに解釈させるだけなので、JavaScriptとして正しいということは断言できません。\n\n```ts twoslash\nfunction isUndefined(value: unknown): value is undefined {\n  return typeof value === \"number\";\n}\n```\n\n上記関数`isUndefined()`は明らかに誤っていますが、この誤りに対してTypeScriptは何も警告を出しません。\n\n## 関連情報\n\n[制御フロー分析と型ガードによる型の絞り込み](../statements/control-flow-analysis-and-type-guard.md)\n",
      "url": "https://typescriptbook.jp/reference/functions/type-guard-functions"
    },
    {
      "title": "関数式 (function expression)",
      "content": "---\nsidebar_label: 関数式\n---\n\n# 関数式 (function expression)\n\n関数式はJavaScriptで関数を作る方法のひとつで、function**式**を用います。\n\n## 関数式の構文\n\n関数式の構文は、[関数宣言]と同じです。\n\n[関数宣言]: ./function-declaration.md\n\n<!--prettier-ignore-->\n```js twoslash\n// @noImplicitAny: false\nfunction 関数名(引数) {\n  // 処理内容\n};\n```\n\n[関数宣言]は文でしたが、関数式は式です。式とは、評価した結果が値になるものを言います。関数式は値になるので、変数に直接代入できます。\n\n```js twoslash\n// @noImplicitAny: false\nconst 変数名 = function 関数名(引数) {\n  // 処理内容\n};\n```\n\n## 関数名の省略\n\n<!--textlint-disable prh-->\n\n関数式は、関数名を省略できます。名前がない関数なので、匿名関数や無名関数とも呼ばれます。\n\n<!--textlint-enable prh-->\n\n```js twoslash\nconst 変数名 = function () {};\n//                     ^関数名を省略\n```\n\n関数式を呼び出すには、変数名を使います。\n\n```js twoslash\nconst 変数名 = function () {};\n// ---cut---\n変数名(); // 呼び出し\n```\n\nたとえば、次の関数宣言で書かれたincrement関数を、\n\n```js twoslash\nfunction increment(n) {\n  return n + 1;\n}\n```\n\n関数式に書き直すと次のようになります。\n\n```js twoslash\nconst increment = function (n) {\n  return n + 1;\n};\n```\n\n関数式は、オブジェクトのプロパティに直接代入することもできます。\n\n```ts twoslash\nconst オブジェクト = {\n  メソッド名: function () {},\n};\n```\n\n関数式は、別の関数の引数に直接渡すこともできます。たとえば、ボタンがクリックされたときの処理を指定するときに関数式を用います。\n\n```js twoslash\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"クリックされました\");\n});\n```\n\n## 関数式と型注釈\n\nTypeScriptでは、関数宣言と同様に引数の型注釈が書けます。\n\n```ts twoslash\nconst increment = function (n: number) {\n  //                         ^^^^^^^^引数の型注釈\n  return n + 1;\n};\n```\n\n引数の型注釈を省略した場合、その型は`any`になります。\n\n```ts twoslash\nconst increment = function (n) {};\n//                          ^?\n// @noImplicitAny: false\n```\n\n関数型の変数に関数式を代入する場合は、引数の型注釈を省略しても、型推論が効きます。変数の型情報から、引数の型がわかるからです。\n\n```ts twoslash\ntype UseString = (value: string) => void;\nlet useString: UseString; // 関数型の変数\nuseString = function (value) {}; // 関数型変数に関数式を代入\n//                    ^?\n```\n\nTypeScriptの関数式では、戻り値の型注釈も書けます。\n\n```ts twoslash\nconst getZero = function (): number {\n  //                         ^^^^^^戻り値の型注釈\n  return 0;\n};\n```\n\n戻り値の型注釈を省略した場合、関数のロジックから型が推論されます。\n\n```ts twoslash\nconst getZero = function () {\n  return 0;\n};\nconst num = getZero();\n//    ^?\n```\n\n## 関数式の関数名\n\nJavaScriptでは、function式に関数名を書いた場合、その関数名は関数の処理内部からのみ参照できます。これは再帰関数を書くときに活用されます。次の例は、与えられた数値`n`の階乗を求める関数です。関数名の`fact`はその関数の中でのみ使えます。関数の外からは`factorial`で呼び出す必要があります。\n\n```js twoslash\nconst factorial = function fact(n) {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * fact(n - 1); // 関数名を使い再帰呼び出し\n};\n```\n\n上の例は、次のように変数名を使った再帰呼び出しに書き換えることもできます。\n\n```js {6} twoslash\n//                        ↓関数名を省略\nconst factorial = function (n) {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1); // 変数名を使った再帰呼び出し\n};\n```\n\n<PostILearned>\n\n・関数式はfunction式を使った関数\n・関数式は関数名が省略可。匿名関数と呼ばれる。\n・関数式は変数や引数などに直接代入できる\n・型注釈の書き方は関数宣言と同じ\n・関数式の関数名は、関数内部からのみ参照可\n\n</PostILearned>\n\n## 関連情報\n\n[関数式とアロー関数の違い](function-expression-vs-arrow-functions.md)\n\n[関数宣言](./function-declaration.md)\n\n[アロー関数](./arrow-functions.md)\n",
      "url": "https://typescriptbook.jp/reference/functions/function-expression"
    },
    {
      "title": "残余引数/可変長引数 (rest parameter)",
      "content": "---\nsidebar_label: 残余引数/可変長引数\n---\n\n# 残余引数/可変長引数 (rest parameter)\n\n通常の関数は引数の数が決まっています。JavaScriptでは引数の数に決まりがない関数も作れます。引数の個数が決まっていない引数のことを可変長引数(variable length arguments, variadic arguments)といいます。JavaScriptでは可変長引数は残余引数(rest parameter)と呼びます。\n\n## 残余引数の書き方\n\nJavaScriptで残余引数を書くには、引数の前に`...`を書きます。\n\n```js twoslash\nfunction func(...params) {\n  // ...\n}\n```\n\n受け取った残余引数は配列になります。\n\n```js twoslash\nfunction func(...params) {\n  console.log(params);\n}\nfunc(1, 2, 3);\n// @log: [ 1, 2, 3 ]\n```\n\n普通の引数と残余引数を持つ関数も作れます。\n\n```js twoslash\nfunction func(param1, ...params) {\n  console.log(param1, params);\n}\nfunc(1, 2, 3);\n// @log: 1 [ 2, 3 ]\n```\n\n残余引数は必ず最後の引数でなければなりません。残余引数を複数持たせることはできません。また、残余引数の後に普通の引数を置くこともできません。\n\n```js twoslash\n// @errors: 1014\n// 構文エラーになるコード\nfunction func(...params1, ...params2) {}\nfunction func(...params, param1) {}\n```\n\n## 残余引数の型注釈\n\nTypeScriptで残余引数に型注釈するには、配列の型を書きます。たとえば、残余引数がnumber型なら、`number[]`のように書きます。\n\n```ts twoslash\nfunction func(...params: number[]) {\n  // ...\n}\n```\n\n## 配列を残余引数として渡す\n\nJavaScriptに組み込みのメソッドに`Math.max()`があります。これは、引数に与えられた数値の中から最大値を返します。この関数は残余引数を要求します。\n\n```js twoslash\nMath.max(1, 10, 100);\n// @log: 100\n```\n\n残余引数は、引数受取時には配列になりますが、関数呼び出しのときにひとつの配列にまとめて渡すことはできません。\n\n```ts twoslash\n// @errors: 2345\nconst scores: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst highest = Math.max(scores);\n```\n\nこのように配列を直接渡してしまうと、`max`の関数内では引数ひとつの`number[][]`型が渡されたと解釈されます。`max`の期待する余剰引数の型は`number[]`型なので、このコードは正しく動きません。配列を余剰引数に渡す場合は、スプレッド構文(spread syntax)を用います。スプレッド構文は`...`と書きます。\n\n```ts twoslash\nconst scores: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst highest = Math.max(...scores);\n```\n\n残余引数もスプレッド構文も`...`と同じ表記ですが、スプレッド構文は配列を引数にバラすものです。\n",
      "url": "https://typescriptbook.jp/reference/functions/rest-parameters"
    },
    {
      "title": "this引数 (this parameter)",
      "content": "---\nsidebar_label: this引数\n---\n\n# this引数 (this parameter)\n\nアロー関数以外の関数とクラスのメソッドの第1引数は`this`という特殊な引数を受けることができます。これは使用するコンテキストによって`this`の意味するところが変わってしまうため、これらがどのコンテキストで使用されるべきなのかをTypeScriptに伝えるために使います。この`this`は呼び出す側は意識する必要はありません。第2引数以降を指定してください。\n\n```twoslash include main\nclass Male {\n  private name: string;\n\n  public constructor(name: string) {\n    this.name = name;\n  }\n\n  public toString(): string {\n    return `Monsieur ${this.name}`;\n  }\n}\n\nclass Female {\n  private name: string;\n\n  public constructor(name: string) {\n    this.name = name;\n  }\n\n  public toString(this: Female): string {\n    return `Madame ${this.name}`;\n  }\n}\n```\n\n```ts twoslash\n// @include: main\n```\n\n上記クラス`Male`、`Female`はほぼ同じ構造ですが`toString()`のメソッドの引数が異なります。\n\n`Male`、`Female`はともに普通の用途で使うことができます。\n\n```ts twoslash\n// @include: main\n// ---cut---\nconst male: Male = new Male(\"Frédéric\");\nconst female: Female = new Female(\"Frédérique\");\n\nmale.toString();\n// @log: Monsieur Frédéric\nfemale.toString();\n// @log: Madame Frédérique\n```\n\nですが各インスタンスの`toString()`を変数に代入すると意味が変わります。\n\n```ts twoslash\n// @errors: 2684\n// @include: main\nconst male: Male = new Male(\"Frédéric\");\nconst female: Female = new Female(\"Frédérique\");\n// ---cut---\nconst maleToStr: () => string = male.toString;\nconst femaleToStr: (this: Female) => string = female.toString;\n\nmaleToStr();\nfemaleToStr();\n```\n\n`femaleToStr()`のコンテキストが`Female`ではないとの指摘を受けています。このコードを実行することはできません。ちなみにこの対応をしていない`maleToStr()`は実行こそできますが実行時に例外が発生します。\n\n```js twoslash\nclass Male {\n  // ...\n  // prettier-ignore\n  toString() {\n// @error: TypeError: Cannot read property 'name' of undefined\n    return `Monsieur ${this.name}`;\n  }\n}\n```\n\n引数の`this`を指定することによって意図しないメソッドの持ち出しを避けることができます。\n",
      "url": "https://typescriptbook.jp/reference/functions/this-parameters"
    },
    {
      "title": "戻り値がない関数とvoid型 (void type)",
      "content": "---\nsidebar_label: 戻り値がない関数とvoid型\n---\n\n# 戻り値がない関数とvoid型 (void type)\n\nTypeScriptで戻り値がない関数の戻り値を型注釈するにはvoid型を用います。void型は関数の戻り値を型注釈するためにある特別な型です。\n\n```ts twoslash\nfunction print(message: string): void {\n  console.log(message);\n}\n```\n\nJavaScriptでは、戻り値がない関数を呼び出したとき、その関数から返る値は`undefined`です。\n\n```ts twoslash\nfunction fn() {\n  // 戻り値のない関数\n}\nconst result = fn();\nconsole.log(result);\n// @log: undefined\n```\n\nしかし、TypeScriptでは、このような戻り値がない関数の戻り値の型注釈には`void`を用いるのが一般的です。\n\n```ts twoslash\nfunction fn(): void {\n  // 戻り値のない関数\n}\n```\n\n## undefined型とvoid型の違い\n\nvoid型の代わりに、undefined型を関数の戻り値の型注釈に用いる書き方もできます。ただし、これは一般的な書き方ではありません。\n\n### 戻り値がundefinedのときはreturnが必須\n\n戻り値型がundefined型の場合は、`return`が無いとコンパイルエラーになります。この点はvoid型と異なる点です。\n\n```ts twoslash\n// @errors: 2355\nfunction fn(): undefined {}\n```\n\nこのコンパイルエラーは、`return`を加えることで解消しますが、戻り値を返さないことを意図するのであれば、`void`型を使うほうがよいです。\n\n```ts twoslash\nfunction fn(): undefined {\n  return;\n}\n```\n\n戻り値が`undefined`を含みうる関数の場合は、undefined型を含んだユニオン型を使うのが一般的です。\n\n```ts twoslash\nfunction getIfExists(numbers: number[], search: number): number | undefined {\n  if (numbers.includes(search)) {\n    return search;\n  }\n  return undefined;\n}\n```\n\n### voidはundefinedの上位型\n\nvoid型は関数戻り値の型注釈にだけ使うのが普通です。変数の型注釈に使うことはまずありません。しかし、もしも変数の型注釈にvoid型を使った場合、voidとundefinedは異なる型になります。undefined型はvoid型に代入できる一方、void型はundefined型に代入できません。これを一言でいうと、voidはundefinedの上位型(supertype)ということになります。\n\n```ts twoslash\n// @errors: 2322\nconst v: void = undefined; // undefined型はvoid型に代入できる\nconst u: undefined = v; // void型はundefined型に代入できない\n```\n\nこの特徴は、関数の誤用に気づくきっかけを与えてくれます。たとえば、次の2つの関数を考えてみましょう。どちらも戻り値なしを意図した関数です。処理内容も同じです。違いは、`f1`は型注釈が`void`ですが、`f2`は`undefined`です。\n\n```ts twoslash\nfunction f1(): void {}\nfunction f2(): undefined {\n  return;\n}\n```\n\nこれらの関数を呼び出すとき、戻り値を受け取るように書けるものの、これら関数の使い方としては正しくないでしょう。次のコードは、戻り値を変数に代入しようとしています。これは誤ったコードです。\n\n```ts twoslash\n// @noErrors\nfunction f1(): void {}\nfunction f2(): undefined {\n  return;\n}\n// ---cut---\nlet mayBeNumber: number | undefined;\nmayBeNumber = f1(); // 誤った関数の使い方\nmayBeNumber = f2(); // 誤った関数の使い方\n```\n\nこのとき、型注釈が`void`の`f1`の呼び出し部分はコンパイルエラーとなります。これにより、誤りに気づきやすくなります。\n\n```ts twoslash\n// @errors: 2322\nfunction f1(): void {}\nfunction f2(): undefined {\n  return;\n}\n// ---cut---\nlet mayBeNumber: number | undefined;\nmayBeNumber = f1(); // コンパイルで誤りに気づける\nmayBeNumber = f2(); // コンパイルでは誤りに気づけない\n```\n\nこのような観点からも、戻り値がない関数を宣言するときは`void`を使ったほうがよいわけです。\n",
      "url": "https://typescriptbook.jp/reference/functions/void-type"
    },
    {
      "title": "関数宣言と巻き上げ (hoisting)",
      "content": "---\nsidebar_label: 関数宣言と巻き上げ\n---\n\n# 関数宣言と巻き上げ (hoisting)\n\nJavaScriptの関数宣言と関数式の違いが現れるひとつの例は巻き上げ(hoisting)です。関数宣言には巻き上げがあり、関数式には巻き上げがありません。\n\nまずは関数宣言の例を見てみましょう。次のコードは、3行目に`hello`関数の関数宣言があります。そして、その宣言の前で`hello`関数を実行しています。\n\n```js twoslash\nhello();\n\nfunction hello() {\n  console.log(\"Hello World\");\n}\n```\n\nこのコードは、`hello`関数の定義行より前でその関数を呼び出しているのに、エラーにはならず問題なく\"Hello World\"が出力されます。これは関数宣言には巻き上げがあるためです。\n\n次に関数式の例を見てみましょう。下のコードは`hello`関数を関数式を使って定義するようにしたものです。\n\n```js twoslash\nhello();\n\nconst hello = function () {\n  console.log(\"Hello World\");\n};\n```\n\nこのコードをJavaScriptとして実行してみると、1行目で「ReferenceError: Cannot access 'hello' before initialization」というエラーが起こります。関数式で関数を定義した場合は巻き上げがないため、このようなエラーが発生します。\n\n以上のように、関数宣言と関数式には巻き上げの有無の違いがあります。関数式の場合は、関数定義と実行の順番を意識する必要が出てくるわけです。\n\nTypeScriptでは、定義前の関数を呼び出そうとするとコンパイラーが指摘してくれます。\n\n```ts twoslash\nhello();\n// @errors: 2448 2454\n\nconst hello = function () {};\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/function-declaration-and-hoisting"
    },
    {
      "title": "関数の型の宣言 (function type declaration)",
      "content": "---\nsidebar_label: 関数の型の宣言\n---\n\n# 関数の型の宣言 (function type declaration)\n\nTypeScriptでは、関数の型を宣言できます。関数の型の宣言とは、関数の実装を示さずに、関数のインターフェースを定義することです。\n\n## 関数の型宣言構文\n\n関数の型宣言は、[型エイリアス](../values-types-variables/type-alias.md)を用います。構文は次のようになります。\n\n```ts twoslash\ntype 引数の型 = any;\ntype 戻り値の型 = any;\n// ---cut---\ntype 型の名前 = (引数名: 引数の型) => 戻り値の型;\n```\n\nたとえば、number型を受け取りnumber型を返す関数の型宣言は次です。\n\n```ts twoslash\ntype Increment = (num: number) => number;\n```\n\n## 型宣言を型注釈で使う\n\n定義した関数の型宣言は、[アロー関数](./arrow-functions.md)の型注釈に使えます。\n\n```ts twoslash\ntype Increment = (num: number) => number;\n// ---cut---\nconst increment: Increment = (num: number): number => num + 1;\n//               ^^^^^^^^^型注釈\n```\n\n[関数式(function**式**)](./function-expression.md)の型注釈にも使えます。\n\n```ts twoslash\ntype Increment = (num: number) => number;\n// ---cut---\nconst increment: Increment = function (num: number): number {\n  return num + 1;\n};\n```\n\nしかし、[関数宣言(function**文**)](./function-declaration.md)の型注釈には使えません。\n\n## 関数実装の型注釈の省略\n\n関数の型宣言を型注釈に使った場合、関数の実装側の引数と戻り値の型注釈は省略できます。\n\n```ts twoslash\ntype Increment = (num: number) => number;\n// ---cut---\nconst f1: Increment = (num: number): number => num + 1;\n// ↓省略形\nconst f2: Increment = (num) => num + 1;\n```\n\n実際のコードでは、省略形で書くのが一般的です。\n\n## メソッド構文による関数の型宣言\n\nTypeScriptでは、アロー関数構文で関数の型を宣言する方法とは別に、メソッド構文でも関数の型を宣言できます。\n\n```ts twoslash title=\"メソッド構文\"\ntype 引数の型 = any;\ntype 戻り値の型 = any;\n// ---cut---\ntype 型の名前 = {\n  (引数名: 引数の型): 戻り値の型;\n};\n```\n\nアロー関数構文とメソッド構文は、書き方が異なるだけです。次の2つの型宣言は同じ型です。\n\n```ts twoslash\n// アロー関数構文による型宣言\ntype Increment1 = (num: number) => number;\n// メソッド構文による型宣言\ntype Increment2 = {\n  (num: number): number;\n};\n```\n\n一般的には、アロー関数構文で型宣言します。アロー関数構文のほうが短くシンプルだからです。\n\nメソッド構文による型宣言は、[オーバーロード関数](./overload-functions.md)の型宣言に使われることがあります。\n\n## 関数から関数の型を宣言する\n\nTypeScriptでは、関数の実装から関数の型を宣言できます。関数の値に対して[`typeof`型演算子](../type-reuse/typeof-type-operator.md)を使います。\n\n```ts twoslash\n// 関数の実装\nfunction increment(num: number): number {\n  return num + 1;\n}\n// 関数の型を宣言する\ntype Increment = typeof increment;\n//   ^?\n```\n\n<PostILearned>\n\n・TypeScriptでは関数の型が宣言できる\n例: type Func = (n: number) => number\n・定義した型は型注釈で使える\n・その場合、実装側の型注釈は省略可\n・メソッド風の型宣言もある\n・通常はアロー関数風の型宣言を使う\n・typeofで関数から型を導くこともできる\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/functions/function-type-declaration"
    },
    {
      "title": "関数宣言 (function declaration)",
      "content": "---\nsidebar_label: 関数宣言\n---\n\n# 関数宣言 (function declaration)\n\n関数宣言はJavaScriptで関数を定義する構文です。\n\n## 関数宣言構文\n\nJavaScriptの関数宣言はfunction構文を使います。\n\n```js twoslash\nfunction hello() {\n  return \"hello\";\n}\n```\n\n## 関数宣言構文の型注釈\n\nTypeScriptでは関数宣言の引数と戻り値に型注釈を書けます。\n\n```ts twoslash\nfunction increment(num: number): number {\n  return num + 1;\n}\n```\n\n引数の型注釈を省略した場合、コンパイラーは`any`型と暗黙的に解釈します。\n\n```ts twoslash\n// @noImplicitAny: false\nfunction increment(num): number {\n  //               ^?\n  return num + 1;\n}\n```\n\nコンパイラーオプションの`noImplicitAny`を`true`に設定することで、引数の型注釈を必須にできます。\n\n```ts twoslash\n// @noImplicitAny: true\n// @errors: 7006\nfunction increment(num): number {\n  return num + 1;\n}\n```\n\n[noImplicitAny](../tsconfig/noimplicitany.md)\n\n戻り値の型注釈を省略した場合、コンパイラーがコードから型推論します。\n\n```ts twoslash\nfunction increment(num: number) {\n  return num + 1;\n}\nconst value = increment(1);\n//            ^?\n```\n\n`return`が複数あり違う型を返している場合推論される型はユニオン型になります。\n\n```ts twoslash\nfunction getFirst(items: number[]) {\n  if (typeof items[0] === \"number\") {\n    return items[0];\n  }\n  return null;\n}\n\ngetFirst([1, 2, 3]);\n// ^?\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/function-declaration"
    },
    {
      "title": "アロー関数 (arrow function)",
      "content": "---\nsidebar_label: アロー関数\n---\n\n# アロー関数 (arrow function)\n\nアロー関数(arrow function)はJavaScriptの関数を作る方法のひとつです。\n\n## アロー関数の構文\n\nJavaScriptのアロー関数は短く書けるのが特徴的です。カッコに引数のリスト、アロー記号`=>`、中カッコに処理内容を書きます。\n\n```js twoslash\n(引数) => {\n  // 処理内容\n};\n```\n\nアロー関数は式です。式とは、評価した結果が値になるものを言います。アロー関数に関数名をつけるには、変数に代入します。\n\n```js twoslash\nconst 変数名 = (引数) => {\n  // 処理内容\n};\n```\n\nたとえば、次の[関数式](./function-expression.md)をアロー関数に書き直すと\n\n```js twoslash title=\"関数式で定義したincrement関数\"\nconst increment = function (n) {\n  return n + 1;\n};\n```\n\n次のようになります。\n\n```js twoslash title=\"アロー関数で定義したincrement関数\"\nconst increment = (n) => {\n  return n + 1;\n};\n```\n\n### アロー関数の省略形\n\nJavaScriptのアロー関数は、引数が1つだけの場合、引数のカッコが省略できます。\n\n```js twoslash\n// prettier-ignore\nconst increment = n => { /* ... */ };\n//                ^カッコの省略\n```\n\n引数がない場合は、引数のカッコは省略できません。\n\n```js twoslash title=\"引数がないアロー関数\"\nconst getOne = () => {\n  return 1;\n};\n```\n\nさらに、関数内のコードが式1つだけの場合は、中カッコ`{}`と`return`が省略できます。この省略形は簡潔文体(concise body)、非省略形はブロック文体(block body)と呼びわけます。\n\n```js twoslash\n// prettier-ignore\nconst increment = n => n + 1;\n//                     ^^^^^returnと中括弧の省略\n```\n\n戻り値が[オブジェクトリテラル](../values-types-variables/object/object-literal.md)の場合は要注意です。簡潔文体では、オブジェクトリテラルをカッコ`()`で囲む必要があります。\n\n```js twoslash\n// prettier-ignore\n(n) => { foo: n + 1 }; // 誤り\n(n) => ({ foo: n + 1 }); // 正しい\n```\n\nそうしないと、オブジェクトリテラルの開始と終了のつもりで書いた中カッコ`{}`は、ブロック文体の中カッコと解釈され、異なる処理になるからです。上の例では、`foo`はオブジェクトプロパティのキーではなく、ラベルとして扱われます。\n\n## アロー関数の型注釈\n\nTypeScriptのアロー関数では、引数に型注釈が書けます。\n\n```ts twoslash\nconst increment = (num: number) => num + 1;\n//                    ^^^^^^^^引数の型注釈\n```\n\n戻り値の型注釈も書けます。\n\n```ts twoslash\nconst increment = (num: number): number => num + 1;\n//                             ^^^^^^^^戻り値の型注釈\n```\n\n引数のカッコを省略した場合は、**引数と戻り値のどちらも型注釈を書けません。**\n\n<!--prettier-ignore-->\n```ts twoslash\n// @noImplicitAny: false\nconst increment = num => num + 1;\n```\n\n暗黙のanyを禁ずるコンパイラオプション`noImplicitAny`が有効の場合、引数カッコを省略したアロー関数がコンパイルエラーになる場合があります。\n\n<!--prettier-ignore-->\n```ts twoslash\n// @errors: 7006\nconst increment = num => num + 1;\n```\n\n[noImplicitAny](../tsconfig/noimplicitany.md)\n\n`noImplicitAny`が有効でも、引数の型が推論できる場合は、引数カッコが省略できます。たとえば、他の関数の引数にアロー関数を直接書く場合です。次の`map`関数は第1引数に関数を取ります。第1引数の型情報、引数の型がついているので、渡されるアロー関数の型注釈は省略できます。\n\n```ts twoslash\n[1, 2, 3].map((num) => num + 1); // 型注釈が省略可\n```\n\n<PostILearned>\n\n・JavaScriptのアロー関数は()=>{}のように短く書ける\n・引数が1つの場合、()は省略できる\n・処理が1行の場合、{}は省略できる(簡潔文体)\n・TypeScriptでは引数カッコ省略時に型注釈が書けない\n\n</PostILearned>\n\n## 関連情報\n\n[関数式とアロー関数の違い](function-expression-vs-arrow-functions.md)\n\n[関数宣言](./function-declaration.md)\n\n[関数式 (function expression)](function-expression.md)\n",
      "url": "https://typescriptbook.jp/reference/functions/arrow-functions"
    },
    {
      "title": "コールバック関数 (callback functions)",
      "content": "---\nsidebar_label: \"コールバック関数\"\n---\n\n# コールバック関数 (callback functions)\n\nコールバック関数とは、関数の引数として渡される関数です。関数の中で引数で指定した関数を呼び出す（コールバックする）ことで関数の振る舞いを制御したり、非同期な結果を受け取ることができます。\nコールバック関数という言語レベルの構文が存在する訳ではなく、設計パターンのひとつとしてコールバック関数と呼ばれています。\n\n## コールバック関数の使い方\n\n### 関数の振る舞いの制御\n\nコールバック関数はある関数の振る舞いの一部を外側から制御したい時に利用できます。\n\n`greetNewUser`は「ご新規さん」に挨拶をする関数です。\n`hello`関数と`goodMorning`関数をそれぞれコールバック関数として渡すことで、どのように挨拶するかの振る舞いを制御しています。\n\n```ts twoslash\nfunction greetNewUser(func: (name: string) => string) {\n  console.log(func(\"ご新規さん\"));\n}\n\nfunction hello(name: string) {\n  return `こんにちは！${name}さん！！`;\n}\n\nfunction goodMorning(name: string) {\n  return `おはようございます！${name}さん！！`;\n}\n\n// こんにちは！ご新規さん!!\ngreetNewUser(hello);\n\n// おはようございます！ご新規さん!!\ngreetNewUser(goodMorning);\n```\n\n### 非同期な結果の受け取り\n\nコールバック関数は非同期な関数の結果を受け取って処理をしたい場合にも利用できます。\n\n次の例はNode.jsのfsモジュールのファイル読み込みのサンプルコードです。\nファイルの読み込みが非同期で実行され、読み込みが完了した後にコールバック関数が呼ぶことで、非同期な読み込み結果を呼び出し側へ渡すことができます。\n\n```ts twoslash\nimport fs from \"fs\";\n\nfs.readFile(\"./user.txt\", \"utf-8\", (err, data) => {\n  if (err) {\n    console.error(err);\n  }\n  console.log(data);\n});\n```\n\n### コールバック関数地獄\n\n次のサンプルコードは\n\n1. Aファイルを読み込み\n2. Aファイルに記述されたBファイルを読み込む\n3. Bファイルに記述されたCファイルを読み込む\n\nという形でファイル読み込みをしています。\n\nこのようにコールバック関数の中でコールバック関数を呼び出すことでネストが深くなり、コードが読みづらくなる問題をコールバック地獄と呼びます。\n\n```ts twoslash\nimport fs from \"fs\";\n\nfs.readFile(\"./a.txt\", \"utf-8\", (err, data) => {\n  fs.readFile(data, \"utf-8\", (err, data) => {\n    fs.readFile(data, (err, data) => {\n      console.log(data);\n    });\n  });\n});\n```\n\nこのような場合には、コールバック関数を使用せずにPromiseを利用することで解消ができます。\n\nコールバック地獄の問題を解消するために、Promiseが登場して以降は非同期処理の結果を取得する場合には、コールバック関数を用いずにPromiseを利用することが一般的になっています。\n\n```ts twoslash\nimport { promises as fs } from \"fs\";\n\nfs.readFile(\"a.txt\", \"utf-8\")\n  .then((data) => fs.readFile(data, \"utf-8\"))\n  .then((data) => fs.readFile(data, \"utf-8\"))\n  .then((data) => console.log(data));\n```\n\n## コールバック関数の型定義\n\nコールバック関数の型は`(arg: [引数の型]) => [戻り値の型]`と記述します。\nコールバック関数はただの関数なので、引数の型として関数の型宣言をしているだけです。\n\n[関数の型宣言](./function-type-declaration.md)\n\n```ts twoslash\nfunction greetNewUser(func: (name: string) => string) {\n  console.log(func(\"ご新規さん\"));\n}\n```\n\n## 同期型と非同期型\n\n使い方の例でも見たように、コールバック関数には同期型と非同期型が存在します。\n\n### 同期型のコールバック関数\n\n同期型のコールバック関数は同期的にすぐに呼ばれるコールバック関数です。\n代表的な例としては、標準APIの`Array.map`の引数が同期型のコールバック関数を受け取ります。\n\n```ts twoslash\nconst numbers = [1, 2, 3];\nconst doubles = numbers.map((n: number) => {\n  return n * 2;\n});\n\n// 2, 4, 6\nconsole.log(doubles);\n```\n\n### 非同期型のコールバック関数\n\n非同期型のコールバック関数はAPIリクエストなど非同期に呼ばれるコールバック関数です。\n代表的な例としては、`setTimeout`の引数が非同期型のコールバック関数を受け取ります。\n\n次の例では、`setTimeout`に渡したコールバック関数が1秒後に非同期に呼ばれ、\n`hello`, `This is callback function!`の順番でコンソールに結果が表示されます。\n\n```ts twoslash\nsetTimeout(() => {\n  console.log(\"This is callback function!\");\n}, 1000);\n\nconsole.log(\"hello\");\n\n// hello\n// This is callback function!\n```\n\n### 同期型コールバック関数と非同期処理\n\n`Array.map`などの同期型コールバック関数にPromiseを返す非同期関数を渡した場合は、どうなるでしょうか？\n\n`doublePromise`は渡された値を2倍にする処理を非同期に実行して値を返す非同期関数です。\nこのとき`doublePromise`は非同期関数のため2倍した値ではなくPromiseを返すため、`doubles`はPromiseの配列となります。\n\n```ts twoslash\nfunction doublePromise(n: number): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(n * 2);\n    }, 100);\n  });\n}\n\nconst numbers = [1, 2, 3];\nconst doubles = numbers.map(doublePromise);\n\n// [Promise: {}, Promise: {}, Promise: {}]\nconsole.log(doubles);\n```\n\n同期型のコールバック関数に非同期関数を渡した場合は、Promiseの結果を解決するようにする必要があります。\n\n```ts twoslash\nfunction doublePromise(n: number): Promise<number> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(n * 2);\n    }, 100);\n  });\n}\n\n(async function () {\n  const numbers = [1, 2, 3];\n  const doubles = await Promise.all(numbers.map(doublePromise));\n\n  // [2, 4, 6]\n  console.log(doubles);\n})();\n```\n\n`Array.map`はコールバック関数として非同期関数も受け取るように型指定がされているため、型エラーは発生しません。\nコールバック関数の型指定が同期関数だけ受け取る場合は、非同期関数を渡した時に型エラーが発生します。\n\n```ts twoslash\n// @errors: 2345\n\ntype User = {\n  name: string;\n};\n\nfunction greetUser(getUser: () => User) {\n  const user = getUser();\n  console.log(`Hello, ${user.name}`);\n}\n\nfunction fetchUserFromDB(): Promise<User> {\n  return new Promise<User>((resolve) => {\n    setTimeout(() => {\n      resolve({ name: \"太郎\" });\n    }, 1000);\n  });\n}\n\ngreetUser(fetchUserFromDB);\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/callback-functions"
    },
    {
      "title": "関数はオブジェクト",
      "content": "# 関数はオブジェクト\n\nJavaScriptの関数はオブジェクトです。したがって、関数にプロパティを持たせることができます。\n\n```js twoslash\nfunction hello() {\n  return \"Hello World\";\n}\n\nhello.prop = 123;\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/function-is-an-object"
    },
    {
      "title": "オプション引数 (optional parameter)",
      "content": "---\nsidebar_label: オプション引数\n---\n\n# オプション引数 (optional parameter)\n\nオプション引数(optional parameter)は、渡す引数を省略できるようにするTypeScript固有の機能です。オプション引数は疑問符`?`を引数名の後ろに書くことで表現します。\n\n## オプション引数の構文\n\n```ts twoslash\ninterface 型 {}\n// ---cut---\n// @noImplicitAny: false\nfunction 関数名(引数名?: 型) {}\n//                  ^オプション引数の標示\n```\n\nオプション引数は、関数を呼び出すときに引数が省略できます。\n\n```ts twoslash\nfunction hello(person?: string) {}\nhello(); // 引数を省略して呼び出せる\nhello(\"alice\"); // 省略しない呼び出しももちろんOK\n```\n\n## 省略すると`undefined`になる\n\nオプション引数の型は、型と`undefined`の[ユニオン型](./../values-types-variables/union.md)になります。ユニオン型は日本語で言うと「いずれか」の意味です。上の例では、引数`person`は`string | undefined`型になります。\n\n```ts twoslash\nfunction hello(person?: string) {}\n//             ^?\n```\n\n引数を省略した場合、オプション引数の実行時の値は`undefined`になります。\n\n```ts twoslash\nfunction hello(person?: string) {\n  console.log(person);\n}\nhello();\n// @log: undefined\n```\n\n## オプション引数の取り回し\n\nオプション引数は、型が`undefined`とのユニオン型になるため、そのままでは使えません。たとえば、次のコードはstringの`toUpperCase`メソッドを呼び出すコードです。これはコンパイルエラーになります。なぜなら、`person`が`undefined`型である可能性があるからです。そして、`undefined`には`toUpperCase`メソッドがありません。\n\n```ts twoslash\n// @errors: 18048\nfunction hello(person?: string) {\n  return \"Hello \" + person.toUpperCase();\n}\n```\n\nこの問題を解消するには、次の2つの方法があります。\n\n### デフォルト値を代入する\n\n引数が`undefined`の場合分けを`if`文で書き、そこでデフォルト値を代入する方法です。\n\n```ts twoslash {2-4}\nfunction hello(person?: string) {\n  if (typeof person === \"undefined\") {\n    person = \"anonymous\";\n  }\n  return \"Hello \" + person.toUpperCase();\n}\n```\n\nNull合体代入演算子`??=`でデフォルト値を代入する方法もあります。\n\n```ts twoslash {2}\nfunction hello(person?: string) {\n  person ??= \"anonymous\";\n  return \"Hello \" + person.toUpperCase();\n}\n```\n\nさらに、デフォルト引数を指定することでも同じことができます。多くのケースでは、デフォルト引数を使うほうがよいです。\n\n```ts twoslash {1-2}\nfunction hello(person: string = \"anonymous\") {\n  //                          ^^^^^^^^^^^^^デフォルト引数\n  return \"Hello \" + person.toUpperCase();\n}\n```\n\n[デフォルト引数](./default-parameters.md)\n\n### 処理を分ける\n\nオプション引数を取り回すもうひとつの方法は、処理を分けることです。\n\n```ts twoslash {2-4}\nfunction hello(person?: string) {\n  if (typeof person === \"undefined\") {\n    return \"Hello ANONYMOUS\";\n  }\n  return \"Hello \" + person.toUpperCase();\n}\n```\n\n## `T | undefined`との違い\n\nオプション引数はユニオン型`T | undefined`として解釈されます。であれば、引数の型を`T | undefined`と書けば同じなはずです。なぜTypeScriptは、疑問符`?`という別の記法を用意したのでしょうか。違いがあるのでしょうか。\n\nこれには呼び出す側で、**引数を省略できるかどうかという違い**が生まれます。オプション引数は引数自体を省略できますが、`T | undefined`型の引数は引数が省略できません。\n\nたとえば、次のオプション引数の関数は引数なしで呼び出せます。\n\n```ts twoslash\nfunction hello(person?: string) {}\nhello(); // 引数を省略して呼び出せる\n```\n\n一方、次のような`undefined`とのユニオン型の引数は、引数なしではコンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2554\nfunction hello(person: string | undefined) {}\nhello();\n```\n\nこの関数を呼び出すためには、`undefined`を渡す必要があります。\n\n```ts twoslash {2}\nfunction hello(person: string | undefined) {}\nhello(undefined);\n```\n\n## オプション引数の後に普通の引数は書けない\n\nオプション引数は必ず最後に書かなければいけません。次のようにオプション引数より後ろに普通の引数を書くと、コンパイルエラーになります。\n\n```ts twoslash\n// @errors: 1016\nfunction func(foo?: string, bar: string) {}\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/optional-parameters"
    },
    {
      "title": "キーワード引数とOptions Objectパターン",
      "content": "# キーワード引数とOptions Objectパターン\n\nJavaScriptやTypeScriptの関数には、Pythonにあるキーワード引数のような機能はありません。その代わり、分割代入引数を応用することで、キーワード引数と同じようなことができます。\n\n## キーワード引数とは\n\nキーワード引数(keyword argument)は、Pythonの機能です。関数呼び出し時に、値だけを指定するのではなく、引数名を使って「名前=値」の形式で引数を指定する方法です。\n\n```python\n# Pythonコード\ndef func(x, y, z):\n    print(x, y, z)\n\nfunc(x=1, y=2, z=3)  # => 1 2 3\n```\n\nキーワード引数と同じような機能はRubyや、Scalaの名前付き引数(named argument)などに見られます。JavaScriptやTypeScriptにはキーワード引数に相当する機能はありません。\n\nキーワード引数の仕様上の特徴は、位置引数(positional argument)と異なり、関数呼び出し側が引数の順番を自由に変えられるところです。\n\n```python\n# Pythonコード\nfunc(z=3, y=2, x=1)  # => 1 2 3\n```\n\n## Options Objectパターン\n\nJavaScriptやTypeScriptにはキーワード引数のような言語仕様はありませんが、Options Objectパターンというデザインパターンで似たようなことができます。Options Objectパターンは複数の位置引数を受け取る代わりに、ひとつのオブジェクトを引数に受け取るように設計された関数を言います。\n\n```js twoslash\n// 位置引数の関数\nfunction normalFunc(x, y, z) {\n  console.log(x, y, z);\n}\n\n// オブジェクトひとつだけを引数に持つ関数\nfunction func(options) {\n  console.log(options.x, options.y, options.z);\n}\n\nfunc({ x: 1, y: 2, z: 3 });\n// @log: 1 2 3\n```\n\nさらに、Options Objectパターンでは分割代入引数を応用すると、引数の部分をよりシンプルに書けるようになります。\n\n```js twoslash\nfunction func({ x, y, z }) {\n  console.log(x, y, z);\n}\n```\n\n[分割代入引数 (destructuring assignment parameter)](destructuring-assignment-parameters.md)\n\n## Options Objectパターンの型注釈\n\nTypeScriptでOptions Objectパターンを使うときには、引数の型注釈が必要になります。型注釈はオブジェクトの型を書きます。\n\n```ts twoslash\nfunction func({ x, y, z }: { x: number; y: number; z: number }) {\n  // ...\n}\n```\n\nオブジェクトの型の記述が長すぎる場合には、TypeScriptの型エイリアス(type alias)を用いて、引数の型を分けて書くと可読性が良くなります。\n\n```ts twoslash\ntype Options = {\n  x: number;\n  y: number;\n  z: number;\n};\n\nfunction func({ x, y, z }: Options) {\n  // ...\n}\n```\n\n## Options Objectパターンの利点\n\nOptions Objectパターンの利点は次の3つがあります。\n\n- 引数の値が何を指すのか分かりやすい\n- 引数追加時に古いコードを壊さない\n- デフォルト引数が省略できる\n\n### 引数の値が何を指すのか分かりやすい\n\n位置引数3つを持つような関数の呼び出しコードには分かりにくさがあります。\n\n```ts twoslash\ndeclare function findProducts(\n  isSale: boolean,\n  withDetails: boolean,\n  freeShipping: boolean\n): void;\n// ---cut---\nfindProducts(true, true, true);\n```\n\n`true`が3つ並んでいますが、それが何を指すのかは、これを見ただけでは分かりません。それを知るには関数の実装を見に行く必要があります。また、引数の順番を間違えやすいという問題もあります。\n\nOptions Objectパターンの場合、関数呼び出しコードを見ただけで、引数の意味が理解できます。引数名が際立つため、誤って引数を入れ替えてしまう心配が少ないです。\n\n```ts twoslash\ndeclare function findProducts({\n  isSale,\n  withDetails,\n  freeShipping,\n}: {\n  isSale: boolean;\n  withDetails: boolean;\n  freeShipping: boolean;\n}): void;\n// ---cut---\nfindProducts({ isSale: true, withDetails: true, freeShipping: true });\n```\n\n### 引数追加時に古いコードを壊さない\n\n位置引数の関数は変更に弱い側面があります。たとえば、ユーザーを検索する関数を実装したとします。最初の要件は国と都市でユーザーを絞り込めること、そして、ユーザー属性でソートできることだったとします。その場合、次のような実装をすれば要件は満たせます。\n\n```ts twoslash\nclass User {}\n\ndeclare function findUsers(\n  country: string,\n  city: string,\n  order: string,\n  sort: string\n): Promise<User[]>;\n// ---cut---\nfindUsers(\"JP\", \"Tokyo\", \"id\", \"asc\");\n```\n\nその後、年齢の範囲でも絞り込みたいという要望が出てきたとします。年齢範囲を指定できる引数を追加する必要があります。この場合、2つの選択肢があります。1つ目は、呼び出し側のコードを壊さないよう、引数の最後に年齢範囲を追加することです。\n\n```js\nfunction findUsers(country, city, order, sort, ageMin, ageMax);\n//                                             ^^^^^^^^^^^^^^追加\n```\n\nこの場合、並び順指定のorderとsortが絞り込み条件のcityとageMinに挟まれる形となります。これはあまりキレイな引数の並びではありません。\n\n2つ目の方法は、呼び出し側のコードを壊す代わりに、引数の並びはキレイに保つ方法です。絞り込み条件は前方に、並び順指定は後方に配置します。\n\n```js\nfunction findUsers(country, city, ageMin, ageMax, order, sort);\n//                                ^^^^^^^^^^^^^^^追加\n```\n\nこの場合、呼び出し側コードは修正を余儀なくされます。\n\nOptions Objectパターンを用いれば、呼び出し元コードを壊さずに、追加引数を適切な位置に足せます。変更前の関数の実装と、その呼び出しコードは次のようになります。\n\n```ts twoslash\nclass User {}\n\ndeclare function findUsers({\n  country,\n  city,\n  order,\n  sort,\n}: {\n  country: string;\n  city: string;\n  order: string;\n  sort: string;\n}): Promise<User[]>;\n// ---cut---\nfindUsers({ country: \"JP\", city: \"Tokyo\", order: \"id\", sort: \"asc\" });\n```\n\nこれに年齢範囲を追加した場合、関数定義の引数の位置はふさわしいところに置けます。\n\n```ts twoslash\nclass User {}\n\ndeclare function findUsers({\n  country,\n  city,\n  order,\n  sort,\n  ageMin,\n  ageMax,\n}: {\n  country: string;\n  city: string;\n  order: string;\n  sort: string;\n  ageMin: number;\n  ageMax: number;\n}): Promise<User[]>;\n// ---cut---\nfindUsers({\n  country: \"JP\",\n  city: \"Tokyo\",\n  ageMin: 10,\n  ageMax: 20,\n  order: \"id\",\n  sort: \"asc\",\n});\n```\n\n加えて、関数呼び出し側のコードは変更する必要がありません。\n\n### デフォルト引数が省略できる\n\n位置引数を採用した関数では、場合によってはデフォルト引数が省略できません。たとえば、デフォルト引数を持つ位置引数3つを持つ関数で、1番目を2番目をデフォルトにしたい場合、それぞれに`undefined`を書く必要があります。\n\n```js twoslash\nfunction findProducts(\n  isSale = false,\n  withDetails = false,\n  freeShipping = false\n) {\n  console.log(isSale, withDetails, freeShipping);\n}\n\nfindProducts(undefined, undefined, true);\n// @log: false false true\n```\n\nOptions Objectパターンを用いた場合は、デフォルトにしたい引数については何も書く必要がありません。\n\n```js twoslash\nfunction findProducts({\n  isSale = false,\n  withDetails = false,\n  freeShipping = false,\n}) {\n  console.log(isSale, withDetails, freeShipping);\n}\n\nfindProducts({ freeShipping: true });\n// @log: false false true\n```\n\n## 引数名を変更する方法\n\n位置引数の利点は引数名の変更に強いことです。関数呼び出し側を壊すことなく、関数宣言側の引数名を自由に変更できます。たとえば、`function func(hoge) {}`の`hoge`を`fuga`に変更したとしても、呼び出し側のコードには影響がありません。\n\n引数名の指定を必要とするOptions Objectパターンでは、引数名の変更が呼び出し側コードに影響を及ぼします。たとえば、`function func({ hoge }) {}`の`hoge`を`fuga`に変更した場合、呼び出し側の`func({ hoge: 123 })`も`func({ fuga: 123 })`に変更しなければなりません。\n\nOptions Objectパターンの引数名変更問題を解決するには、分割代入の異なる引数名への代入機能を遣います。上の例でいうと、関数宣言側を`function func({ hoge })`に変更する代わりに`function func({ hoge: fuga })`のようにします。\n\n```js twoslash\nfunction func({ hoge: fuga }) {\n  console.log(fuga);\n}\n\nfunc({ hoge: 123 });\n// @log: 123\n```\n\nすると、関数呼び出し側は古い変数名`hoge`を渡すやり方から変えなくても動作するようにできます。関数の実装は、新しい変数名`fuga`が使えます。\n\n## デフォルト引数の型注釈\n\nTypeScriptでOptions Objectにデフォルト引数をもたせたい場合は、引数名のところにデフォルト値を書いた上で、オブジェクトの型注釈にてオプションプロパティを指定する`?`を書きます。\n\n```ts twoslash\nfunction func({ x, y = 0, z = 0 }: { x: number; y?: number; z?: number }) {\n  console.log(x, y, z);\n}\n\nfunc({ x: 1, y: undefined });\n// @log: 1 0 0\n```\n\n## Option Object自体をオプショナルにする方法\n\nTypeScriptでOptions Object自体を渡さなくても関数を呼び出せるようにするには、Options Objectのデフォルト値として空のオブジェクト`{}`を指定するとできます。\n\n```ts twoslash\ntype Options = {\n  x?: number;\n  y?: number;\n  z?: number;\n};\n\nfunction func({ x = 0, y = 0, z = 0 }: Options = {}) {\n  console.log(x, y, z);\n}\n\nfunc();\n// @log: 0 0 0\n```\n\n<PostILearned>\n\n・Pythonのキーワード引数相当の構文はJavaScript/TypeScriptにはない\n・代わりにOptions Objectパターンが使える\n・このパターンのメリット:\n①引数の値が何を指すのか分かりやすい\n②引数追加時に古いコードを壊さない\n③デフォルト引数が省略できる\n\n</PostILearned>\n\n## 関連情報\n\n[Partial&lt;T>](../type-reuse/utility-types/partial.md)\n",
      "url": "https://typescriptbook.jp/reference/functions/keyword-arguments-and-options-object-pattern"
    },
    {
      "title": "オーバーロード関数 (overload function)",
      "content": "---\nsidebar_label: オーバーロード関数\n---\n\n# オーバーロード関数 (overload function)\n\nオーバーロード関数(overload function)は、TypeScriptの機能で、ひとつの関数に異なる関数シグネチャを複数もつ関数です。関数シグネチャとは、どのような引数を取るか、どのような戻り値を返すかといった関数の型のことです。要するに、異なる引数や戻り値のパターンがいくつかある関数をオーバーロード関数と言います。\n\n## オーバーロード関数の文法\n\nTypeScriptでは、オーバーロード関数は、関数シグネチャと実装の2つの部分に分けて書きます。\n\n```ts twoslash\n// 関数シグネチャ部分\nfunction hello(person: string): void; // シグネチャ1\nfunction hello(persons: string[]): void; // シグネチャ2\n// 関数の実装部分\nfunction hello(person: string | string[]): void {\n  if (typeof person === \"string\") {\n    console.log(`Hello ${person}`);\n  } else {\n    console.log(`Hello ${person.join(\",\")}`);\n  }\n}\n```\n\n関数シグネチャの部分は、オーバーロードのパターン数だけ複数書きます。この部分はインターフェースを定義するところなので、関数のボディは書けません。\n\n関数の実装部分は、オーバーロードの全パターンを網羅する関数を書きます。ありうる引数の数や型のパターンを網羅したものになります。ロジックも分岐などを用いて、パターンごとの処理を書く必要があります。\n\n関数シグネチャと実装部分の関数名は同じにする必要があります。\n\nオーバーロード関数の文法を一般化すると次のようになります。\n\n```js\nfunction 関数名 関数シグネチャ1\nfunction 関数名 関数シグネチャ2\nfunction 関数名 すべてのシグネチャを網羅する実装\n```\n\n## オーバーロード関数のコンパイル結果\n\nオーバーロード関数はTypeScriptからJavaScriptにコンパイルすると、関数シグネチャ部分と型注釈が消され、次のようなコードになります。\n\n```ts twoslash title=\"コンパイル後のJavaScript\"\n// @showEmit\n// @target: esnext\n// @alwaysStrict: false\nfunction hello(person: string): void;\nfunction hello(persons: string[]): void;\nfunction hello(person: string | string[]): void {\n  if (typeof person === \"string\") {\n    console.log(`Hello ${person}`);\n  } else {\n    console.log(`Hello ${person.join(\",\")}`);\n  }\n}\n```\n\n## なぜJavaのようなオーバーロードではないのか？\n\nオーバーロードは他の言語にもあります。たとえば、Javaを始めとするJVM言語、C#、Swiftなどです。これらの言語のオーバーロードを知っていると、TypeScriptのオーバーロードは独特に思えるかもしれません。\n\n他の言語のオーバーロードの書き方は、シグネチャごとに実装が書けます。たとえば、JVM言語のひとつのKotlinでは、次のように書けます。TypeScriptと比べると、シグネチャごとに実装が別れていて、if分岐もなく、読みやすいのではないでしょうか。\n\n```kotlin title=\"Kotlinのオーバーロード関数\"\nfun hello(person: String) {\n  println(\"Hello $person\")\n}\n\nfun hello(persons: Array<String>) {\n  println(\"Hello ${persons.joinToString(\",\")}\")\n}\n```\n\nでは、なぜTypeScriptは、このような書き方を採用しなかったのでしょうか。理由として、JavaScriptにオーバーロードがない点が挙げられます。\n\nTypeScriptで書いたコードは「型に関する部分を消したらJavaScriptになる」というのがTypeScriptの基本方針です。このおかげで、開発者はTypeScriptコードが意図したJavaScriptにコンパイルされたかを確認する必要がなく、TypeScriptコードを見るだけでJavaScriptコードが予測できるという利点があります。\n\nもしも、Javaのようなオーバーロードを採用すると、JavaScriptにオーバーロードがない以上、どの関数を呼ぶかといった解決ロジックをTypeScriptがコンパイル時に生成しなければなりません。そうなると、TypeScriptの基本方針から大きく外れてしまいます。ソースコードからの予測可能性も下がります。こうしたことから、TypeScriptのオーバーロードは関数シグネチャ定義にとどめていると見られます。\n\n## アロー関数とオーバーロード\n\nオーバーロード関数の構文が用意されているのは関数宣言だけです。アロー関数にはオーバーロードの構文がありません。アロー関数でオーバーロード関数を作るには、関数呼び出しシグネチャで型注釈する必要があります。\n\n```ts twoslash\n// 関数呼び出しシグネチャでHello型を定義\ntype Hello = {\n  (person: string): void;\n  (persons: string[]): void;\n};\n// Hello型で型注釈\nconst hello: Hello = (person: string | string[]): void => {\n  if (typeof person === \"string\") {\n    console.log(`Hello ${person}`);\n  } else {\n    console.log(`Hello ${person.join(\",\")}`);\n  }\n};\n```\n\n関数呼び出しシグネチャ以外に、関数型(function type)とインターセクション型を用いる方法もあります。\n\n```ts twoslash {1-2}\n// 関数型とインターセクション型を用いてHello型を定義\ntype Hello = ((person: string) => void) & ((persons: string[]) => void);\nconst hello: Hello = (person: string | string[]): void => {\n  if (typeof person === \"string\") {\n    console.log(`Hello ${person}`);\n  } else {\n    console.log(`Hello ${person.join(\",\")}`);\n  }\n};\n```\n\n## 関数シグネチャは詳しい順に書く\n\nオーバーロードの関数シグネチャは順番が重要になります。TypeScriptは関数シグネチャを上から順に試していき、最初にマッチしたシグネチャを採用します。そのため、より詳しい関数シグネチャが上に、詳しくないものが下に来るように書き並べなければなりません。詳しいとは、引数の型の範囲が狭いという意味です。たとえば、`number`より`1 | 2`のほうが狭い型です。`any`は`number`より広い型です。\n\n```ts twoslash\nfunction func(param: 1 | 2): 1 | 2; // 詳しい関数\nfunction func(param: number): number; // そこそこ詳しい関数\nfunction func(param: any): any; // 詳しくない関数\nfunction func(param: any): any {\n  // ...\n}\nconst result1 = func(1);\n//    ^?\nconst result2 = func(100);\n//    ^?\nconst result3 = func(\"others\");\n//    ^?\n```\n\n次の誤りのように、詳しい関数を下のほうに書いてしまうと、詳しい関数がまったく採用されなくなります。\n\n```ts twoslash title=\"誤り:シグネチャの順番が間違っている\"\nfunction func(param: any): any; // 詳しくない関数。採用される\nfunction func(param: 1 | 2): 1 | 2; // 詳しい関数。採用されない\nfunction func(param: any): any {\n  // ...\n}\nconst result = func(1);\n//     ^?\n```\n\n## オーバーロード以外も検討しよう\n\nオーバーロード関数以外の方法を使ったほうがいい場合もあります。\n\n### 代わりにオプション引数を使う\n\n引数の数が違うだけの場合、オーバーロードより[オプション引数](./optional-parameters.md)を使ったほうがよいです。たとえば、次のようなオーバーロード関数は、[strictNullChecks](../tsconfig/strictnullchecks.md)が有効な場合、第2引数に`undefined`が渡せません。\n\n```ts twoslash title=\"オーバーロードを使う例\"\n// @strictNullChecks: true\n// @errors: 2345\nfunction func(one: number): void;\nfunction func(one: number, two: number): void;\nfunction func(one: number, two?: number): void {}\nfunc(1, undefined);\n```\n\nこれは次のように[オプション引数](./optional-parameters.md)を使うだけにとどめたほうがよいです。\n\n```ts twoslash title=\"オプション引数を使う例\"\n// @strictNullChecks: true\nfunction func(one: number, two?: number): void {}\nfunc(1, undefined);\n```\n\n### 代わりにユニオン型を使う\n\n引数の型だけが異なる場合は、[ユニオン型](../values-types-variables/union.md)を使ったほうがシンプルです。\n\n```ts twoslash title=\"オーバーロードを使う例\"\nfunction func(x: string): void;\nfunction func(x: number): void;\nfunction func(x: string | number) {}\n```\n\n```ts twoslash title=\"ユニオン型を使う例\"\nfunction func(x: string | number) {}\n```\n\n### 代わりにジェネリクスを使う\n\n引数の型と戻り値の型に一定の対応関係がある場合は、[ジェネリクス](../generics/README.md)を使ったほうがシンプルになる場合があります。\n\n```ts twoslash title=\"オーバーロードを使う例\"\nfunction func(x: boolean): boolean;\nfunction func(x: number): number;\nfunction func(x: string): string;\nfunction func(x: boolean | string | number): boolean | string | number {\n  return x;\n}\n```\n\n```ts twoslash title=\"ジェネリクスを使う例\"\nfunction func<T extends boolean | number | string>(x: T): T {\n  return x;\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/functions/overload-functions"
    },
    {
      "title": "分割代入引数 (destructuring assignment parameter)",
      "content": "---\nsidebar_label: \"分割代入引数\"\n---\n\n# 分割代入引数 (destructuring assignment parameter)\n\nJavaScriptでは分割代入構文は関数の引数でも使えます。引数がオブジェクトや配列の場合、そのオブジェクトや配列の一部だけを関数で利用したい場合に、分割代入引数が便利です。\n\n## 分割代入引数の構文\n\nJavaScriptでは、オブジェクトの分割代入引数の構文は中カッコ中に、オブジェクトのプロパティ名を書きます。引数名はプロパティ名と一致する必要があります。\n\n```js twoslash\nfunction foo({ a, b }) {\n  console.log(a, b);\n}\nfoo({ a: 1, b: 2, c: 3 });\n// @log: 1 2\n```\n\nプロパティ名を別の引数名で受け取るには、`:`の後に引数名を指定します。\n\n```js twoslash\nfunction foo({ a: x, b: y }) {\n  console.log(x, y);\n}\nfoo({ a: 1, b: 2 });\n// @log: 1 2\n```\n\n配列の分割代入引数は、カギカッコの中に配列要素を代入する変数名を書きます。配列要素に対応する引数名は自由に決められます。\n\n```js twoslash\nfunction bar([a, b]) {\n  console.log(a, b);\n}\nbar([1, 2, 3]);\n// @log: 1 2\n```\n\n分割代入引数はアロー関数でも使えます。\n\n```js twoslash\nconst foo = ({ a, b }) => {};\nconst bar = ([a, b]) => {};\n```\n\n## 分割代入引数の型注釈\n\nTypeScriptでオブジェクトを分割代入する場合、分割代入引数の右にオブジェクトの型注釈を書きます。\n\n```ts twoslash\nfunction foo({ a, b }: { a: number; b: number }) {}\n//                   ^^^^^^^^^^^^^^^^^^^^^^^^^^型注釈\n```\n\n配列を分割代入する場合も、分割代入引数の右に配列型の型注釈を書きます。\n\n```ts twoslash\n// @noUncheckedIndexedAccess: false\nfunction bar([num1]: number[]) {}\n//            ^?\n```\n\n型注釈が配列型の場合、コンパイラオプション`noUncheckedIndexedAccess`を有効にした場合、分割代入引数は`undefined`とのユニオン型になります。\n\n```ts twoslash\n// @noUncheckedIndexedAccess: true\nfunction bar([num1]: number[]) {}\n//            ^?\n```\n\n[noUncheckedIndexedAccess](../tsconfig/nouncheckedindexedaccess.md)\n\n配列の分割代入引数の型注釈をタプル型にすると、`noUncheckedIndexedAccess`が有効な場合でも、`undefined`とのユニオン型にはなりません。\n\n```ts twoslash\n// @noUncheckedIndexedAccess: true\nfunction bar([num1, num2]: [number, number]) {}\n//            ^?\n```\n\n## 既定値とコンパイルエラー\n\nJavaScriptでは、分割代入引数に対応するオブジェクトプロパティや配列要素が無い場合、`undefined`が代入されます。\n\n```js twoslash\nfunction foo({ a }) {\n  console.log(a);\n}\nfunction bar([a]) {\n  console.log(a);\n}\nfoo({});\n// @log: undefined\nbar([]);\n// @log: undefined\n```\n\n一方、TypeScriptでは分割代入引数に対応するオブジェクトプロパティや配列要素が無いと、コンパイルエラーになります。\n\n```ts twoslash\n// @errors: 2345\nfunction foo({ a }: { a: number }) {}\nfunction bar([a]: [number]) {}\nfoo({});\nbar([]);\n```\n\n## 分割代入引数のデフォルト引数\n\nJavaScriptで分割代入引数のデフォルト引数を指定する場合、引数名の後に`=`と既定値を書きます。\n\n```js twoslash\nfunction foo({ a = 0 }) {\n  //             ^^^既定値の指定\n  console.log(a);\n}\nfunction bar([a = 0]) {\n  //            ^^^既定値の指定\n  console.log(a);\n}\nfoo({});\n// @log: 0\nbar([]);\n// @log: 0\n```\n\nTypeScriptでデフォルト引数を型注釈する場合、オブジェクトではプロパティを`?`でオプションにします。\n\n```ts twoslash\nfunction foo({ a = 0 }: { a?: number | string }) {}\n//             ^?\n```\n\nプロパティの既定値からプロパティの型が予想できる場合、型注釈を省略できる場合もあります。\n\n```ts twoslash\nfunction foo({ a = 0 }) {}\n//             ^?\n```\n\n## 分割代入引数の全体の既定値\n\n分割代入引数の全体の既定値を指定する場合、分割代入構文の後に`=`と既定値を書きます。この既定値は、引数全体が無い、または、`undefined`の場合に採用されます。\n\n```js twoslash\nfunction foo({ a, b } = { a: 0, b: 0 }) {\n  console.log(a, b);\n}\nfoo();\n// @log: 0 0\nfoo({ a: 1 });\n// @log: 1 undefined\n\nfunction bar([a, b] = [0, 0]) {\n  console.log(a, b);\n}\nbar();\n// @log: 0 0\nbar([1]);\n// @log: 1 undefined\n```\n\nTypeScriptでは、引数全体の既定値は型注釈の後に書きます。\n\n```ts twoslash\n//                ................型注釈の位置\nfunction foo({ a }: { a?: number } = { a: 0 }) {}\n//                                 ^^^^^^^^^^既定値の位置\n```\n\n各プロパティの既定値と引数全体の既定値の両方を指定することもできます。この場合、引数全体を省略すると、各プロパティの既定値が使われます。\n\n```ts twoslash\ntype Obj = { a?: number; b?: number };\nfunction foo({ a = 0, b = 0 }: Obj = {}) {\n  console.log(a + b);\n}\nfoo();\n// @log: 0\nfoo({});\n// @log: 0\nfoo({ a: 1 });\n// @log: 1\nfoo({ a: 1, b: 2 });\n// @log: 3\n```\n\n## 呼び出し時のプロパティ名の省略\n\nJavaScriptでは、分割代入引数の引数名と同じ変数が定義済みであれば、オブジェクトリテラルのプロパティ名を省略し、変数だけ渡すことができます。\n\n```ts twoslash\nfunction bmi({ height, weight }: { height: number; weight: number }) {}\n\n// プロパティ名と同じ変数\nconst height = 170;\nconst weight = 65;\n\n// プロパティ名を省略しない呼び出し\nbmi({ height: height, weight: weight });\n\n// プロパティ名を省略した呼び出し\nbmi({ weight, height });\n```\n\n[Shorthand property names](../values-types-variables/object/shorthand-property-names.md)\n\n<PostILearned>\n\n・分割代入引数は関数でobjectや配列を部分的に使うときに便利\n・objectは中カッコで引数を書く\n→ function foo({ a, b })\n・配列はカギカッコで引数を書く\n→ function foo([a, b])\n・型注釈は分割代入の後に書く\n・既定値も指定可\n→ function foo({ a = 0})\n\n</PostILearned>\n\n## 関連情報\n\n[オブジェクトの分割代入](../values-types-variables/object/destructuring-assignment-from-objects.md)\n\n[配列の分割代入](../values-types-variables/array/destructuring-assignment-from-array.md)\n",
      "url": "https://typescriptbook.jp/reference/functions/destructuring-assignment-parameters"
    },
    {
      "title": "即時実行関数式 (IIFE)",
      "content": "---\nsidebar_label: \"即時実行関数式(IIFE)\"\n---\n\n# 即時実行関数式 (IIFE)\n\nIIFE (Immediately Invoked Function Expression; 即時実行関数式) とは定義と同時に実行される関数です。\nデザインパターンの1種で、Self-Executing Anonymous Function; 自己実行匿名関数とも呼ばれます。\n\nTypeScriptにおいては、次のように定義、使用します。\n\n```typescript\n(() => {\n  console.log(\"IIFE\");\n})();\n\nconst result1 = (function (arg: string) {\n  console.log(`IIFE with args:${arg}`);\n  return \"IIFE with args\";\n})(\"hoge\");\n\nconst result2 = await(async () => {\n  console.log(\"async IIFE\");\n  return \"async IIFE\";\n})();\n```\n\n## TypeScriptでの利用シーン\n\n### ReactのuseEffectなど、非同期関数を受け取らない引数に非同期処理を渡したい場合\n\nReactのuseEffectなど、非同期関数を受け取らない引数に非同期処理を渡したい場合、即時実行関数を使うことで、非同期処理を引数に渡すことができます。\n\n```ts twoslash\nfunction useEffect(f: () => void, args: string[]) {}\n// ---cut---\nuseEffect(() => {\n  (async () => {\n    const result = await fetch(\"https://example.com\");\n    console.log(result);\n  })();\n}, []);\n```\n\nただし、実行は非同期で実行されることに注意してください。戻り値としてvoidではなく、何らかの具体値を返す関数には適用できません。\n\n```ts twoslash\n// @errors: 2322\nfunction receivesSyncFunc(func: () => string) {\n  console.log(func());\n}\n\n// NG\nreceivesSyncFunc((): string => {\n  // Promise<string>が戻り値となってしまい、利用不可\n  return (async () => {\n    return \"hoge\";\n  })();\n});\n```\n\n### ifやswitchなどを式として扱いたい場合\n\nTypeScriptでのifやswitchは構文であり式ではないため、判定結果を変数に代入することができません。そのため、疑似的にifやswitchを式として扱うときにIIEFを利用できます。<br />\nまた、ifやswitchの条件判定が複雑になった場合に、判定に利用する変数や、どこまでが判定処理かを明確にできるため可読性が向上します。\n\n```typescript\nconst result = ((type: string) => {\n  if (type === \"Apple\") {\n    return \"林檎\";\n  } else if (type === \"Orange\") {\n    return \"オレンジ\";\n  } else {\n    return \"謎の果物\";\n  }\n})(fruit.type);\n```\n\nもしIIFEを使わない場合は次のような実装となります。\n\n```typescript\nlet result;\nconst type = fruit.type;\nif (type === \"Apple\") {\n  result = \"林檎\";\n} else if (type === \"Orange\") {\n  result = \"蜜柑\";\n} else {\n  result = \"謎の果物\";\n}\n```\n\nこの場合、constではなくletを使う必要があるため、変数の再代入のリスクが発生してしまいます。\n\n### スコープ内での変数汚染を防ぐ\n\n汎用的な変数の場合、同じスコープ内で複数回使いたい場合があるかと思います。\nその際に、IIFEを利用することで変数名のスコープを限定し名前の重複を回避できます。\n\n```typescript\nasync function callApiAAndB() {\n  await (async () => {\n    const result = await fetch(\"api1\");\n    if (result !== \"OK\") {\n      console.log(result);\n    }\n  })();\n  await (async () => {\n    const result = await fetch(\"api2\");\n    if (result !== \"Success\") {\n      console.log(result);\n    }\n  })();\n}\n```\n\n## 参考\n\n[MDN - IIFE (即時実行関数式)](https://developer.mozilla.org/ja/docs/Glossary/IIFE)\n[MDN Self-Executing Anonymous Function](https://developer.mozilla.org/ja/docs/Glossary/Self-Executing_Anonymous_Function)\n",
      "url": "https://typescriptbook.jp/reference/functions/iife"
    },
    {
      "title": "ジェネリクス (generics)",
      "content": "---\nsidebar_label: ジェネリクス\nslug: /reference/generics\n---\n\n# ジェネリクス (generics)\n\n型の安全性とコードの共通化の両立は難しいものです。あらゆる型で同じコードを使おうとすると、型の安全性が犠牲になります。逆に、型の安全性を重視しようとすると、同じようなコードを量産する必要が出てコードの共通化が達成しづらくなります。こうした問題を解決するために導入された言語機能がジェネリクスです。ジェネリクスを用いると、**型の安全性とコードの共通化を両立する**ことができます。\n\n## ジェネリクスが解決する問題\n\nジェネリクスが具体的にどのような問題を解決するのか見ていきましょう。ここに、`chooseRandomlyString()`という普通の関数があります。この関数は、2つの文字列を引数に受け取り、五分五分の確率で第1引数か第2引数の値を抽選して返します。\n\n```ts twoslash\nfunction chooseRandomlyString(v1: string, v2: string): string {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\n```\n\n`chooseRandomlyString`は文字列の抽選に限っては、この関数を再利用していくことができます。\n\n```ts twoslash\ndeclare function chooseRandomlyString(v1: string, v2: string): string;\n// ---cut---\nconst winOrLose = chooseRandomlyString(\"勝ち\", \"負け\");\n```\n\n次に、文字列だけでなく数値の抽選も同じロジックで行う必要が出てきたと考えてみましょう。`chooseRandomlyString()`は文字列にしか対応していないので、数値用の関数を新設しないとなりません。\n\n```ts twoslash\n// 数値用の抽選関数\nfunction chooseRandomlyNumber(v1: number, v2: number): number {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nconst num: number = chooseRandomlyNumber(1, 2);\n```\n\nさらに、五分五分抽選のロジックは汎用的なので、広告のA/Bテストのために`URL`オブジェクト向けの実装も作ることになりました。\n\n```ts twoslash\nconst urlA: URL = new URL(\"https://www.example.com/1\");\nconst urlB: URL = new URL(\"https://www.example.com/2\");\n// ---cut---\n// URLオブジェクト向けの抽選関数\nfunction chooseRandomlyURL(v1: URL, v2: URL): URL {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nconst url: URL = chooseRandomlyURL(urlA, urlB);\n```\n\nここまでで、`chooseRandomly()`関数は二度複製され、型だけが異なる同じ関数が3つもできてしまいました。\n\n```ts twoslash\n// 重複した3つの関数\nfunction chooseRandomlyString(v1: string, v2: string): string {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nfunction chooseRandomlyNumber(v1: number, v2: number): number {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nfunction chooseRandomlyURL(v1: URL, v2: URL): URL {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\n```\n\nでは、コードを共通化するにはどうしたらいいのでしょうか？まず考えられる方法としては、型を`any`にしてしまう方法です。この方法の問題点としては、戻り値の型も`any`になってしまうため、コンパイラのチェックが行われなくなり、バグを生みやすくなることです。つまり、型の安全性が損なわれるということです。\n\n下のサンプルコードでは、`chooseRandomly()`に`number`型を渡していますが、戻り値は`string`型のつもりで扱っています。このコードはコンパイルエラーにはなりませんが、コンパイル後のコードを実行してみると5行目で「TypeError: str.toLowerCase is not a function」というエラーが発生します。\n\n```ts twoslash\nfunction chooseRandomly(v1: any, v2: any): any {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nlet str = chooseRandomly(0, 1);\nstr = str.toLowerCase();\n```\n\nコードの共通化と型の安全性の両方を達成するにはどうしたらいいのでしょうか？ここで、役に立つのがジェネリクスです。ジェネリクスの発想は実はとてもシンプルで、「型も変数のように扱えるようにする」というものです。どういうことでしょうか？先に取り上げた重複した3つの関数を「どの部分がそれぞれ異なっているのか？」という視点で見てみましょう。すると、次のように`<>`で強調した部分が違うことに気がつくはずです。それ以外はまったく同じコードです。\n\n```ts twoslash\n// @noErrors\nfunction chooseRandomly<String>(v1: <string>, v2: <string>): <string> {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nfunction chooseRandomly<Number>(v1: <number>, v2: <number>): <number> {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nfunction chooseRandomly<URL>(v1: <URL>, v2: <URL>): <URL> {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nchooseRandomly<String>(\"勝ち\", \"負け\");\nchooseRandomly<Number>(1, 2);\nchooseRandomly<URL>(urlA, urlB);\n```\n\nこのそれぞれ違う部分は型に関するところです。この部分を変数のように扱いたいとしたら、ジェネリクスの文法を知らなくても、プログラマーなら次のようなコードを想像するのではないでしょうか？\n\n```ts twoslash\n// @noErrors\n// 注意: これは架空の文法です\nfunction chooseRandomly<type>(v1: <type>, v2: <type>): <type> {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nchooseRandomly<string>(\"勝ち\", \"負け\");\nchooseRandomly<number>(1, 2);\nchooseRandomly<URL>(urlA, urlB);\n```\n\n`<type>`に置き換えたところが「型の引数」を表した部分です。値の引数と同様に、この例では型も引数なので`chooseRandomly()`関数を呼び出すときは、`chooseRandomly<string>`のように型を関数に渡します。型をまるで引数のように扱ったコードがここで誕生したわけです。「ジェネリクスは、型も変数のように扱えるようにすること」だと説明しましたが、もうその意味がお分かりなのではないでしょうか。\n\n上のコードは、あくまでジェネリクスの発想を理解するためにでっち上げた架空のコードでした。このままではTypeScriptは理解できないので、TypeScriptのジェネリクスの文法で書き直してみましょう。架空のコードともそこまでかけ離れてはいません。次のように書きます。\n\n```ts twoslash\nconst urlA: URL = new URL(\"https://www.example.com/1\");\nconst urlB: URL = new URL(\"https://www.example.com/2\");\n// ---cut---\nfunction chooseRandomly<T>(v1: T, v2: T): T {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nchooseRandomly<string>(\"勝ち\", \"負け\");\nchooseRandomly<number>(1, 2);\nchooseRandomly<URL>(urlA, urlB);\n```\n\n`chooseRandomly`の`<T>`は型変数名の定義です。慣習として`T`がよく使われますが、`A`でも`Type`でも構いません。関数の引数の型や戻り値の型として書かれた`T`は型変数を参照しています。\n\n先ほどコンパイル時には気づけなかったバグコードに、ジェネリクス化した`chooseRandomly`を使ってみましょう。すると、「Argument of type '0' is not assignable to parameter of type 'string'.」というコンパイルエラーが発生するようになり、`string`型を入れなければならないところに`0`を代入しているバグに気づくことができるようになりました。\n\n```ts twoslash\n// @errors: 2345\nfunction chooseRandomly<T>(v1: T, v2: T): T {\n  return Math.random() <= 0.5 ? v1 : v2;\n}\nlet str = chooseRandomly<string>(0, 1);\nstr = str.toLowerCase();\n```\n\nこれまでで、ジェネリックではない関数たちを共通化した上で、さらに型の安全性を確保していく過程を見ながら、ジェネリクスが解決する問題点について説明してきました。ジェネリクスはコードの共通化と型の安全性を両立してくれる言語機能です。汎用的なコードをさまざまな型で使えるようにしたい際に、ジェネリクスを使うことを考えてみてください。\n\n## まとめ\n\n- コードの共通化すると、型の安全性が弱まる。\n- 型の安全性を高めると、コードの共通化が難しくなる。\n- ジェネリクスは、コードの共通化と型の安全性を両立するための言語機能。\n- ジェネリクスは、型も引数のように扱うという発想。\n",
      "url": "https://typescriptbook.jp/reference/generics/README"
    },
    {
      "title": "型引数の制約",
      "content": "# 型引数の制約\n\nTypeScriptではジェネリクスの型引数を特定の型に限定することができます。\n\n## ジェネリクス型引数で直面する問題\n\n`changeBackgroundColor()`という関数を例に考えてみます。この関数は指定されたHTML要素の背景色を変更して、そのHTML要素を返す関数です。\nジェネリクス型`T`を定義することで`HTMLButtonElement`や`HTMLDivElement`などの任意のHTML要素を受け取れるようにしています。\n\n```ts twoslash\n// @errors: 2339\nfunction changeBackgroundColor<T>(element: T) {\n  // Property 'style' does not exist on type 'T'.(2339)\n  element.style.backgroundColor = \"red\";\n  return element;\n}\n```\n\nこのコードはコンパイルに失敗します。ジェネリクスの型`T`は任意の型が指定可能なので、渡す型によっては`style`プロパティが存在しない場合があるからです。コンパイラは存在しないプロパティへの参照が発生する可能性を検知してコンパイルエラーとしているのです。\n\n`any`を使えばコンパイルエラーを回避することは可能ですが型のチェックがされません。将来バグが発生する危険性もあるので、できる限り避けたいところです。\n\n```ts twoslash\nfunction changeBackgroundColor<T>(element: T) {\n  // any に型アサーションすればコンパイルエラーは回避できる\n  // 型チェックされないのでバグの可能性\n  (element as any).style.backgroundColor = \"red\";\n  return element;\n}\n```\n\n## 型引数に制約をつける\n\nTypeScriptでは`extends`キーワードを用いることでジェネリクスの型`T`を特定の型に限定することができます。\n\n今回の例では`<T extends HTMLElement>`とすることで型`T`は必ず`HTMLElement`またはそのサブタイプの`HTMLButtonElement`や`HTMLDivElement`であることが保証されるため`style`プロパティに安全にアクセスできるようになります。\n\n```ts twoslash\nfunction changeBackgroundColor<T extends HTMLElement>(element: T) {\n  element.style.backgroundColor = \"red\";\n  return element;\n}\n```\n\nこの`extends`キーワードはインターフェースに対しても使います。インターフェースは実装のときは`implements`キーワードを使いますが型引数に使うときは`implements`を使わず同様に`extends`を使います。\n\n```ts twoslash\ninterface ValueObject<T> {\n  value: T;\n\n  toString(): string;\n}\n\nclass UserID implements ValueObject<number> {\n  public value: number;\n\n  public constructor(value: number) {\n    this.value = value;\n  }\n\n  public toString(): string {\n    return `${this.value}`;\n  }\n}\n\nclass Entity<ID extends ValueObject<unknown>> {\n  private id: ID;\n\n  public constructor(id: ID) {\n    this.id = id;\n  }\n\n  //...\n}\n```\n\n`Entity`クラスは`ValueObject`インターフェースを実装しているクラスをIDとして受ける構造になっていますが19行目にあるようにこのときの型引数の制約は`implements`ではなく`extends`でなければなりません。\n",
      "url": "https://typescriptbook.jp/reference/generics/type-parameter-constraint"
    },
    {
      "title": "デフォルト型引数",
      "content": "# デフォルト型引数\n\n関数の引数にデフォルト値を指定するように、ジェネリクスでもデフォルトの型引数を指定することができます。\n\n例としてエラーイベントを表す`MyErrorEvent`という型を定義してみます。この型は発生した任意のエラーオブジェクトとその種類を文字列で保持する型です。\n\n```ts twoslash\ntype MyErrorEvent<T> = {\n  error: T;\n  type: string;\n};\n```\n\nこの型は次のように利用できます。\n\n```ts twoslash\ntype MyErrorEvent<T> = {\n  error: T;\n  type: string;\n};\n// ---cut---\nclass NetworkError extends Error {\n  constructor(e?: string) {\n    super(e);\n    this.name = new.target.name;\n  }\n}\n\nconst errorEvent: MyErrorEvent<Error> = {\n  error: new Error(\"エラーです\"),\n  type: \"syntax\",\n};\n\nconst networkErrorEvent: MyErrorEvent<NetworkError> = {\n  error: new NetworkError(\"ネットワークエラーです\"),\n  type: \"network\",\n};\n```\n\n例外処理を記述する時に`NetworkError`のように対応するエラークラスをすべて用意することはなく、標準の`Error`で対応してしまうケースも多くありますが、今の状態では`MyErrorEvent`のジェネリクスの型`T`を常に指定する必要があり非常に面倒です。\n\n```ts twoslash\ntype MyErrorEvent<T> = {\n  error: T;\n  type: string;\n};\n// ---cut---\n// @errors: 2314\n// 型 T が必須なので、MyErrorEvent<Error>と指定する必要がある。\nconst errorEvent: MyErrorEvent = {\n  error: new Error(\"エラーです\"),\n  type: \"syntax\",\n};\n```\n\nそこで、`<T = Error>`とすることでデフォルト型引数として`Error`を指定します。\n\n```ts twoslash\ntype MyErrorEvent<T = Error> = {\n  error: T;\n  type: string;\n};\n```\n\nデフォルト型引数として`Error`を指定することでジェネリクスの型`T`は必要な時だけ指定して、何も指定してない場合は自動で`Error`とすることができます。\n\n```ts twoslash\ntype MyErrorEvent<T = Error> = {\n  error: T;\n  type: string;\n};\nclass NetworkError extends Error {\n  constructor(e?: string) {\n    super(e);\n    this.name = new.target.name;\n  }\n}\n// ---cut---\n\n// デフォルト型引数を指定した事で Error の型指定を省略できる\nconst errorEvent: MyErrorEvent = {\n  error: new Error(\"エラーです\"),\n  type: \"syntax\",\n};\n\nconst networkErrorEvent: MyErrorEvent<NetworkError> = {\n  error: new NetworkError(\"ネットワークエラーです\"),\n  type: \"network\",\n};\n```\n\n## 型引数の制約と併用する\n\nある型の部分型であることを指定しながら、かつ省略時はデフォルト型を指定する合わせ技もできます。型引数の制約については専門のページがありますのでそちらを参照してください。\n\n[型引数の制約](type-parameter-constraint.md)\n\n`MyErrorEvent`に与えられる型`T`を`Error`のサブクラスに限定しつつ、省略時は`SyntaxError`としたい場合は次のような書き方になります。\n\n```ts twoslash\ntype MyErrorEvent<T extends Error = SyntaxError> = {\n  error: T;\n  type: string;\n};\n```\n\n型引数の制約とデフォルト型引数の両立をする場合はデフォルト型引数が制約を満たしている必要があります。\n\n```ts twoslash\n// @errors: 2344\ninterface Serializable<T extends string | number = bigint> {\n  value: T;\n\n  toString(): string;\n}\n```\n\nこの例は`string | number`型に制約しているにもかかわらず、デフォルト型引数に`bigint`型を指定しています。そのため制約を満足することができずTypeScriptから指摘を受けます。\n\n## デフォルト型引数をジェネリクスで指定する\n\nジェネリクスが複数あるとき、デフォルト型引数をデフォルト型引数で指定できます。\n\n```ts twoslash\nclass Aubergine<A, B = A, C = B> {\n  private readonly a: A;\n  private readonly b: B;\n  private readonly c: C;\n\n  public constructor(a: A, b: B, c: C) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  // ...\n}\n```\n\nデフォルト型引数は左から順に参照されるため、左にあるジェネリクスが右のジェネリクスを指定することはできません。\n\n```ts twoslash\n// @errors: 2744 2706\nclass Aubergine<A = B, B, C = B> {\n  private readonly a: A;\n  private readonly b: B;\n  private readonly c: C;\n\n  public constructor(a: A, b: B, c: C) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/generics/default-type-parameter"
    },
    {
      "title": "ジェネリクスが使われている標準ライブラリ",
      "content": "# ジェネリクスが使われている標準ライブラリ\n\nジェネリクスは標準ライブラリの中でも多くの箇所で利用されています。ジェネリクスを利用する代表的なものとしては、\n\n- Arrayオブジェクト\n- Promiseオブジェクト\n- Mapオブジェクト\n\nなどがあります。\n\nこれらのオブジェクトでジェネリクスがどう使われているのかを見てきましょう。\n\n## なぜジェネリクスが使われているか\n\n`Array`オブジェクトは`string`や`number`など状況に応じて色々な型の要素を保持する必要があります。このとき、配列の要素の型はどんなプログラムを実装するかで変わってきます。つまり、要素の型を抽象化してプログラマーが実装時に型を指定できる必要があります。\n\nこの型を抽象化する方法としてジェネリクスが利用されています。\n\n```ts twoslash\nconst numbers: Array<number> = [1, 2, 3, 4];\n```\n\n`Array`は特別に別の記法で型表記をすることもできます。これらについては配列のページに詳細がありますので併せて参照ください。\n\n```ts twoslash\nconst numbers: number[] = [1, 2, 3, 4];\n```\n\n[配列の型注釈 (type annotation)](../values-types-variables/array/type-annotation-of-array.md)\n\n## 標準ライブラリを使ってみる\n\n実際にジェネリクスが使われる標準ライブラリを利用した実装をみてみましょう。\n\n### `Array.prototype.map<T>()`\n\n`Array`オブジェクトの`map<T>()`メソッドは引数で渡された関数をすべての配列の要素に適用することで新しい配列を返す関数です。サンプルコードでは、新しく生成される数値配列の要素の型を指定する`map<number>`でジェネリクスが使われています。\n\n```ts twoslash\nconst textNumbers = [\"1\", \"2\", \"3\", \"4\"];\nconst numbers = textNumbers.map<number>(function (text: string) {\n  return Number(text);\n});\n```\n\n### `Map<K, V>`\n\n`Map<K, V>`オブジェクトでは、`K`にキーの型を指定し`V`にキーに紐づく値の型を指定します。先ほどの`map<T>()`メソッドは、ジェネリクスの型定義がひとつだけでしたが、`Map<K, V>`は型定義がふたつあります。このようにジェネリクスの型定義はひとつである必要はなく、複数の型定義を持つことも可能です。\n\n```ts twoslash\ntype Address = {\n  country: string;\n  postalCode: string;\n  address1: string;\n};\n\nconst addresses = new Map<string, Address>();\naddresses.set(\"太郎\", {\n  country: \"日本\",\n  postalCode: \"8256405\",\n  address1: \"東京都\",\n});\n\nconsole.log(addresses.get(\"太郎\"));\n```\n\n### `Promise<T>`\n\n`Promise`オブジェクトについての説明は本書より詳細な記載がありますので、そちらをご参照ください。\n\n[Promise](../asynchronous/promise.md)\n\n### 標準ライブラリの型定義の参照方法\n\n標準ライブラリの型定義ファイルはTypeScriptの公式リポジトリのsrc/libディレクトリで確認することができます。\n<https://github.com/microsoft/TypeScript/tree/main/src/lib>\n\n`Array.prototype.map()`の型は [lib/lib.es5.d.ts](https://github.com/microsoft/TypeScript/blob/main/src/lib/es5.d.ts#L1246) のファイルで確認できます。\n",
      "url": "https://typescriptbook.jp/reference/generics/built-in-libraries-using-generics"
    },
    {
      "title": "型変数 (type variables)",
      "content": "---\nsidebar_label: 型変数\n---\n\n# 型変数 (type variables)\n\nここでは、ジェネリクスで重要な概念となる「型変数」とは何なのかについて説明します。\n\n## **型変数**\n\n「変数」といえば、値を代入する入れ物をイメージすることでしょう。たとえば、次のコードは`x`が変数で、その値に`1`を代入しています。\n\n```ts twoslash\nconst x = 1;\n```\n\n一度変数を定義すれば、あちこちに値を書き写す必要がなくなり、その変数を使ってさまざまな処理をすることができます。\n\n変数という便利な入れ物があるおかげで、繰り返し同じコードを書く必要がなくなったり、より抽象的なコードを書けるようになったりと、さまざまな恩恵を享受できるわけです。\n\n型変数(type variables)は、もうひとつの便利な入れ物です。ただし、入れられるのは「値」ではなく「型」という違いがあります。\n\n```ts twoslash\nfunction printAndReturn<T>(value: T): T {\n  console.log(value);\n  return value;\n}\n```\n\nこの`printAndReturn`関数の`T`が型変数です。`<T>`が型変数名を決めている部分で`value`の型に使われている`T`と戻り値に書かれている`T`は変数を利用している部分、つまり、参照している部分です。\n\n`printAndReturn`関数の`T`の変数スコープは、この関数の範囲になります。したがって、関数のシグネチャで`T`を参照できるのはもちろん、関数の処理部分でも参照することができます。一方で、関数の外から参照することはできません。\n\n```ts twoslash\n// @errors: 2304\nfunction printAndReturn<T>(value: T): T {\n  let values: T[] = []; // OK\n  const doSomething = (value: T) => {}; // OK\n  return value;\n}\n\nlet value: T;\n```\n\nこの関数を利用するコードは、`number`など`T`に好きな型を代入することができます:\n\n```ts twoslash\ndeclare function printAndReturn<T>(value: T): T;\n// ---cut---\nconst value = printAndReturn<number>(123);\n```\n\n## 型引数\n\n型引数(type arguments)とは、型変数に代入した型のことを言います。次のコードでは`number`が型引数です。\n\n```ts twoslash\ndeclare function printAndReturn<T>(value: T): T;\n// ---cut---\nconst value = printAndReturn<number>(123);\n```\n\nTypeScriptでは、型引数にも型推論が行われます。型引数推論(type argument inference)と言われます。上の例では、型変数`T`に`number`を代入するコードを明示的に書いていますが、変数の`123`から型変数`T`の型は`number`型になることがコンパイラからは推測可能なので、次のコードのように型引数の記述を省略することもできます。\n\n```ts twoslash\ndeclare function printAndReturn<T>(value: T): T;\n// ---cut---\nconst value = printAndReturn(123);\n```\n\n## **型変数に使える文字**\n\nTypeScriptの型変数に使える文字は変数名や関数名、クラス名などに使える文字種と同じものが使えます。したがって、大文字アルファベット1文字でなければならないといった制約はありません。\n\n```ts twoslash\nfunction func1<T>(x: T) {}\nfunction func2<Foo>(x: Foo) {}\nfunction func3<fooBar>(x: fooBar) {}\nfunction func4<$>(x: $) {}\nfunction func5<かた>(x: かた) {}\n```\n\nこのように、3文字の`Foo`、キャメルケースの`fooBar`、記号の`$`、Unicodeの`かた`も型変数名として定義可能です。\n\n```ts\nfunction func1<1>(x: 1) {} // コンパイルエラー\nfunction func2<class>(x: class) {} // コンパイルエラー\n```\n\n型変数名に使えないものは数字ではじまるもの、`class`などの予約語です。\n\n## **型変数名の慣習**\n\nTypeScriptの慣習として、型変数名には`T`を用いることが多いです。この`T`はtemplateの略と言われています。\n\n単純なジェネリクスで、型変数が2つある場合は、`T`と`U`が用いられることがあり、その理由はアルファベット順でTの次がUだからです。この規則にしたがって、3つ目の型変数は`V`とする場合もあります。\n\n```ts twoslash\nfunction compare<T, U>(a: T, b: U) {}\n```\n\n複数の型変数がある場合、型変数に意味のある名前をつけることもあります。その場合、`TKey`、`TValue`のように`T`接頭辞を付けた命名規則がしばしば使われます。ただし、これは「型変数名には`T`を用いる」という慣習ほどは一般的でないように思われます。\n\n```ts twoslash\nfunction makeKeyValuePair<TKey, TValue>(key: TKey, value: TValue) {}\n```\n\n型変数名を単語にする場合は、大文字始まりのキャメルケースにすることが普通です。\n\n:::info\n\n### 型変数の名づけを巡る議論\n\n「型変数はどのような名づけがベストか？」というテーマについては、プログラマーによってさまざまな主張があり、見解が分かれるところです。ここでは、参考までにその議論を取り上げますが、どうか混乱しないで頂ければと思います。実務においては、**プロジェクトで一貫した命名規約に準ずる**ことを意識しておけばいいでしょう。\n\n### できるだけ意味のある単語にすべきという主張\n\n`T`のような1文字だけでは何が入るのか分かりにくいため、意味のある単語にすべきという考え方があります。`Array<T>`の代わりに、`Array<Element>`のほうが分かりやすいとする立場です。\n\n### 1文字のほうがよいとする主張\n\nジェネリクスはそもそも抽象的なものごとを扱うため、具体的な名前が付けられないため、意味を持たないTのほうがいいという考え方があります。\n\n`Element`のような型変数名を定義すると、一見するとそれがクラス名のように見えてしまいます。混乱を避けるためにも`T`のほうがよいという意見があります。\n\n### 型変数のスコープの広さによって使い分けるべきとする主張\n\nプログラミングでの名づけは、名つけるもののスコープが広くなるほど長い名前を、狭くなるほど短い名前をつけるというテクニックがあります。たとえば、`for`ループで変数に`i`を用いることがありますが、これは慣習というところもありますが、変数のスコープが狭いという一面もあります。型変数にも同じことが言えて、型変数のスコープが広いものは単語にし、短いジェネリック関数の中でしか使わない型変数は1文字が妥当という考え方があります。\n\n:::\n",
      "url": "https://typescriptbook.jp/reference/generics/type-variables"
    },
    {
      "title": "シングルプロセス・シングルスレッドとコールバック",
      "content": "# シングルプロセス・シングルスレッドとコールバック\n\nコンピューティング。特に並列、並行処理をするプログラミングに入ってくるとプロセス、スレッドという言葉を耳にするようになります。\n\nJavaScriptはシングルプロセス、シングルスレッドの言語です。これは言い換えるとすべてのプログラムは直列に処理されることを意味します。シングルスレッドの言語はコールスタックも1個です。\n\nコールスタックとは実行している関数の呼び出しの順序を司っているものです。スタックという言葉自体は関数の再帰呼び出しを誤って無限ループにしてしまった時に目にしたことがある人が多いのではないでしょうか。\n\n```ts twoslash\nfunction stack(): never {\n  stack();\n}\n\nstack();\n```\n\n```text\nRangeError: Maximum call stack size exceeded\n```\n\n## ブロッキング\n\n直列に処理されるということは、時間のかかる処理があるとその間は他の処理が実行されないことを意味します。\n\nブラウザでAJAX通信を実装したことがある方は多いでしょう。AJAXはリクエストを送信してからレスポンスを受信するまでの間は待ち時間になりますが、直列で処理するのであればJavaScriptはこの間も他の処理ができないことになります。これをブロッキングと言います。\n\nJavaScriptはブラウザで発生するクリック、各種input要素からの入力、ブラウザの履歴の戻る進むなど、各種イベントをハンドリングできる言語ですが、時間のかかる処理が実行されている間はブロッキングが起こるためこれらの操作をハンドリングできなくなります。画面の描画もJavaScriptに任せていた場合はさらに画面が止まったように見えるでしょう。\n\n```ts twoslash\ndeclare function ajax(url: string): Promise<unknown>;\ndeclare function wait(ms: number): Promise<void>;\ndeclare function ajaxDone(): boolean;\ndeclare function cancelAjax(): Promise<void>;\n// ---cut---\najax(\"https://...\");\nwait(3000);\n\nif (!ajaxDone()) {\n  cancelAjax();\n}\n```\n\n上記のメソッドたちはどれも実在するメソッドではありませんが、おおよその意味を理解していただければ問題ありません。これを先入観なく見ると\n\n1. AJAXを開始する\n2. 3000ms待つ\n3. AJAXが終わっていなかったら\n   1. AJAXを中止する\n\nのように見えるかもしれませんが、これはその意図した動作にはなりません。実際には次のようになります。\n\n1. AJAXをして、結果を取得する（ブロックして戻ってきたら2に進む)\n2. 3000ms待つ\n3. AJAXが終わっていなかったら(すでに終了している)\n4. AJAXを中止する\n\nとなります。もちろん`ajaxDone()`は`ajax()`の時点で結果にかかわらず終了しているため`cancelAjax()`は実行されません。\n\n## ノンブロッキング\n\nブロッキングの逆の概念です。Node.jsはノンブロッキングI/Oを取り扱うことができます。\n\nこれは入出力の処理が終わるまで待たずにすぐに呼び出し元に結果を返し、追って別の方法で結果を伝える方式を指します。\n\nここで指している入出力とはアプリケーションが動くマシン(サーバー)が主にリポジトリと呼ばれるようなファイル、リクエスト、DBなど他のデータがある場所へのアクセスを指す時に使われます。\n\nノンブロッキングかわかりやすい例としては次のようなものがあります。\n\n```ts twoslash\nconsole.log(\"first\");\n\nsetTimeout(() => {\n  console.log(\"second\");\n}, 1000);\n\nconsole.log(\"third\");\n```\n\n`setTimeout()`は実際に存在する関数です。第2引数では指定したミリ秒後に第1引数の関数を実行します。ここでは1000を指定しているので、1000ミリ秒、つまり1秒後となります。\n\nJavaScriptを始めて日が浅い方はこのコードに対する出力を次のように考えます。\n\n```text\nfirst\nsecond\nthird\n```\n\n実際の出力は以下です。\n\n```text\nfirst\nthird\nsecond\n```\n\n`setTimeout()`がノンブロッキングな関数です。この関数は実行されると第1引数の関数をいったん保留し、処理を終えます。そのため次の`console.log('third')`が実行され、1000ミリ秒後に第1引数の関数が実行され、中にある`console.log('second')`が実行されます。\n\n1000ミリ秒は待ちすぎ、もっと短ければ意図する順番通りに表示される。と思われるかもしれませんが、基本的に意図するとおりにはなりません。以下は第2引数を1000ミリ秒から0ミリ秒に変更した例ですが、出力される内容は変更前と変わりません。\n\n```ts twoslash\nconsole.log(\"first\");\n\nsetTimeout(() => {\n  console.log(\"second\");\n}, 0);\n\nconsole.log(\"third\");\n\n// @log: 'first'\n\n// @log: 'third'\n\n// @log: 'second'\n```\n\n現実世界の料理に例えてみるとわかりやすいかもしれません。お米を炊いている40分間、ずっと炊飯器の前で待機する料理人はおらず、その間に別のおかずを作るでしょう。\n\n時間はかかるものの待機が多い作業、炊飯器なら炊飯ボタンを押したら炊き上がるまでの間待たずに他の処理の実行に移ることがノンブロッキングを意味します。\n\n## ノンブロッキングを成し遂げるための立役者\n\nノンブロッキングを語る上で欠かせない、必ず目にすることになるであろう縁の下の力持ちを紹介します。\n\n### メッセージキュー\n\nメッセージキューとはユーザーからのイベントや、ブラウザからのイベントなどを一時的に蓄えておく領域です。メッセージキューに蓄積されたイベントはコールスタックが空のときにひとつずつコールスタックに戻されます。\n\n### コールバック\n\n`setTimeout()`のときに説明した**いったん保留した関数**は、いわゆるコールバック関数と呼ばれます。前項で述べた、**追って別の方法で伝える**というのは、このコールバック関数のことです。\n\nコールバック関数は、ある関数が条件を満たした時、前項の例だと1000ミリ秒後に、メッセージキューに蓄積されます。メッセージキューに蓄積されるだけなので、実際に実行されるのはコールスタックが空になるまでさらに時間がかかります。\n\nいままで`setTimeout()`は第2引数のミリ秒だけ遅延させてコールバック関数を実行すると説明していましたが、厳密にはミリ秒経過後にメッセージキューに戻すだけで、そのコールバック関数が即座に実行されるわけではありません。\n\n### イベントループ\n\nイベントループは単純な無限ループです。常にコールスタックを監視しており、イベントがあればそれを実行します。普通の関数呼び出しのスタック以外にもメッセージキューが戻してきたイベントも処理します。現時点では詳しくは説明しませんが、ずっとイベントをどうにかしてくれているやつがいるなー、程度の認識でオッケーです！\n\n## ノンブロッキングの弊害\n\nノンブロッキングにはたくさんいいところがあって頼れる仲間ですが、そのノンブロッキングが時として唐突に牙を剥くことがあります。こわいですねぇ。\n\n### コールバック地獄(Callback hell)\n\nコールバック界における**負の産物**です。\n\n一般的にコールバックは、ある一定の時間を要する処理結果を後から受け取るために使われます。コールバックを採用している関数は主に次のような形をしています。\n\n```ts twoslash\nfunction ajax(uri: string, callback: (res: Response) => void): void {\n  // ...\n}\n```\n\nこの関数を使う時はこのようになります。\n\n```ts twoslash\ndeclare function ajax(uri: string, callback: (res: Response) => void): void;\n// ---cut---\najax(\"https://...\", (res: Response) => {\n  // ...\n});\n```\n\nここで、この関数`ajax()`の結果を受けてさらに`ajax()`を使いたいとすると、このようになってしまいます。\n\n```ts twoslash\ndeclare function ajax(uri: string, callback: (res: Response) => void): void;\n// ---cut---\najax(\"https://...\", (res1: Response) => {\n  ajax(\"https://...\", (res2: Response) => {\n    // ...\n  });\n});\n```\n\nインデント(ネスト)が深くなります。これが何度も続くと見るに堪えなくなります。\n\n```ts twoslash\ndeclare function ajax(uri: string, callback: (res: Response) => void): void;\n// ---cut---\najax(\"https://...\", (res1: Response) => {\n  ajax(\"https://...\", (res2: Response) => {\n    ajax(\"https://...\", (res3: Response) => {\n      ajax(\"https://...\", (res4: Response) => {\n        ajax(\"https://...\", (res5: Response) => {\n          ajax(\"https://...\", (res6: Response) => {\n            // ...\n          });\n        });\n      });\n    });\n  });\n});\n```\n\nこのコールバック地獄を解消する画期的なクラスとして`Promise`が登場し主要なブラウザとNode.jsではビルトインオブジェクトとして使うことができます。こちらの説明については本書に専用のページがありますのでそちらをご参照ください。\n\n[非同期処理](./asynchronous/README.md)\n",
      "url": "https://typescriptbook.jp/reference/single-process-and-callback"
    },
    {
      "title": "for-of文 - 拡張for文",
      "content": "# for-of文 - 拡張for文\n\nJavaScriptで配列をループするのに使えるのがfor-of構文です。PHPの`foreach`やPythonの`for in`と使い勝手が似ている構文です。\n\n```js\nfor (変数 of 配列) {\n  文;\n}\n```\n\n次の例は、配列`[1, 2, 3]`をループして順番に`1`、`2`、`3`を出力するものです。\n\n```js twoslash\nconst numbers = [1, 2, 3];\nfor (const n of numbers) {\n  console.log(n);\n}\n```\n\n## for-ofでインデックスを取得する\n\nJavaScriptで、for-ofで配列のインデックスと値を一緒に得るには、`entries`メソッドを組み合わせます。\n\n```js twoslash\nconst words = [\"I\", \"love\", \"TypeScript\"];\nfor (const [index, word] of words.entries()) {\n  console.log(index, word);\n}\n// @log: 0 I\n\n// @log: 1 love\n\n// @log: 2 TypeScript\n```\n\n## 関連情報\n\n[配列をループする方法](../values-types-variables/array/how-to-loop-an-array.md)\n\n[オブジェクトをループする方法](../values-types-variables/object/how-to-loop-an-object.md)\n",
      "url": "https://typescriptbook.jp/reference/statements/for-of"
    },
    {
      "title": "例外処理 (exception)",
      "content": "---\nsidebar_label: 例外処理\n---\n\n# 例外処理 (exception)\n\nJavaScriptにはJavaに似た例外処理の構文があります。例外には`Error`オブジェクトを使い、throw構文で例外を投げます。try-catch構文で例外を捕捉できます。\n\n```js twoslash\ntry {\n  throw new Error(\"something wrong\");\n} catch (e) {\n  // something wrong\n  console.log(e.message);\n}\n```\n\n## throw構文\n\nJavaScriptのthrowは例外を投げる構文です。例外として投げるオブジェクトはErrorオブジェクトを使うのが一般的です。\n\n```js twoslash\nthrow new Error(\"network error!\");\n```\n\nJavaScriptのthrowはJavaなどと異なり、何でも投げることができます。プリミティブ型でさえ投げれます。\n\n```js twoslash\nthrow \"just a string\";\n```\n\nこれはアンチパターンです。throwが何でも投げられるとしても、Errorオブジェクトを用いるべきです。Errorオブジェクトを使ったほうがコードの読み手に意外性を与えないからです。加えて、スタックトレースが追えるのはErrorオブジェクトだけだからです。\n\n## try-catch構文\n\nJavaScriptで例外を捉えるにはtry-catch構文を使います。例外が投げられる可能性がある部分をtryブロックで囲み、catchブロックで捉えた例外に対する処理を行います。\n\n```js twoslash\ntry {\n  throw new Error(\"something wrong\");\n} catch (e) {\n  console.error(e);\n}\n```\n\n### catchの型\n\nTypeScriptではcatchの変数の型はデフォルトで`any`型になります。\n\n```ts twoslash\n// @useUnknownInCatchVariables: false\ntry {\n  // ...\n} catch (e) {\n  //     ^?\n}\n```\n\n型が`Error`オブジェクトの型ではなく`any`型になるのは、JavaScriptの仕様上どんな値がthrowされるか分からないためです。\n\nTypeScriptのコンパイラーオプションの`useUnknownInCatchVariables`を有効にすると、catchの変数の型が`unknown`型になります。「どんな値がthrowされるか分からない」ことを型として正確に表現できるため、より型安全にしたい場合は、このオプションを有効化するとよいでしょう。\n\n[useUnknownInCatchVariables](../tsconfig/useunknownincatchvariables.md)\n\n[undefined型](../values-types-variables/undefined.md)\n\n### catchの分岐\n\nJavaやPHPでは捉えるエラーの型に対応するcatchを複数書けますが、JavaScriptとTypeScriptではcatchは1つしか書けません。JavaScriptでエラーの型によってエラーハンドリングを分岐したい場合は、catchブロックの中で分岐を書く方法で対応します。\n\n```ts twoslash\ntry {\n  // ...\n} catch (e) {\n  if (e instanceof TypeError) {\n    // TypeErrorに対する処理\n  } else if (e instanceof RangeError) {\n    // RangeErrorに対する処理\n  } else if (e instanceof EvalError) {\n    // EvalErrorに対する処理\n  } else {\n    // その他のエラー\n  }\n}\n```\n\n### try-catchはブロックスコープ\n\nJavaScriptのtry-catch文内の変数はブロックスコープになります。そのため、try-catch内で宣言された変数は、try-catchの外では参照できません。\n\n```ts twoslash\n// @errors: 2304\nasync function fetchData() {\n  try {\n    const res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\");\n    const data = await res.json();\n    console.log(data); // dataが参照できる\n  } catch (e: unknown) {\n    return;\n  }\n  console.log(data); // dataが参照できない\n}\n\nfetchData();\n```\n\n[変数のスコープ (scope)](variable-scope.md)\n\ntry-catch文の外でも変数を参照したい場合は、tryの前に代入用の変数をlet宣言しておく必要があります。\n\n```ts twoslash\nasync function fetchData() {\n  let data: any;\n  try {\n    const res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\");\n    data = await res.json();\n  } catch (e: unknown) {\n    return;\n  }\n  console.log(data); // dataが参照できる\n}\n\nfetchData();\n```\n\n### finallyブロック\n\nJavaScriptにもJavaやPHPと同じようにfinallyが書けます。finallyは例外が発生しようがしまいが必ず実行される処理です。finallyはtry-catchの後に書きます。finally内の処理はtryとcatchの処理が実行された後に実行されます。\n\n```js twoslash\ntry {\n  // ...\n} catch (e) {\n  // ...\n} finally {\n  // ...\n}\n```\n",
      "url": "https://typescriptbook.jp/reference/statements/exception"
    },
    {
      "title": "switchと変数スコープ",
      "content": "# switchと変数スコープ\n\nJavaScriptでは、`switch`ごとに変数スコープが作られます。\n\n```ts twoslash\nswitch (\n  true // 変数スコープその1\n) {\n  default:\n    switch (\n      true // 変数スコープその2\n    ) {\n      default:\n      // ...\n    }\n}\n```\n\n## caseの変数スコープはない\n\n`case`ごとには変数スコープが作られません。複数の`case`がある場合、`switch`全体で変数スコープを共有します。そのため、複数の`case`で同じ変数名を宣言すると実行時エラーが発生します。\n\n<!--prettier-ignore-->\n```ts twoslash\nlet x = 1;\nswitch (x) {\n  case 1:\n    const sameName = \"A\";\n    break;\n  case 2:\n    const sameName = \"B\";\n// @error: SyntaxError: Identifier 'sameName' has already been declared\n    break;\n}\n// @noErrors\n```\n\nTypeScriptでは、同じ変数名を宣言するとコンパイルエラーを出します。\n\n```ts twoslash\n// @errors: 2451\nlet x = 1;\nswitch (x) {\n  case 1:\n    const sameName = \"A\";\n    break;\n  case 2:\n    const sameName = \"B\";\n    break;\n}\n```\n\n## caseに変数スコープを作る方法\n\ncaseに変数スコープを作るには、中カッコでcase節を囲みます。\n\n```ts twoslash\nlet x = 1;\nswitch (x) {\n  case 1: {\n    const sameName = \"A\";\n    break;\n  }\n  case 2: {\n    const sameName = \"B\";\n    break;\n  }\n}\n```\n\nこうすると、JavaScriptの実行時エラーも、TypeScriptのコンパイルエラーも発生しなくなります。\n\n<PostILearned>\n\n🌏JavaScriptのswitchは全体で1つの変数スコープ\n😕caseレベルのスコープはない\n\nもしも複数のcaseで同じ変数名を宣言すると…\n🔥JavaScript → 実行時エラー\n⛔️TypeScript → コンパイルエラー\n\n✅caseに{}を書くと固有のスコープが作れる\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/statements/switch-and-variable-scope"
    },
    {
      "title": "if-else文",
      "content": "# if-else文\n\nJavaScriptの条件分岐はJavaやPHPと同じようにif-else構文を用います。\n\n```js twoslash\nif (value === 0) {\n  // ...\n} else {\n  // ...\n}\n```\n\nJavaScriptにもelse-ifがあります。`else if`のようにelseとifの間にはスペースが必要です。\n\n```js twoslash\nif (value === 0) {\n  // ...\n} else if (value === 1) {\n  // ...\n} else {\n  // ...\n}\n```\n\nJavaScriptのif-elseは文です。式ではないので、条件分岐を直接変数に代入することはできません。\n\n```js\n// こんな書き方はできない\nconst result = if (value === 0) \"OK\" else \"NG\";\n```\n\n式で条件分岐を使いたい場合は三項演算子(ternary operator)を用います。\n\n```js twoslash\nconst result = value === 0 ? \"OK\" : \"NG\";\n```\n\n[三項演算子 (ternary operator)](ternary-operator.md)\n\n上のコードと同じロジックをif-elseで書く場合は、`if`ブロックの手前で結果を代入する変数を`let`で宣言します。\n\n```js twoslash\nlet result;\nif (value === 0) {\n  result = \"OK\";\n} else {\n  result = \"NG\";\n}\n```\n\n## 関連情報\n\n[switch文](switch.md)\n",
      "url": "https://typescriptbook.jp/reference/statements/if-else"
    },
    {
      "title": "unknown型",
      "content": "# unknown型\n\nTypeScriptのunknown型は、型が何かわからないときに使う型です。\n\nunknown型にはどのような値も代入できます。\n\n```ts twoslash\nlet value: unknown;\nvalue = 1; // OK\nvalue = \"string\"; // OK\nvalue = { name: \"オブジェクト\" }; // OK\n```\n\n## unknown型は型安全なany型\n\nunknown型はよく「型安全なany型」と言われ、any型と対比されます。\n\nany型はどのような型の変数にも代入できます。\n\n```ts twoslash\nconst value: any = 10;\nconst int: number = value;\nconst bool: boolean = value;\nconst str: string = value;\nconst obj: object = value;\n```\n\n一方、unknown型の値は具体的な型へ代入できません。\n\n```ts twoslash\n// @errors: 2322\nconst value: unknown = 10;\nconst int: number = value;\nconst bool: boolean = value;\nconst str: string = value;\nconst obj: object = value;\n\nconst any: any = value; // OK\nconst unknown: unknown = value; // OK\n```\n\nnumber型である変数`int`に対しても代入が失敗しているのは、やりすぎではないかと思われるかもしれませんが、不明な型を安全に扱うとこのようになります。\n\nまた、unknown型はプロパティへのアクセス、メソッドの呼び出しも許されません。\n\n```ts twoslash\n// @errors: 18046\nconst value: unknown = 10;\nvalue.toFixed();\n\nconst obj: unknown = { name: \"オブジェクト\" };\nobj.name;\n```\n\nanyとunknownの特性の違いの詳細は次のページをご覧ください。\n\n[anyとunknownの違い](any-vs-unknown.md)\n\n## unknownと型の絞り込み\n\nunknownはanyよりも安全な不明型ですが、そのままでは実用できません。unknownの値を使うには、型を絞り込む必要があります。\n\n型の絞り込みには`typeof`や`instanceof`などを条件式に含んだif文を使います。これは型ガードと呼ばれます。型ガードで絞り込むと、それ以降の処理では絞り込まれた型として扱えます。\n\n```ts twoslash\nconst value: unknown = \"\";\n// 型ガード\nif (typeof value === \"string\") {\n  // ここブロックではvalueはstring型として扱える\n  console.log(value.toUpperCase());\n}\n```\n\nこの例ではunknown型の変数`value`が`typeof`によりifの中ではstring型であることが確定したため、string型のメソッドである`toUpperCase()`を使えるようになります。\n\n型の絞り込みは、[型ガード関数]を使う方法もあります。\n\n```ts twoslash\n// 型ガード関数\nfunction isObject(value: unknown): value is object {\n  return typeof value === \"object\" && value !== null;\n}\nconst value: unknown = { a: 1, b: 2 };\n// 型ガード\nif (isObject(value)) {\n  console.log(Object.keys(value));\n  //                      ^?\n  // ここでは、valueはobject型として扱える\n}\n```\n\n[型ガード関数]: ../functions/type-guard-functions.md\n\n[制御フロー分析](../statements/control-flow-analysis-and-type-guard.md)\n\n### unknown型を配列型に絞り込む\n\nunknown型を配列型に絞り込みたいときは`Array.isArray()`を使います。加えて、さらに配列要素までチェックすると、より安全なチェック処理になります。\n\n```ts twoslash\nfunction isNumberArray(value: unknown): value is number[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  return value.every((e) => typeof e === \"number\");\n}\n```\n\n### unknown型をオブジェクトの型に絞り込む\n\nunknown型をオブジェクトの型に絞り込むには、`typeof`演算子を用います。\n\n```ts twoslash\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\nfunction isEmail(value: unknown): value is Email {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  return true;\n}\n```\n\nこのままでは、値が本当に`Email`型を満たしているかわかりません。`from`などのプロパティまでチェックしていないからです。チェックの正確さを高めるためには、各プロパティの型をチェックする必要があります。\n\n```ts twoslash\n// @noErrors\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\n// ---cut---\nfunction isEmail(value: unknown): value is Email {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  // 各プロパティのチェック\n  if (typeof value.from !== \"string\") {\n    return false;\n  }\n  return true;\n}\n```\n\n上のプロパティチェックは一見問題なさそうですが、実際は次のようなコンパイルエラーが発生します。\n\n```ts twoslash\n// @errors: 2339\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\nfunction isEmail(value: unknown): value is Email {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  // ---cut---\n  // 各プロパティのチェック\n  if (typeof value.from !== \"string\") {\n    return false;\n  }\n\n  return true;\n}\n```\n\nこれを回避するには、[型アサーション](../values-types-variables/type-assertion-as.md)を使って`Email`型に近づけます。このとき、型アサーションは`as Email`でも構いませんが、より型安全にするためにunknown型の[`Record`](../type-reuse/utility-types/record.md)を使うのがお勧めです。\n\n```ts twoslash\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\n// ---cut---\nfunction isEmail(value: unknown): value is Email {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  // 型アサーションでvalueをEmail型に近づける\n  const email = value as Record<keyof Email, unknown>;\n  // 各プロパティのチェック\n  if (typeof email.from !== \"string\") {\n    return false;\n  }\n  return true;\n}\n```\n\nこのときの`Record<keyof Email, unknown>`型は次のように、`Email`のプロパティがすべて`unknown`になった型となります。\n\n```ts twoslash\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\n// ---cut---\ntype MayBeEmail = Record<keyof Email, unknown>;\n//   ^?\n```\n\n最後に、各プロパティのチェックをすべて実装したチェック処理は次のようになります。\n\n```ts twoslash\ntype Email = {\n  from: string;\n  to: string;\n  title: string;\n  subject: string;\n};\n// ---cut---\nfunction isEmail(value: unknown): value is Email {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const email = value as Record<keyof Email, unknown>;\n  if (typeof email.from !== \"string\") {\n    return false;\n  }\n  if (typeof email.to !== \"string\") {\n    return false;\n  }\n  if (typeof email.title !== \"string\") {\n    return false;\n  }\n  return typeof email.subject === \"string\";\n}\n```\n\n:::info バリデーションライブラリも検討しよう\n\nunknown型からobject型へ安全に絞り込むには、プロパティをひとつひとつチェックする必要があります。上の例を見た読者の中には、これを実装するのは大変だと思った方もいるのではないでしょうか。\n\nチェックするプロパティ数が多い場合は、次のバリデーションライブラリを導入したほうがよいでしょう。\n\n- [zod](https://github.com/colinhacks/zod)\n- [superstruct](https://docs.superstructjs.org/)\n\nこれらのライブラリはチェック項目を宣言的に実装できるので、実装コストを抑えられたり、チェック処理の間違いが起きにくくなります。\n\n:::\n\n## unknownの用途\n\n### any型の値をより安全にする\n\nたとえば`JSON.parse()`は戻り値が[any型](../values-types-variables/any.md)です。このまま戻り値を取り回すと、もし存在しないプロパティにアクセスした場合に、実行時エラーになる危険性が残ります。\n\nそこで一旦unknown型にしておくことで、存在しないプロパティへのアクセスにコンパイル時に気づきやすくなります。\n\n```ts twoslash\nconst data: unknown = JSON.parse(\"...\");\n```\n\n### 型アサーションの制約を回避する\n\n通常、[型アサーション](../values-types-variables/type-assertion-as.md)では、まったく異なる型は指定できません。\n\n```ts twoslash\n// @errors: 2352\nconst str = \"a\";\nconst num = str as number;\n```\n\nこのようなときにunknown型を使うことができます。unknown型はどのような型にも型アサーションできるため、目的の型の前に一度unknown型への型アサーションを挟むテクニックがあります。\n\n```ts twoslash\n// @errors: 2352\nconst str = \"a\";\nconst num = str as unknown as number;\n```\n\nただし、型アサーションは実際に値の型をキャストしているのではなく、TypeScriptにその型であると認識させているだけなので型安全性の問題は残ります。\n\n### try-catchで捕捉される値の型\n\nTypeScriptは4.4になって、投げられた例外がany型としてかunknown型のどちらかで捕捉されるかを選べるようになりました。ですが、標準の設定では投げられた例外はany型なのでunknown型にしたい場合はtsconfig.jsonの設定を変える必要があります。\n\n[useUnknownInCatchVariables](../tsconfig//useunknownincatchvariables.md)\n",
      "url": "https://typescriptbook.jp/reference/statements/unknown"
    },
    {
      "title": "switchのフォールスルー問題",
      "content": "# switchのフォールスルー問題\n\nJavaScriptのswitchの`case`には、分岐を抜けさせる働きがありません。分岐を抜けるには、`break`が必要です。`break`を書かない場合、次の分岐も実行されます。この仕様をフォールスルー(fallthrough)と言います。\n\n```ts twoslash\nlet s = \"A\";\nswitch (s) {\n  case \"A\": // breakが無い分岐\n    console.log(1);\n  case \"B\": // この分岐にも処理が続く\n    console.log(2);\n}\n// @log: 1 2 の順で出力される\n```\n\nフォールスルーはしばしばバグの原因になります。TypeScriptでは、コンパイラオプション`noFallthroughCasesInSwitch`を`true`にすると、フォールスルーを警告するようになります。このオプションは有効化しておきましょう。\n\n```ts twoslash\n// @noFallthroughCasesInSwitch: true\n// @errors: 7029\nlet s = \"A\";\nswitch (s) {\n  case \"A\":\n    console.log(1);\n  case \"B\":\n    console.log(2);\n}\n```\n\n[noFallthroughCasesInSwitch](../tsconfig/nofallthroughcasesinswitch.md)\n\n<PostILearned>\n\n😴JavaScriptのswitchのcaseには、分岐を抜けさせる働きがない\n⏩breakを書かないと次の分岐も実行される(フォールスルー)\n🐞フォールスルーはバグになりがち\n✅TypeScriptではnoFallthroughCasesInSwitchを有効にするとフォールスルーが検出される\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/statements/switch-fallthrough"
    },
    {
      "title": "変数のスコープ (scope)",
      "content": "---\nsidebar_label: 変数のスコープ\n---\n\n# 変数のスコープ (scope)\n\nスコープ(scope)とは、変数がどこから参照できるかを定めた変数の有効範囲のことです。JavaScriptには大きく分けてグローバルスコープとローカルスコープの2つがあります。\n\n## グローバルスコープ\n\nグローバルスコープ(global scope)はプログラムのどこからでも参照できる変数です。JavaScriptにはグローバルオブジェクト(global object)と呼ばれるオブジェクトがたったひとつ存在します。ブラウザでは`window`オブジェクトがグローバルオブジェクトです。\n\nグローバル変数は、グローバルオブジェクトのプロパティになります。ブラウザでは、`window`オブジェクトのプロパティになっていることになります。日付の`Date`クラスや、デバッグに使う`console`オブジェクトなどの組み込みAPIはすべて`window`オブジェクトのプロパティです。グローバル変数へのアクセスはwindowを省略して書くことができます。\n\n```js twoslash\nDate === window.Date; //=> true\nconsole === window.console; //=> true\n```\n\nローカルスコープ以外で`var`を用いて変数宣言すると、グローバル変数になります。ただ、`var`の使用は本書としては非推奨です。\n\n[varはもう使わない](../values-types-variables/vars-problems.md)\n\n## ローカルスコープ\n\nローカルスコープ(local scope)は、一定範囲にだけ効く変数スコープです。\n\n### 関数スコープ\n\n関数スコープ(function scope)は、関数内でのみ参照できる範囲です。関数内で宣言された変数は、関数の外から参照できません。\n\n```js twoslash\nfunction func() {\n  const variable = 123;\n  return variable; // 参照できる\n}\nconsole.log(variable); // 参照できない\n```\n\n### レキシカルスコープ\n\nレキシカルスコープ(lexical scope)変数とは、関数を定義した地点から参照できる、関数の外の変数を言います。\n\n```js twoslash\nconst x = 100;\n\nfunction a() {\n  console.log(x); // 関数の外の変数が見える\n}\n\na();\n// @log: 100\n```\n\n### ブロックスコープ\n\nブロックスコープ(block scope)は、ブレース`{ }`で囲まれた範囲だけ有効なスコープです。ブロックスコープ内の変数は、ブロックの外から参照できません。\n\n<!--prettier-ignore-->\n```js twoslash\n{\n  const x = 100;\n  console.log(x);\n// @log: 100\n}\nconsole.log(x); // xを参照できない\n// @error: ReferenceError: x is not defined\n```\n\nブロックスコープはif構文などのブレースにも作用します。条件分岐の中で変数宣言された変数は、条件分岐の外からは参照できないので注意しましょう。\n\n```js twoslash\nif (navigator.userAgent.includes(\"Firefox\")) {\n  const browser = \"Firefox\";\n} else {\n  const browser = \"Firefox以外\";\n}\nconsole.log(browser); // 参照できずエラー\n```\n\n上の例は、ブロックスコープの外で変数宣言するように書き換える必要があります。\n\n```js twoslash\nlet browser;\nif (navigator.userAgent.includes(\"Firefox\")) {\n  browser = \"Firefox\";\n} else {\n  browser = \"Firefox以外\";\n}\nconsole.log(browser); // OK\n```\n\n## 意図しないグローバル変数への代入\n\nJavaScriptではローカルスコープの変数に代入したつもりが、グローバル変数に代入してしまっていたといった事故が起こりえます。ローカル変数を宣言する場合は、`let`や`const`を用いますが、これを書き忘れた変数代入は、グローバル変数になってしまいます。\n\n```js twoslash\nfunction func() {\n  foo = \"ローカル変数のつもり\";\n}\nfunc();\nconsole.log(window.foo);\n// @log: \"ローカル変数のつもり\"\n```\n\nJavaScriptで変数を扱う際は、誤ってグローバル変数を作ってしまわないよう注意が必要です。一方、TypeScriptでは変数宣言されていない変数に代入しようとすると、コンパイラが指摘してくれます。\n\n```ts twoslash\n// @errors: 2304\nfunction func() {\n  foo = \"ローカル変数のつもり\";\n}\n```\n\n意図しないグローバル変数への代入は、JavaScriptの残念な仕様と言えますが、TypeScriptを使っているとこういったトラブルも発見しやすくなります。\n",
      "url": "https://typescriptbook.jp/reference/statements/variable-scope"
    },
    {
      "title": "switch文",
      "content": "# switch文\n\nswitch構文はJavaScriptで条件分岐を行うための構文です。\n\n```js\nswitch (条件) {\n  case 値A:\n    値Aの処理;\n    break;\n  case 値B:\n    値Bの処理;\n    break;\n  default:\n    値Aと値B以外の処理;\n    break;\n}\n```\n\nswitch文を使った例は次です。\n\n```js twoslash\nconst extension = \"ts\";\nswitch (extension) {\n  case \"js\":\n    console.log(\"JavaScript\");\n    break;\n  case \"ts\":\n    console.log(\"TypeScript\");\n    break;\n  default:\n    console.log(\"不明な言語\");\n    break;\n}\n// @log: \"TypeScript\"\n```\n\nこのコードはif-elseで書き直すと次のようになります。\n\n```js twoslash\nconst extension = \"ts\";\nif (extension === \"js\") {\n  console.log(\"JavaScript\");\n} else if (extension === \"ts\") {\n  console.log(\"TypeScript\");\n} else {\n  console.log(\"不明な言語\");\n}\n// @log: \"TypeScript\"\n```\n\ncaseは連続して書くこともできます。\n\n```js twoslash\nconst food = \"🍙\";\nswitch (food) {\n  case \"🍎\":\n  case \"🍓\":\n  case \"🍉\":\n    console.log(\"くだもの\");\n    break;\n  case \"🍙\":\n  case \"🍜\":\n  case \"🍞\":\n    console.log(\"炭水化物\");\n    break;\n  case \"🥕\":\n  case \"🧅\":\n  case \"🥬\":\n    console.log(\"野菜\");\n    break;\n  default:\n    console.log(\"未知の食べ物\");\n    break;\n}\n// @log: \"炭水化物\"\n```\n\n## switchは厳密等価演算\n\nswitch構文でその値であると判断されるのは等価演算(`==`)ではなく厳密等価演算(`===`)です。たとえば`null`と`undefined`は等価演算では等しいとされますが厳密等価演算では等しくありません。\n\n```ts twoslash\nconsole.log(null == undefined);\n// @log: true\nconsole.log(null === undefined);\n// @log: false\n```\n\nこのふたつを使ったswitch構文を作るとそのことがよくわかります。\n\n```ts twoslash\nfunction test(n: unknown): void {\n  switch (n) {\n    case null:\n      console.log(\"THIS IS null\");\n      return;\n    case undefined:\n      console.log(\"THIS IS undefined\");\n      return;\n    default:\n      console.log(\"THIS IS THE OTHER\");\n  }\n}\n\ntest(null);\n// @log: 'THIS IS null'\ntest(undefined);\n// @log: 'THIS IS undefined'\n```\n",
      "url": "https://typescriptbook.jp/reference/statements/switch"
    },
    {
      "title": "anyとunknownの違い",
      "content": "# anyとunknownの違い\n\n`any, unknown`型はどのような値も代入できます。\n\n```ts twoslash\nconst any1: any = null;\nconst any2: any = undefined;\nconst any3: any = true;\nconst any4: any = 0.8;\nconst any5: any = \"Comment allez-vous\";\nconst any6: any = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n\nconst unknown1: unknown = null;\nconst unknown2: unknown = undefined;\nconst unknown3: unknown = true;\nconst unknown4: unknown = 0.8;\nconst unknown5: unknown = \"Comment allez-vous\";\nconst unknown6: unknown = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n```\n\nちなみに逆の概念としてどの値も代入できない`never`という型もありますが、今回は説明を省きます。\n\n`any`型に代入したオブジェクトのプロパティ、メソッドは使用することができます。\n\n```ts twoslash\nconst any4: any = 0.8;\nconst any5: any = \"Comment allez-vous\";\nconst any6: any = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n// ---cut---\nconsole.log(any4.toFixed());\n// @log: 1\nconsole.log(any5.length);\n// @log: 18\nconsole.log(any6.name);\n// @log: \"origin\"\n```\n\n一方、`unknown`型に代入したオブジェクトのプロパティ、メソッドは使用することができません。使用できないどころか、実行することができません。\n\n```ts twoslash\nconst unknown4: unknown = 0.8;\nconst unknown5: unknown = \"Comment allez-vous\";\nconst unknown6: unknown = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n\n// ---cut---\n// @errors: 18046\nconsole.log(unknown4.toFixed());\nconsole.log(unknown5.length);\nconsole.log(unknown6.name);\n```\n\nこれだけ見ると`unknown`型よりも`any`型の方が優れていると思われるかもしれませんがそうではありません。`any`型は言い換えれば**TypeScriptが型のチェックを放棄した型**であり、そのためなんでもできます。`any`型を使うということはTypeScriptでせっかく得た型という利点を手放しているのと同じです。\n\nこれでは存在しているエラーはコンパイル時には気が付けず、ソフトウェアをリリースしたあと実際のユーザーが使ったときに実行時エラーとなります。それが不具合報告や、クレームとなり、被害が拡大していきます。\n\n`any`型に関しては、次のような無茶なコードもTypeScriptは一切関与せず、実行してみてプログラムが実行時エラーになる、初めてこのプログラムが不完全であることがわかります。\n\n```ts twoslash\nconst any6: any = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n\n// ---cut---\nconsole.log(any6.x.y.z);\n// @error: Cannot read property 'z' of undefined\n```\n\n`unknown`型は一貫してTypeScriptがプロパティ、メソッドへのアクセスを行わせません。そのため実行することができず、意図しないランタイム時のエラーを防止します。\n\n```ts twoslash\nconst unknown6: unknown = {\n  x: 0,\n  y: 1,\n  name: \"origin\",\n};\n\n// ---cut---\n// @errors: 18046\nconsole.log(unknown6.x.y.z);\n```\n\nTypeScriptのプロジェクトを作る時に必要なtsconfig.jsonにはこの`any`型の使用を防ぐためのオプションとして`noImplicitAny`があります。既存のJavaScriptのプロジェクトをTypeScriptに置き換えていくのではなく、スクラッチの状態からTypeScriptで作るのであればこの設定を入れるとよいでしょう。\n",
      "url": "https://typescriptbook.jp/reference/statements/any-vs-unknown"
    },
    {
      "title": "never型",
      "content": "# never型\n\n`never`型は「値を持たない」を意味するTypeScriptの特別な型です。\n\n## neverの特性\n\n### 何も代入できない\n\n`never`型には何も代入できません。\n\n```ts twoslash\n// @errors: 2322\nconst foo: never = 1;\n```\n\nたとえ`any`型でも代入は不可能です。\n\n```ts twoslash\n// @errors: 2322\nconst any: any = 1;\nconst foo: never = any;\n```\n\n唯一`never`型は代入できます。\n\n```ts twoslash\nconst foo: never = 1 as never;\n```\n\n### 何にでも代入できる\n\n`never`型はどんな型にも代入できます。\n\n```ts twoslash\nconst nev = 1 as never;\nconst a: string = nev; // 代入OK\nconst b: string[] = nev; // 代入OK\n```\n\n## 値が無いとは\n\n`never`型の「値が無い」とはどういうことでしょうか。たとえば、例外が必ず発生する関数の戻り値です。戻り値は絶対に取れません。そのため、戻り値の型は`never`型になります。\n\n```ts twoslash\nfunction throwError(): never {\n  throw new Error();\n}\n```\n\n終了しない関数も戻り値が`never`型になります。\n\n```ts twoslash\nfunction forever(): never {\n  while (true) {} // 無限ループ\n}\n```\n\n作り得ない値も`never`型になります。たとえば、number型とstring型の両方に代入可能な値は作れません。そのため、number型とstring型の[インターセクション型](../values-types-variables/intersection.md)は`never`型になります。\n\n```ts twoslash\ntype NumberString = number & string;\n//   ^?\n```\n\n## void型とnever型の違い\n\n`void`型は`undefined`が代入できますが、`never`は値を持てません。\n\n```ts twoslash\n// @errors: 2322\nconst ok: void = undefined;\nconst ng: never = undefined;\n```\n\n意味的に戻り値での`void`と`never`は、戻り値が無い点は同じです。関数が終了するかが異なります。`void`は関数が最後まで実行されるという意味です。`never`は関数の処理が中断、もしくは、永遠に続くことを意味します。\n\n| 型      | 戻り値 | 終了するか                           |\n| ------- | ------ | ------------------------------------ |\n| `void`  | 無い   | `return`されるか、最後まで実行される |\n| `never` | 無い   | 中断されるか、永遠に実行される       |\n\nそのため、戻り値が`never`の関数が最後まで到達できてしまう実装の場合、TypeScriptはコンパイルエラーを出します。\n\n```ts twoslash\n// @errors: 2534\nfunction func(): never {}\n```\n\n## neverを使った網羅性チェック\n\n`never`の何も代入できないという特性は、網羅性チェック(exhaustiveness check)に応用できます。網羅性チェックとは、[ユニオン型](../values-types-variables/union.md)を分岐処理するとき、ロジックがすべてのパターンを網羅しているかをコンパイラにチェックさせることを言います。\n\nたとえば、3パターンのユニオン型があるとします。\n\n```ts twoslash\ntype Extension = \"js\" | \"ts\" | \"json\";\n```\n\nこのうち2パターンにだけ対応した分岐処理が次です。これには網羅性がありませんが、TypeScriptは警告を出しません。\n\n```ts twoslash title=\"網羅性がない分岐\"\ntype Extension = \"js\" | \"ts\" | \"json\";\n// ---cut---\nfunction printLang(ext: Extension): void {\n  switch (ext) {\n    case \"js\":\n      console.log(\"JavaScript\");\n      break;\n    case \"ts\":\n      console.log(\"TypeScript\");\n      break;\n    // \"json\"に対する分岐がない\n  }\n}\n```\n\n### 網羅性チェックの基本\n\n網羅性チェックを行うには、`default`分岐で網羅性をチェックしたい値をnever型に代入します。すると、TypeScriptが代入エラーの警告を出すようになります。\n\n```ts twoslash title=\"網羅性チェックがついた分岐\"\n// @errors: 2322\ntype Extension = \"js\" | \"ts\" | \"json\";\n// ---cut---\nfunction printLang(ext: Extension): void {\n  switch (ext) {\n    case \"js\":\n      console.log(\"JavaScript\");\n      break;\n    case \"ts\":\n      console.log(\"TypeScript\");\n      break;\n    default:\n      const exhaustivenessCheck: never = ext;\n      break;\n  }\n}\n```\n\n### 例外による網羅性チェック\n\n一歩進んで網羅性チェック用の例外クラスを定義するのがお勧めです。このクラスは、コンストラクタ引数に`never`型を取る設計にします。\n\n```ts twoslash title=\"網羅性チェック関数\"\nclass ExhaustiveError extends Error {\n  constructor(value: never, message = `Unsupported type: ${value}`) {\n    super(message);\n  }\n}\n```\n\nこの例外を`default`分岐で投げるようにします。コンストラクタに網羅性をチェックしたい引数を渡します。こうしておくと、網羅性が満たされていない場合、TypeScriptが代入エラーを警告します。\n\n```ts twoslash\n// @errors: 2345\ntype Extension = \"js\" | \"ts\" | \"json\";\nclass ExhaustiveError extends Error {\n  constructor(value: never, message = `Unsupported type: ${value}`) {\n    super(message);\n  }\n}\n// ---cut---\nfunction printLang(ext: Extension): void {\n  switch (ext) {\n    case \"js\":\n      console.log(\"JavaScript\");\n      break;\n    case \"ts\":\n      console.log(\"TypeScript\");\n      break;\n    default:\n      throw new ExhaustiveError(ext);\n  }\n}\n```\n\n例外にしておく利点は2つあります。\n\n1. `noUnusedLocals`に対応可能\n2. 実行時を意識したコードになる\n\n#### `noUnusedLocals`に対応可能\n\nコンパイラオプション[`noUnusedLocals`](../tsconfig/nounusedlocals.md)は使われていない変数について警告を出すかを設定します。これが`true`のとき、変数に代入するだけの網羅性チェックはコンパイルエラーになります。\n\n```ts twoslash title=\"全網羅するも未使用変数で警告される\"\n// @noUnusedLocals: true\n// @errors: 6133\nfunction func(value: \"yes\" | \"no\"): void {\n  switch (value) {\n    case \"yes\":\n      console.log(\"YES\");\n      break;\n    case \"no\":\n      console.log(\"NO\");\n      break;\n    default:\n      const exhaustivenessCheck: never = value;\n      break;\n  }\n}\n```\n\n網羅性チェックを例外にしておくと、未使用変数についてのコンパイルエラーが発生しなくなります。\n\n#### 実行時を意識したコードになる\n\n例外のほうが、コンパイル後のJavaScriptを意識した実装になります。変数代入による網羅性チェックのコードをコンパイルすると、次のJavaScriptが生成されます。\n\n```ts twoslash title=\"コンパイル後のJavaScript(変数代入による網羅性チェック)\"\n// @alwaysStrict: false\n// @showEmit\nfunction func(value: \"yes\" | \"no\"): void {\n  switch (value) {\n    case \"yes\":\n      console.log(\"YES\");\n      break;\n    case \"no\":\n      console.log(\"NO\");\n      break;\n    default:\n      const exhaustivenessCheck: never = value;\n      break;\n  }\n}\n```\n\nコンパイルもとのTypeScriptを知らない者がこのコードを見ると、`exhaustivenessCheck`への代入は意図が不明です。また、網羅性のチェックは実行時に行われません。\n\n例外による網羅性チェックは、コンパイル後コードだけ見ても意図が明瞭です。また、実行時にもチェックが行われます。このほうがよい実装になります。\n\n```ts twoslash title=\"コンパイル後のJavaScript(例外による網羅性チェック)\"\n// @alwaysStrict: false\n// @showEmit\nclass ExhaustiveError extends Error {\n  constructor(value: never, message = `Unsupported type: ${value}`) {\n    super(message);\n  }\n}\nfunction func(value: \"yes\" | \"no\"): void {\n  switch (value) {\n    case \"yes\":\n      console.log(\"YES\");\n      break;\n    case \"no\":\n      console.log(\"NO\");\n      break;\n    default:\n      throw new ExhaustiveError(value);\n  }\n}\n```\n\n<PostILearned>\n\nTypeScriptのneverは「値を持たない」型。\n\n1️⃣特性1: neverへは何も代入できない\n2️⃣特性2: neverは何にでも代入できる\n💥常に例外を起こす関数の戻り値に使える\n👐voidとは異なる\n✅網羅性チェックに応用できる\n\n</PostILearned>\n",
      "url": "https://typescriptbook.jp/reference/statements/never"
    },
    {
      "title": "制御フロー分析と型ガードによる型の絞り込み",
      "content": "# 制御フロー分析と型ガードによる型の絞り込み\n\nTypeScriptは制御フローと型ガードにより、処理の流れに応じて変数の型を絞り込むことができます。\n\n## ユニオン型と曖昧さ\n\nユニオン型で変数の型注釈を書いた時に、片方の型でしか定義されていないメソッドやプロパティにアクセスをすると型エラーが発生します。\n\n```ts twoslash\n// @errors: 2339\nfunction showMonth(month: string | number) {\n  console.log(month.padStart(2, \"0\"));\n}\n```\n\nこれは`month`の変数が`string`or`number`型のどちらかになる可能性があり`number`型が渡された時に未定義なメソッドへのアクセスが発生する危険があるためです。\n\n## 制御フロー分析\n\nTypeScriptは`if`や`for`ループなどの制御フローを分析することで、コードが実行されるタイミングでの型の可能性を判断しています。\n\n先ほどの例に`month`変数が`string`型であることを条件判定を追加することで`month`の`padStart`メソッドの実行時は`month`が`string`型であるとTypeScriptが判断し型エラーを解消することができます。\n\n```ts twoslash\nfunction showMonth(month: string | number) {\n  if (typeof month === \"string\") {\n    console.log(month.padStart(2, \"0\"));\n  }\n}\n```\n\nもう少し複雑な例を見てみましょう。\n\n次の例では`month`の`toFixed`メソッドの呼び出しは条件分岐のスコープ外であり`month`変数の型が`string | number`となるため型エラーが発生します。\n\n```ts twoslash\n// @errors: 2339\nfunction showMonth(month: string | number) {\n  if (typeof month === \"string\") {\n    console.log(month.padStart(2, \"0\"));\n  }\n  console.log(month.toFixed());\n}\n```\n\nこの関数の最初の条件分岐の中に`return`を追記して早期リターンで関数の処理を終了させてみます。\n\n```ts twoslash\nfunction showMonth(month: string | number) {\n  if (typeof month === \"string\") {\n    console.log(month.padStart(2, \"0\"));\n    return;\n  }\n  console.log(month.toFixed());\n}\n```\n\nこの変更によりエラーとなっていた`month`の`toFixed`メソッドの呼び出しの型エラーが解消されます。\n\nこれは制御フロー分析により`month`変数が`string`型の場合は早期リターンにより関数が終了し、`month`の`toFixed`メソッドが実行されるタイミングでは`month`変数は`number`型のみであるとTypeScriptが判断するためです。\n\n## 型ガード\n\n制御フローの説明において、型の曖昧さを回避するために`if(typeof month === \"string\")`という条件判定で変数の型を判定して型の絞り込みを行いました。\n\nこのような型チェックのコードを型ガードと呼びます。\n\n### typeof\n\n代表的な例は`typeof`演算子を利用した型ガードです。\n\n[typeof演算子](../values-types-variables/typeof-operator.md)\n\n次の例では`typeof`で`month`変数の型を`string`型と判定しています。\n\n```ts twoslash\nfunction showMonth(month: string | number) {\n  if (typeof month === \"string\") {\n    console.log(month.padStart(2, \"0\"));\n  }\n}\n```\n\n`typeof`の型ガードでは`typeof null === \"object\"`となる点に注意が必要です。\n\nJavaScriptにおいて`null`はオブジェクトであるため、次の型ガードを書いた場合は`date`変数は`Date | null`に絞り込まれ`null`となる可能性が残ってしまい型エラーが発生します。\n\n```ts twoslash\n// @errors: 18047\nfunction getMonth(date: string | Date | null) {\n  if (typeof date === \"object\") {\n    console.log(date.getMonth() + 1);\n  }\n}\n```\n\n`date != null`の型ガードを追加することで型エラーを解消できます。\n\n```ts twoslash\nfunction getMonth(date: string | Date | null) {\n  if (typeof date === \"object\" && date != null) {\n    console.log(date.getMonth() + 1);\n  }\n}\n```\n\n### instanceof\n\n`typeof`でインスタンスを判定した場合はオブジェクトであることまでしか判定ができません。\n特定のクラスのインスタンスであることを判定する型ガードを書きたい場合は`instanceof`を利用します。\n\n```ts twoslash\nfunction getMonth(date: string | Date) {\n  if (date instanceof Date) {\n    console.log(date.getMonth() + 1);\n  }\n}\n```\n\n### in\n\n特定のクラスのインスタンスであることを明示せず、`in`演算子でオブジェクトが特定のプロパティを持つかを判定する型ガードを書くことで型を絞り込むこともできます。\n\n```ts twoslash\ninterface Wizard {\n  castMagic(): void;\n}\ninterface SwordMan {\n  slashSword(): void;\n}\n\nfunction attack(player: Wizard | SwordMan) {\n  if (\"castMagic\" in player) {\n    player.castMagic();\n  } else {\n    player.slashSword();\n  }\n}\n```\n\n### ユーザー定義の型ガード関数\n\n型ガードはインラインで記述する以外にも関数として定義することもできます。\n\n```ts\nfunction isWizard(player: Player): player is Wizard {\n  return \"castMagic\" in player;\n}\n\nfunction attack(player: Wizard | SwordMan) {\n  if (isWizard(player)) {\n    player.castMagic();\n  } else {\n    player.slashSword();\n  }\n}\n```\n\nこの名称(user-defined type guard)は英語としても長いらしく、型ガード関数(type guarding function, guard's function)と呼ばれることもあります。\n\n[型ガード関数](../functions/type-guard-functions.md)\n\n### 型ガードの変数代入\n\n型ガードに変数を使うこともできます。\nただし、この文法は TypeScript4.4 以降のみで有効なため、使用する場合はバージョンに注意してください。\n\n```ts twoslash\nfunction getMonth(date: string | Date) {\n  const isDate = date instanceof Date;\n  if (isDate) {\n    console.log(date.getMonth() + 1);\n  }\n}\n```\n\n## 関連情報\n\n[any型](../values-types-variables/any.md)\n\n[any vs unknown](any-vs-unknown.md)\n",
      "url": "https://typescriptbook.jp/reference/statements/control-flow-analysis-and-type-guard"
    },
    {
      "title": "三項演算子 (ternary operator)",
      "content": "---\nsidebar_label: 三項演算子\n---\n\n# 三項演算子 (ternary operator)\n\nJavaScriptの三項演算子(ternary operator)は、条件分岐ができる演算子です。条件式、真の場合の値、偽の場合の値の三項を取るため三項演算子と呼ばれています。\n\n```js\n条件式 ? 真の場合の値 : 偽の場合の値;\n```\n\n演算の結果は変数に代入できます。\n\n```js twoslash\nconst age = 20;\nconst drink = age >= 20 ? \"ビール\" : \"ジュース\";\nconsole.log(drink);\n// @log: \"ビール\"\n```\n\n条件分岐といえばif-elseですが、if-elseは構文なので上のようにif-elseを直接、値を返すような書き方はできません。\n\n```js\n// こうした書き方はできない\nconst drink = if (age >= 20) \"ビール\" else \"ジュース\";\n```\n\n三項演算子は条件をネストできます。\n\n```js twoslash\nconst extension = \"ts\";\nconst language =\n  extension === \"js\"\n    ? \"JavaScript\"\n    : extension === \"ts\"\n    ? \"TypeScript\"\n    : extension === \"java\"\n    ? \"Java\"\n    : \"不明\";\n```\n\n上のコードと同等の処理をif-elseで書くと次のようになります。\n\n```js twoslash\nconst extension = \"ts\";\nlet language;\nif (extension === \"js\") {\n  language = \"JavaScript\";\n} else if (extension === \"ts\") {\n  language = \"TypeScript\";\n} else if (extension === \"java\") {\n  language = \"Java\";\n} else {\n  language = \"不明\";\n}\n```\n\n## 関連情報\n\n[if-else文](if-else.md)\n\n[switch文](switch.md)\n",
      "url": "https://typescriptbook.jp/reference/statements/ternary-operator"
    },
    {
      "title": "索引:記号とキーワード",
      "content": "# 索引:記号とキーワード\n\nJavaScriptやTypeScriptのコードには`?.`のような記号や`as`のようなキーワードが使われます。こういった記号やキーワードはGoogleで検索しづらく、意味を調べるのは難しいものです。\n\nこの索引は、JavaScriptとTypeScriptの記号やキーワードから、その名前や意味を調べられるようにするためのものです。コードを読んでいて未知の記号やキーワードに出くわしたら、その意味や使い方を調べる手がかりにしてください。\n\nここで扱う記号とキーワードには、JavaScript由来のもの、つまり、JavaScriptとTypeScriptに共通して使えるものと、TypeScriptでのみ使えるものを併記しています。JavaScript由来のものには![js]のマークを、TypeScript固有のものには![ts]マークを表示しています。\n\n<!--\n:::編集者ノート:::\n記号はASCIIコード順です。\nキーワードはアルファベット順です。\n-->\n\n[js]: /img/js.svg\n[ts]: /img/ts.svg\n\n## 記号\n\n### `!` 論理否定演算子 (logical not operator) ![js]\n\n真値と偽値を反転します。\n\n### `!` 非Nullアサーション (non-null assertion operator) ![ts]\n\n値がnullやundefinedでないことを宣言し、コンパイラーに値を非Nullとして解釈させます。\n\n```ts twoslash\nfunction firstChar(text: string | undefined) {\n  // コンパイルエラーにならない\n  return text!.charAt(0);\n}\n```\n\n### `!` 明確な割り当てアサーション演算子 (definite assignment assertion operator) ![ts]\n\nクラスのプロパティが型アノテーションで示された型でセットされていることをコンパイラーに伝える記号です。\n\n```ts twoslash\nclass Example {\n  public foo!: number;\n}\n```\n\nまたは、変数の値が型アノテーションで示された型でセットされていることをコンパイラーに伝える記号です。\n\n```ts twoslash\nlet numbers!: number[];\n```\n\n[definite assignment assertion](./reference/values-types-variables/definite-assignment-assertion.md)\n\n### `!!` Double Bang ![js]\n\ndouble bangはJavaScriptで定義されている演算子ではなく、論理否定演算子を2つ連続したイディオムです。値がtruthyかを求めるときに使われます。\n\n### `!=` 不等価演算子 (inequality operator) ![js]\n\n左の値と右の値が異なるか判定します。型が異なる場合は型変換されて比較されます。\n\n```js twoslash\n\"1\" != 1;\n// @log: false\n```\n\n### `!==` 厳密不等価演算子 (strict inequality operator) ![js]\n\n型を含めて左の値と右の値が異なるか判定します。\n\n```js twoslash\n1 !== \"1\";\n// @log: true\n```\n\n### `\"` 文字列リテラル (string literal) ![js]\n\n`\"foo\"`のように文字列リテラルの開始と終了に使われる記号です。\n\n### `#` プライベートプロパティ (private property) ![js]\n\nクラスのプロパティのうち`#`で始まるプロパティはプライベートになります。\n\n```js twoslash\nclass ExampleClass {\n  #privateField;\n  #privateMethod() {}\n  static #PRIVATE_STATIC_FIELD;\n  static #privateStaticMethod() {}\n}\n```\n\n### `$` ドル変数 (dollar variable) ![js]\n\n慣習的にjQueryなどのライブラリで変数として使われることがあります。変数名として`$`が使われる場合は、JavaScriptとしては変数以上の特別な意味はありません。\n\n### `$` 文字列中の変数展開 (placeholder) ![js]\n\nテンプレートリテラル内で変数を展開するときに用いられる記号です。\n\n```js twoslash\nconst name = \"John\";\nconsole.log(`Hi, ${name}.`);\n// @log: \"Hi, John.\"\n```\n\n### `%` 剰余演算子 (reminder operator) ![js]\n\n左の値を右の値で割った余りを計算します。\n\n```js twoslash\n12 % 5;\n// @log: 2\n```\n\n### `%=` 剰余代入 (reminder assignment) ![js]\n\n左の変数の値に右の値で割り算した余りを左の変数に割り当てます。\n\n### `&` ビット論理積 (bitwise and) ![js]\n\n左の値と右の値で共にビットが1である位置のビットを1に します。\n\n```js twoslash\nconst a = 1;\n// @log: 00000001\nconst b = 5;\n// @log: 00000101\nconsole.log(a & b);\n// @log: 00000001\n// 出力: 1\n```\n\n### `&` インターセクション型 (intersection type) ![ts]\n\n複数の型を組み合わせたインターセクション型を定義します。\n\n```ts twoslash\ninterface Swordsman {\n  sword: string;\n}\ninterface Wizard {\n  magic: string;\n}\ntype MagicalSwordsman = Swordsman & Wizard;\n```\n\n[インターセクション型 (intersection type)](reference/values-types-variables/intersection.md)\n\n### `&=` ビット論理積代入 (bitwise and assignment) ![js]\n\n左の変数の値と右の値で共にビットが1である位置のビットを1にした結果を左の変数に割り当てます。\n\n```js twoslash\nlet a = 1;\n// @log: 00000001\nconst b = 5;\n// @log: 00000101\na &= b;\nconsole.log(a);\n// @log: 00000001\n// 出力: 1\n```\n\n### `&&` 論理積 (logical and) ![js]\n\n左の値がtruthyな場合は右の値を返します。そうでないときは左の値を返します。\n\n特にboolean値が与えられた場合は、双方とも`true`のときに`true`を返し、そうでないときに`false`を返します。\n\n```js twoslash\nconsole.log(true && true);\n// @log: true\nconsole.log(true && false);\n// @log: false\n\nconsole.log(1 && \"\");\n// @log: \"\"\n```\n\n### `&&=` 論理積代入 (logical and assignment) ![js]\n\n左の変数と右の値の`&&`論理積の結果を左の変数に割り当てます。\n\n```js twoslash\nlet a = true;\nlet b = 1;\na &&= b;\n\nconsole.log(a);\n// @log: 1\n```\n\n### `'` 文字列リテラル (string literal) ![js]\n\n`'foo'`のように文字列リテラルの開始と終了に使われる記号です。\n\n### `()` 即時実行関数の一部 (IIFE: immediately invoked function expression) ![js]\n\n定義されるとすぐ実行される即時実行関数式(IIFE; Immediately Invoked Function Expression)の一部に用いられる書き方です。即時実行関数式そのものがデザインパターンで、その一部である`()`は関数呼び出しのカッコであり、JavaScriptの特別な演算子や構文というわけではありません。即時実行関数式は即時関数と呼ばれることがあります。\n\n```js\n(function () {})();\n//              ^^\n(function () {})();\n//              ^^\n(() => {})();\n//        ^^\n```\n\n### `*` 乗算演算子 (multiplication operator) ![js]\n\n左の値と右の値を掛け算します。\n\n### `*` ジェネレーター関数の宣言 (generator) ![js]\n\n`Generator`オブジェクトを返すジェネレーター関数を宣言するときに用いられる記号です。\n\n```js twoslash\nfunction* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 2;\n}\n```\n\n### `*` yield\\*式 (yield) ![js]\n\n別のジェネレーターに移譲する式を書くときに用いられる記号です。\n\n```js twoslash\nfunction* func1() {\n  yield 123;\n}\n\nfunction* func2() {\n  yield* func1();\n  //   ^ここ\n}\n```\n\n### `*=` 乗算代入 (multiplication assignment) ![js]\n\n左の変数の値と右の値を掛け算した結果を左の変数に割り当てます。\n\n### `**` べき乗演算子 (exponentiation) ![js]\n\n左の値を右の値でべき乗します。\n\n```js twoslash\n2 ** 3;\n// @log: 8\n```\n\n### `**=` べき乗代入 (exponentiation assignment) ![js]\n\n左の変数の値を右の値でべき乗した結果を左の変数に割り当てます。\n\n### `+` 単項正値演算子 ![js]\n\nnumber型に変換します。\n\n```js twoslash\n+\"1\";\n// @log: 1\n```\n\n### `+` 加算演算子 (addition operator) ![js]\n\n2つの値を足し算します。\n\n### `+` 文字列結合演算子 (concatenation operator) ![js]\n\n2つの文字列を結合します。\n\n### `+` 修飾子の付加 ![ts]\n\n`readonly`や`?`などの修飾子を追加します。\n\n何も指定しない場合は暗黙的に`+`が付与されるので`+`を実際に利用する機会はおそらくありません。\n\n```ts twoslash\ntype MyPartial<T> = {\n  [k in keyof T]+?: T[k];\n};\n\ntype MyReadonly<T> = {\n  +readonly [k in keyof T]: T[k];\n};\n```\n\n### `+=` 加算代入 (addition assignment) ![js]\n\n左の変数の値とに右の値を足し算した結果を左の変数に割り当てます。\n\n### `++` インクリメント (increment) ![js]\n\n変数に`1`を足す演算子です。\n\n```js twoslash\nlet x = 3;\nx++;\nconsole.log(x);\n// @log: 4\n```\n\n### `,` 関数引数の区切り ![js]\n\n複数の引数を関数に与えたり、複数の引数を受け取る関数宣言に用いる記号です。\n\n```js twoslash\nfunction plus(x, y, z) {\n  return x + y + z;\n}\nplus(1, 2, 3);\n```\n\n### `,` 配列要素の区切り ![js]\n\n複数の要素を持つ配列を宣言するときに用いる記号です。\n\n```js twoslash\nconst numbers = [1, 2, 3];\n```\n\n### `,` オブジェクトプロパティの区切り ![js]\n\n複数のプロパティを持つオブジェクトを宣言するときに用いる記号です。\n\n```js twoslash\nconst data = {\n  property1: 1,\n  property2: true,\n  property3: \"hello\",\n};\n```\n\n### `,` タプル型の要素の区切り ![ts]\n\n複数の要素を持つタプル型を宣言するときに用いる記号です。\n\n```ts twoslash\ntype Tuple = [number, string, boolean];\n```\n\n### `,` カンマ演算子 (comma operator) ![js]\n\n左から右に式を評価をして、一番右の評価した値を返します。\n\n```js twoslash\nlet x = -1;\nconst a = (x++, x++, x > 0);\nconsole.log(a);\n// @log: true\n```\n\n### `-` 単項負値演算子 ![js]\n\n正負を反転してnumber型に変換します。\n\n```js twoslash\n-\"1\";\n// @log: -1\n```\n\n### `-` 減算演算子 (subtraction operator) ![js]\n\n2つの値を引き算します。\n\n### `-` 修飾子の削除 ![ts]\n\n`readonly`や`?`などの修飾子を削除します。\n\n```ts twoslash\ntype MyRequired<T> = {\n  [k in keyof T]-?: T[k];\n};\n\ntype Writable<T> = {\n  -readonly [k in keyof T]: T[k];\n};\n```\n\n### `-=` 減算代入 (subtraction assignment) ![js]\n\n左の変数の値から右の値を引き算した結果を左の変数に割り当てます。\n\n### `--` デクリメント (decrement) ![js]\n\n変数に`1`を引き算する演算子です。\n\n```js twoslash\nlet x = 3;\nx--;\nconsole.log(x);\n// @log: 2\n```\n\n### `.` プロパティへのアクセス (dot operator) ![js]\n\nオブジェクトのプロパティにアクセスするときに用いる記号です。\n\n```js twoslash\nconst object = { property: 123 };\nobject.property;\n// @log: 123\n```\n\n### `...` スプレッド構文 (spread syntax) ![js]\n\n配列などの反復可能オブジェクトを関数の引数にする構文です。\n\n```js twoslash\nfunction sum(x, y, z) {\n  return x + y + z;\n}\nconst numbers = [1, 2, 3];\nconsole.log(sum(...numbers));\n// @log: 6\n```\n\nまたは、配列などの反復可能オブジェクトを配列要素に展開する構文です。\n\n```js twoslash\nconst numbers = [1, 2, 3];\nconst newNumbers = [0, ...numbers, 4];\nconsole.log(newNumbers);\n// @log: [ 0, 1, 2, 3, 4 ]\n```\n\nまたは、オブジェクトのプロパティを展開する構文です。\n\n```js twoslash\nconst object = { x: 1, y: 2 };\nconst newObject = { ...object, z: 3 };\nconsole.log(newObject);\n// @log: { x: 1, y: 2, z: 3 }\n```\n\n### `...` 残余構文 (rest syntax) ![js]\n\n関数の残りの引数をひとつの配列として受け取るのに用いられる構文です。\n\n```js twoslash\nfunction func(a, b, ...rest) {\n  return rest;\n}\nconsole.log(func(1, 2, 3, 4, 5));\n// @log: [ 3, 4, 5 ]\n```\n\nまたは、配列などの反復可能オブジェクトの残りの要素を取り出す構文です。\n\n```js twoslash\nconst numbers = [1, 2, 3, 4, 5];\nconst [first, second, ...rest] = numbers;\nconsole.log(rest);\n// @log: [ 3, 4, 5 ]\n```\n\nまたは、オブジェクトの残りのプロパティを取り出す構文です。\n\n```js twoslash\nconst object = { a: 1, b: 2, c: 3, d: 4 };\nconst { a, b, ...rest } = object;\nconsole.log(rest);\n// @log: { c: 3, d: 4 }\n```\n\n### `/` 除算演算子 (division operator) ![js]\n\n左の値を右の値で割り算します。\n\n### `/` 正規表現リテラル (regular expression literal) ![js]\n\n`/[0-9]+/`のような正規表現リテラルの前後に書かれる記号です。\n\n### `/=` 除算代入 (division assignment) ![js]\n\n左の変数の値を右の値で割り算した結果を左の変数に割り当てます。\n\n### `//` 一行コメント (one line comment) ![js]\n\n行コメントの開始を表す記号です。\n\n### `/*` 複数行コメント (multiline comment) ![js]\n\n複数行コメントの開始を表す記号です。\n\n```js\n/*\n コメント\n */\n```\n\n### `/**` JSDoc\n\n慣習的にJSDocなどのドキュメンテーションコメントの開始を表す記号です。これはJavaScriptやTypeScriptの構文ではなく、複数行コメントを用いたドキュメンテーションに慣習的に用いられるものです。\n\n### `:` オブジェクトの一部 ![js]\n\nオブジェクトプロパティのキーと値の対関係を表すのに用いられる記号です。\n\n```js twoslash\nconst object = { a: 1, b: 2, c: 3, d: 4 };\n```\n\n### `:` 三項演算子の一部 (conditional operator) ![js]\n\n`a ? b : c`のような三項演算子のelseを表すのに用いられる記号です。\n\n### `:` 型アノテーション (type annotation) ![ts]\n\n変数の型アノテーションに用いられる記号です。\n\n```ts twoslash\nconst variable: number = 20;\n```\n\nまたは、関数の引数や戻り値の型アノテーションに用いられる記号です。\n\n```ts twoslash\nfunction numberToString(x: number): string {\n  return x.toString();\n}\n```\n\n### `<` 小なり演算子 (less than operator) ![js]\n\n左の値が右の値よりも小さいか判定します。\n\n### `<` ジェネリクス (generic) ![ts]\n\nジェネリクスの型引数の開始に用いられる記号です。\n\n```ts twoslash\nfunction func<T>(x: T) {}\nconst result = func<string>(\"hello\");\n```\n\n[ジェネリクス (generics)](/reference/generics)\n\n### `<` JSX ![ts]\n\n[JSX](./reference/jsx/README.md)と呼ばれるXMLリテラルの開始に現れる記号です。\n\n```tsx twoslash title=\"Hello.tsx\"\nfunction Hello() {\n  return <div>HELLO</div>;\n}\n```\n\n### `<` 型アサーション (type assertion) ![ts]\n\n型アサーションに用いられる記号です。`as`の別の書き方です。\n\n```ts twoslash\nlet someValue: unknown = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n### `<=` 小なりイコール演算子 (less than or equal) ![js]\n\n左の値が右の値以下か判定します。\n\n### `<<` ビット左シフト演算子 (left shift operator) ![js]\n\n左の値のビットを右の値の数だけ左にずらします。\n\n```js twoslash\nconst a = 1;\n// @log: 00000001\nconst b = 3;\nconsole.log(a << b);\n// @log: 00001000\n// 出力: 8\n```\n\n### `<<=` 左シフト代入 (left shift assignment) ![js]\n\n左の変数の値のビットを右の値の数だけ左にずらした結果を左の変数に割り当てます。\n\n```js twoslash\nlet a = 1;\n// @log: 00000001\nconst b = 3;\na <<= b;\nconsole.log(a);\n// @log: 00001000\n// 出力: 8\n```\n\n### `=` 代入演算子 (assignment) ![js]\n\n左の変数に右の値を割り当てます。\n\n### `==` 等価演算子 (equality) ![js]\n\n左の値と右の値が等しいか判定します。型が異なる場合は型変換されて比較されます。\n\n```js twoslash\n\"1\" == 1;\n// @log: true\n```\n\n### `===` 厳密等価演算子 (strict equality) ![js]\n\n型を含めて左の値と右の値が等しいか判定します。\n\n```js twoslash\n\"1\" === 1;\n// @log: false\n```\n\n### `=>` アロー関数の一部 (arrow function) ![js]\n\nアロー関数の引数と関数ボディーの間に書かれる記号です。\n\n```js twoslash\nconst increment = (num) => num + 1;\n//                 ^^^ 引数\n//                         ^^^^^^^ 関数ボディ\n```\n\n### `>` 大なり演算子 (greater than) ![js]\n\n左の値が右の値よりも大きいか判定します。\n\n### `>=` 大なりイコール演算子 (greater than or equal) ![js]\n\n左の値が右の値以上か判定します。\n\n### `>>` ビット右シフト演算子 (right shift) ![js]\n\n左の値のビットを右の値の数だけ右にずらします。\n\n```js twoslash\nconst a = 8;\n// @log: 00001000\nconst b = 3;\nconsole.log(a >> b);\n// @log: 00000001\n// 出力: 1\n```\n\n### `>>=` 右シフト代入 (right shift assignment) ![js]\n\n左の変数の値のビットを右の値の数だけ右にずらした結果を左の変数に割り当てます。\n\n### `>>>` 符号なし右シフト演算子 (unsigned right shift) ![js]\n\n左の値のビットを右の値の数だけ右にずらします。左に入る符号ビットは常に0になります。\n\n```js twoslash\nconst a = -2;\n// @log: 11111111111111111111111111111110\nconst b = 3;\nconsole.log(a >>> b);\n// @log: 00011111111111111111111111111111\n// 出力: 536870911\n```\n\n### `>>>=` 符号なし右シフト代入 (unsigned right shift assignment) ![js]\n\n左の変数の値のビットを右の値の数だけ右にずらした結果を左の変数に割り当てます。左に入る符号ビットは常に0になります。\n\n### `?` 三項演算子の一部 (conditional operator) ![js]\n\n三項演算子`a ? b : c`の一部で、条件式の終わりに置かれる記号です。\n\n### `?` オプション修飾子 (optional property) ![ts]\n\nオブジェクトのプロパティを任意プロパティとして定義します。\n\n```ts twoslash\ninterface User {\n  name: string;\n  // name は必須\n  age?: number;\n  // age は任意\n}\nconst user: User = { name: \"taro\" };\n```\n\nまたは、関数の引数を必須ではなくします。\n\n```ts twoslash\nfunction func(x?: number) {}\nfunc();\n// xがなくてもOK\n```\n\n### `?.` オプショナルチェーン (optional chaining) ![js]\n\nプロパティのアクセス元が`null`または`undefined`のときにエラーを発生させずに`undefined`を返します。\n\n```js twoslash\nconst user = null;\nconsole.log(user.name);\n// @error: Cannot read property 'name' of null\nconsole.log(user?.name);\n// @log: undefined\n```\n\n### `??` Null合体 (nullish coalescing operator) ![js]\n\n左の値が`null`または`undefined`のときに右の値を返します。そうでない場合は左の値を返します。\n\n```js twoslash\nconsole.log(undefined ?? 1);\n// @log: 1\nconsole.log(2 ?? 1);\n// @log: 2\n```\n\n### `??=` Null合体代入 (logical nullish assignment) ![js]\n\n左の変数の値が`null`または`undefined`の場合のみ右の値を左の変数に割り当てます。\n\n```js twoslash\nconst user1 = { name: undefined };\nuser1.name ??= \"taro\";\nconsole.log(user1.name);\n// @log: taro\n\nconst user2 = { name: \"kaori\" };\nuser2.name ??= \"taro\";\nconsole.log(user2.name);\n// @log: kaori\n```\n\n### `@` デコレーター (decorator) ![ts]\n\nデコレーターはクラスやクラスメンバーに注釈を追加するもので、デコレーターを使うのに用いられる記号です。\n\n### `[` 配列リテラル (array literal notation) ![js]\n\n`[1, 2, 3]`のような配列リテラルの開始に用いられる記号です。\n\n### `[` アクセッサー (bracket notation) ![js]\n\n配列の要素やオブジェクトのプロパティにアクセスするときに用いられる記号です。\n\n```js twoslash\nconst numbers = [1, 2, 3];\nnumbers[0];\n// @log: 1\nconst object = { a: 1, b: 2 };\nobject[\"a\"];\n// @log: 1\n```\n\n### `[` 配列の分割代入 (destructuring assignment) ![js]\n\n配列などの反復可能オブジェクトの分割代入の開始に用いられる記号です。\n\n```js twoslash\nconst numbers = [1, 2, 3];\nconst [first, ...rest] = numbers;\n// 分割代入\nconsole.log(first, rest);\n// @log: 1 [ 2, 3 ]\n\n// 分割代入\nfunction func([first, ...rest]) {\n  console.log(first, rest);\n}\nfunc([1, 2, 3]);\n// @log: 1 [ 2, 3 ]\n```\n\n### `[` インデックス型 (index signature) ![ts]\n\nインデックス型(index signature)の開始に用いられる記号です。\n\n```ts twoslash\ntype StringKeysAndStringValues = {\n  [key: string]: string;\n};\n```\n\n[インデックス型 (index signature)](reference/values-types-variables/object/index-signature.md)\n\n### `[]` 配列型 (array type) ![ts]\n\n配列型を表現するのに用いられる記号です。\n\n```ts twoslash\nclass Foo {}\n// ---cut---\nlet names: string[];\ntype FooList = Foo[];\n```\n\n### `\\` 文字列エスケープシーケンス (escaping character) ![js]\n\n文字列のエスケープシーケンスの開始に用いられる記号です。\n\n```js twoslash\nconst lineBreak = \"\\n\";\n```\n\n### `^` ビット排他的論理和 (bitwise xor) ![js]\n\n左の値と右の値でビットの値が異なる位置のビットを1にします。\n\n```js twoslash\nconst a = 1;\n// @log: 00000001\nconst b = 5;\n// @log: 00000101\nconsole.log(a ^ b);\n// @log: 00000100\n// 出力: 4\n```\n\n### `^=` ビット排他的論理和代入 (bitwise xor assignment) ![js]\n\n左の変数の値と右の値でビットの値が異なる位置のビットを1にした結果を左の変数に割り当てます。\n\n### `_` 数値の区切り文字 ![js]\n\n数値の可読性のために、桁区切りとして用いられる記号です。\n\n```js twoslash\nconst hyakuman = 1_000_000;\n```\n\n### `_` アンダースコア変数 ![js]\n\n慣習的にlodashなどのライブラリで変数として使われることがあります。変数名として`_`が使われる場合は、JavaScriptとしては変数以上の特別な意味はありません。\n\nまた、慣習的に使わない変数の受け取り先に使われることがあります。たとえば、2つの引数を受け取るコールバック関数で、第2引数だけを使う場合、第1引数をアンダースコアにする書き方をするコードが中にはあります。\n\n```js twoslash\n[1, 2, 3].map((_, index) => {\n  //  _ は 1, 2, 3のような要素値。それを使わないという意味で _ にしている\n});\n```\n\n### `` ` `` テンプレートリテラル (template literal) ![js]\n\nテンプレートリテラル(テンプレート文字列)の前後に置かれる記号です。\n\n```js\n`string text`;\n```\n\n### `{` ブロック文 (block) ![js]\n\nif文やfor文などの構文に付随して使われる記号です。\n\n```js twoslash\nlet isOK = false;\n// ---cut---\nif (isOK) {\n  // ...\n} else {\n  // ...\n}\n```\n\nif文やfor文などの構文を伴わないブロック文は、単に変数のスコープを分けることを目的にしていることがあります。\n\n```js twoslash\n{\n  const value = 1;\n}\n{\n  const value = 2;\n  // 上と同じ変数名で初期化しているが、スコープが別になるためエラーにならない。\n}\n```\n\n### `{` オブジェクトの分割代入 (destructuring assignment) ![js]\n\nオブジェクトの分割代入に用いられる記号です。\n\n```js twoslash\nconst object = { a: 1, b: 2, c: 3, d: 4 };\nconst { a, b, ...rest } = object; // 分割代入\nconsole.log(a, b, rest);\n// @log: 1 2 { c: 3, d: 4 }\n\n// 分割代入\nfunction func({ a, b, ...rest }) {\n  console.log(a, b, rest);\n}\nfunc(object);\n// @log: 1 2 { c: 3, d: 4 }\n```\n\n### `|` ビット論理和 (bitwise or) ![js]\n\n左の値と右の値でどちらのビットが1である位置のビットを1にします。\n\n```js twoslash\nconst a = 0b010;\nconst b = 0b101;\nconsole.log((a | b) === 0b111);\n// @log: true\n```\n\n### `|` ユニオン型 (union type) ![ts]\n\n複数の型を組み合わせたユニオン型を定義します。\n\n```ts twoslash\ntype ID = string | number;\nconst id1 = \"e29b41\"; // OK\nconst id2 = 100; // OK\nconst id3 = true; // ERROR\n```\n\n### `|=` ビット論理和代入 (bitwise or assignment) ![js]\n\n左の変数の値と右の値でどちらかがのビットが1である位置のビットを1にした結果を左の変数に割り当てます。\n\n### `||` 論理和 (logical or) ![js]\n\n左の値がtruthyな場合はそれを返します。そうでないときは右の値を返します。\n\n特にboolean値の場合は、ひとつでも`true`のときに`true`を返し、そうでない場合に`false`を返します。\n\n```js twoslash\nconsole.log(true || false);\n// @log: true\nconsole.log(false || false);\n// @log: false\n\nconsole.log(false || \"abc\");\n// @log: \"abc\"\n```\n\n### `||=` 論理和代入 (logical or assignment) ![js]\n\n左の変数と右の値の`||`論理和の結果を左の変数に割り当てます。\n\n```js twoslash\nlet a = false;\nlet b = 1;\na ||= b;\nconsole.log(a);\n// @log: 1\n```\n\n### `~` ビット否定演算子 (bitwise not) ![js]\n\nビットを反転します。\n\n```js twoslash\nconst a = 1;\n// @log: 00000001\nconsole.log(~a);\n// @log: 11111110\n// 出力: -2\n```\n\n### `~~` Double Tilde ![js]\n\nビット否定演算子を2つ重ねたもので、小数点以下を消し去る計算をするイディオムです。JavaScriptにこういう演算子があるわけではなく慣習的なものです。double tildeの計算結果は、正の数については`Math.floor`と同じに、負の数は`Math.ceil`と同じになります。\n\n```js twoslash\n~~1.5;\n// @log: 1\nMath.floor(1.5);\n// @log: 1\nMath.ceil(1.5);\n// @log: 2\n\n~~-1.5;\n// @log: -1\nMath.floor(-1.5);\n// @log: -2\nMath.ceil(-1.5);\n// @log: -1\n```\n\n## キーワード\n\n### `as` 型アサーション (type assertion) ![ts]\n\nTypeScriptコンパイラーが解釈した型を上書きする「型アサーション」に用いられるキーワードです。\n\n### `as const` constアサーション (const assertion) ![ts]\n\n変数に含まれるハードコーディングされた値をそのリテラル型で宣言し、読み取り専用にします。\n\n```ts twoslash\nlet hello = \"hello\";\n//      ^?\nlet bye = \"bye\" as const;\n//  ^?\nconst wolf = { caniformia: \"Wolf\" };\n//    ^?\nconst fox = { caniformia: \"Fox\" } as const;\n//    ^?\n```\n\n### `const` const ![js]\n\nブロックスコープを持つ定数定義です。スコープ内では再代入も再宣言もできません。\n\n### `get` ゲッター (get) ![js]\n\nオブジェクトのプロパティが参照されたときに対応する関数が呼ばれます。\n\n```js twoslash\nconst exam = {\n  scores: [50, 70, 90, 80, 100, 60],\n  get best() {\n    return Math.max(...this.scores);\n  },\n};\n\nconsole.log(exam.best);\n// @log: 100\n```\n\n### `in` in演算子 (in operator) ![js]\n\nプロパティがオブジェクトにある場合に`true`を返す演算子です。\n\n```js twoslash\nconst book = { name: \"サバイバルTypeScript\" };\nconsole.log(\"name\" in book);\n// @log: true\nconsole.log(\"price\" in book);\n// @log: false\n```\n\n### `in` for-in構文 ![js]\n\nオブジェクトの列挙可能プロパティをループするfor-in構文です。\n\n```js twoslash\nconst drink = { name: \"Coffee\", price: 500 };\nfor (const property in drink) {\n  console.log(property);\n}\n```\n\n### `in` Mapped Types ![ts]\n\nMapped Typesに現れる`in`です。\n\n```ts twoslash\ntype MappedType = {\n  [key in \"foo\" | \"bar\"]: string;\n};\n```\n\n[Mapped Types](reference/type-reuse/mapped-types.md)\n\n### `is` 型アサーション関数の一部 (user-defined type guard) ![ts]\n\n型ガードに用いる型アサーション関数の戻り値の型アノテーション部分に用いられるキーワードです。\n\n```ts twoslash\nclass Animal {\n  public legs: number;\n\n  public constructor(legs: number) {\n    this.legs = legs;\n  }\n}\nclass Bird extends Animal {}\nclass Duck extends Bird {}\n// ---cut---\nfunction isDuck(animal: Animal): animal is Duck {\n  return animal.legs === 2;\n}\n```\n\n### `keyof` keyof型演算子 (keyof) ![ts]\n\nオブジェクトの型からプロパティ名を型として返す型演算子です。\n\n### `n` bigintリテラル (bigint literal) ![js]\n\n数字がbigintリテラルであることを表すのに用いる記号です。\n\n```js\n100n; // bigint型の100\n```\n\n### `typeof` typeof演算子 (typeof) ![js]\n\n与えられた値の型を表す文字列を返します。\n\n```js twoslash\nconsole.log(typeof 123);\n// @log: \"number\"\n```\n\n### `typeof` typeof型演算子 (typeof) ![ts]\n\n変数から型を抽出する演算子です。\n\n### `set` セッター (set) ![js]\n\nオブジェクトのプロパティを変更するときに対応する関数が呼ばれます。\n\n```js twoslash\nconst prize = {\n  latest: \"\",\n  history: [],\n  set winner(winner) {\n    this.latest = winner;\n    this.history.push(winner);\n  },\n};\n\nprize.winner = \"Stanislas Wawrinka\";\nprize.winner = \"Rafael Nadal Parera\";\nprize.winner = \"Novak Đoković\";\n\nconsole.log(prize.latest);\n// @log: \"Novak Đoković\"\nconsole.log(prize.history);\n// @log: [ 'Stanislas Wawrinka', 'Rafael Nadal Parera', 'Novak Đoković' ]\n```\n\n### `void` void演算子 (void) ![js]\n\n戻り値を`undefined`にします。\n\n```js twoslash\nconsole.log(void 123);\n// @log: undefined\n```\n\n### `void` void型 (void) ![ts]\n\n戻り値が`undefined`あるいはない場合に使用します。\n\n```ts twoslash\nfunction returnUndefined(num: number): void {\n  if (num === 0) {\n    return undefined;\n  }\n\n  return;\n}\n```\n\n[void型](reference/functions/void-type.md)\n",
      "url": "https://typescriptbook.jp/symbols-and-keywords"
    },
    {
      "title": "サバイバルTypeScriptとは",
      "content": "---\nsidebar_label: 本書について\n---\n\n# サバイバルTypeScriptとは\n\n本書の目標は、本読者がTypeScriptをすぐに実務で利用できるよう、最短ルートに読者を導く一冊になることです。本書は、TypeScriptの網羅的なドキュメントではありません。逆に、実務であまり使わないTypeScriptの機能は割愛します。扱う内容は、頻出する機能にしぼりにしぼって、「実務でTypeScriptを使うなら、ここだけはおさえておこう」「ここだけはおさえておけば、実務で死なない(=サバイバルできる)」という観点で執筆しています。\n\n本書はTypeScriptを中心に扱いますが、実務上、必要になる知識としてJavaScriptの仕様、フロントエンドフレームワークのReactなどについても扱います。\n\n## 誰に向けて書かれた本か？\n\n本書は、プログラミング経験はあるが、これからTypeScriptをはじめる人、もしくは、始めたばかりという人を対象にしています。たとえば、次のような属性のプログラマを想定しています。\n\n1. 主としてサーバーサイドのプログラミング(PHPやRuby、Javaなど)をしているが、フロントエンドも担当することになった。\n2. JavaScriptの経験があるが、そこまでJavaScriptに精通しているわけではないので、TypeScriptと並行して勉強したい。\n3. RubyやPythonなどの動的型付け言語を主に扱ってきており、型をそこまで意識してこなかったので、型システムについて学ぶ必要性を感じている。\n\n## 本書では扱わないこと\n\n本書は、TypeScript初心者であるものの、プログラミング経験自体はある人を対象読者としています。そのため、「変数とは何か？」「関数とは何か？」といったプログラミングのいろはは本書では扱いません。\n\n## 本書の構成\n\n第2章「TypeScriptのあらまし」では、TypeScriptの概要について触れます。同時に、TypeScriptの良さや、TypeScriptがJavaScriptエコシステムでどういった立ち位置にあるのかを示すことで、全体像を知っていただきます。TypeScriptとは何なのか詳しく知ってもらったり、読者が同僚や属するチームにTypeScriptをPRできるような情報を提供します。TypeScriptの歴史、思想、哲学を知ってもらうことで、どのようなところでTypeScriptがその本領を発揮するのかを学びます。TypeScriptをなぜ使うべきなのか？TypeScriptのアドバンテージは何なのか？TypeScriptとJavaScriptはどのような関係なのか？といった疑問に答えていきます。\n\n第3章「作って学ぶTypeScript」では、さまざまなアプリケーションをTypeScriptで実装するワークショップ形式の解説を通じて、TypeScriptそのものについては軽めに学びながら、TypeScriptを用いた開発の流れを感じ取って頂きます。このワークショップでは、実務の開発により近づけるよう、TypeScriptだけでなく、フロントエンドフレームワークのReact、テストフレームワークのJest、REST APIによるCRUD操作やWebSocketを使ったバックエンドとの通信についても扱って行きます。本章でもTypeScriptの機能や書き方について必要最低限説明しますが、詳しい言語機能の説明は第4章で扱います。\n\n第4章「読んで学ぶTypeScript」では、TypeScriptの言語機能をひとつひとつ解説します。すべての機能のリファレンスというよりは、実際の開発で頻繁に使用するものに限定し、これだけはおさえておきたい機能を中心に取り上げていきます。TypeScript学習者はJavaScriptも並行して学習することが多いので、JavaScriptについての説明も織り交ぜながら解説します。\n\n第5章「Tips」では、JavaScriptやTypeScriptでよく使われるコーディングテクニックを紹介します。\n\n## 本書の使い方\n\n本書は基本的に、章立ての順番通りに読み進めて頂いて問題ありません。\n\n本書の大まかな流れとして、応用編であるアプリ開発(第3章)のほうが、基礎編であるTypeScriptの言語機能(第4章)より先んじていますが、これには実践を通じて学んだほうが学習効率がいいという経験則に基づいています。\n\n意図的に応用編を先に解説しているので、TypeScriptに初めて触れる読者でも、基礎編(第4章)を先に読まなくても、第3章から読み進められるように十分配慮しています。\n\n## 執筆者について\n\n本書は、主に[YYTypeScript](https://yyts.connpass.com/)の参加者を中心とした複数の有志のプログラマが集って執筆を行っています。執筆はいわばオープンソース的に行われており、本書はGitHubでも公開されていて、執筆への参加も随時受け付けています。執筆に興味がある方は、執筆者向け情報ページをご覧ください。\n\n### コントリビューター\n\n本書の企画、執筆、編集等に携わった方々を順不同敬称略で紹介します。\n\n- reoring\n- suin\n- nouphet\n- クロレ\n- jamashita\n- fuubit\n- t-yng\n- kakiuchi\n- philomagi\n- mikkame\n- NkawaK\n- zima\n- tatsuki_sun\n- 建築のジョー\n- ないとう\n- takezoux2\n- \\_rena_h\n\n[![](https://contrib.rocks/image?repo=yytypescript/book)](https://github.com/yytypescript/book/graphs/contributors)\n\nコントリビューターの方でこちらのリストに掲載されていない方がいらっしゃいましたら[GitHub Issues](https://github.com/yytypescript/book/issues/new)にご連絡ください。\n\n## 継続的アップデート\n\n本書は継続的にアップデートされていきます。\n",
      "url": "https://typescriptbook.jp/about"
    },
    {
      "title": "TypeScript Playgroundの使い方",
      "content": "# TypeScript Playgroundの使い方\n\n## TypeScript Playgroundとは\n\n公式が提供している Web で TypeScript を手軽に試すことができる実行環境です。\n\n## TypeScript Playgroundを使う\n\n[TypeScript Playground](https://www.typescriptlang.org/play) にアクセスすれば、すぐに使いはじめることができます。\n\n### プログラムの実行結果を確認する\n\nPlayground にアクセスできたら、早速コードを実行してみましょう。\n\n次のサンプルコードを Playground のエディターに入力します。\n\n```ts\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\nconsole.log(add(1, 2));\n```\n\n入力が終わったらエディターの上部にある`RUN`をクリックして、コードを実行できます。\n\n実行後は右側の`Logs`のタブで実行結果が確認できます。\n\n![](how-to-use-typescript-playground/image1.png)\n\n### JavaScriptのコンパイル結果を確認する\n\nTypeScript を書いていると実際に生成される JavaScript のコードを確認したい時があると思います。そんな時は、右側の`.JS`タブを開くことで生成される JavaScript のコードを確認することができます。\n\n試しに TypeScript 固有の機能である`enum`のコンパイル結果を確認してみます。\n\nエディターに次のコードを入力して`.JS`タブを開いてみてください。\n\n```ts\nenum Color {\n  RED = \"red\",\n  BLUE = \"blue\",\n  GREEN = \"green\",\n}\n\nconsole.log(Color.RED);\n```\n\nTypeScript が`enum`をどのように JavaScript へコンパイルしているか簡単に確認することができます。\n\n![](how-to-use-typescript-playground/image2.png)\n\n### コンパイルエラーの確認方法\n\n次のサンプルコードをエディター上で入力してみてください。エディター上に表示される赤の波線にマウスオーバーをすることでリアルタイムにコンパイルエラーを確認することができます。\n\n```ts\nlet value = \"1\";\nvalue = 1;\nvalue = true;\n```\n\nまた、エディターでマウスオーバーをする以外にも右側の`Errors`タブを表示して、すべてのエラーを一覧で確認することができます。\n\n![](how-to-use-typescript-playground/image3.png)\n\n### 型定義の確認方法\n\n`.D.TS`タブを開くことでエディターのコードから生成される型定義を確認することができます。\n\n```ts\n// コード\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\n// .D.TSの出力\ndeclare function add(a: number, b: number): number;\n```\n\n### 書いたコードを共有する\n\n↓のURLを開いてみてください。エディターにコードが入力された状態で TypeScript Playground が表示されます。\n\n<https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAQwCaoBTIFxhAWwCMBTAJwBpFDcCTSBKRAbwChF3FTioRSllEAaioBuFgF8WLCAgDOcADbEAdArgBzLOgwBGSgCZ69EUA>\n\nTypeScript Playground はページのURLを共有するだけで書いたコードを他の人に共有することができます。\n\nこれは\n\n1. エディターのコードを文字列圧縮ライブラリで圧縮して文字列をURLに設定する &#x20;\n2. URLを共有する &#x20;\n3. 共有されたURLが開かれる時に圧縮された文字列をデコードしてエディターに展開する\n\nという仕組みでコードが共有されています。\n\n新規で Playground を開き上記のリンク先と同じコードをエディターに入力すると、同じURLが生成されるのを確認できます。\n\n### 色々な形式でコードを共有する\n\n上部の`Export`タブから色々な形式でコードを共有するためのテキストを出力することができます。\n\nたとえば`Copy as Markdown Link with Preview`を選択した場合は次のような形式のテキストを出力することができます。\n\n````markdown\n```\nfunction add(a:number, b:number) {\n    return a + b;\n}\n```\n\n[Playground Link](https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAQwCaoBTIFxhAWwCMBTAJwBpFDcCTSBKRAbwFgAoRTxU4qEUpMkQBqKgG52AX3bsICAM5wANsQB0SuAHMs6DAEZKAJnr0xQA)\n````\n\n## TypeScript Playgroundの設定方法\n\n### TypeScript のバージョンの設定\n\n左上のバージョンが記載されたタブをクリックすることで、実行する Type Script のバージョンを変更することができます。\n\nデフォルトでは TypeScript のバージョンは 4.1 以上なので、次のサンプルコードはコンパイルエラーが発生しません。\n\nバージョンを 4.1 未満に変更してみてください。TypeScript のバージョンが変更されたことで\n`Template Literal Types`が非対応となりコンパイルエラーが発生するのが確認できます。\n\n```ts\ntype LocaleLang = \"en\" | \"ja\" | \"fr\";\ntype LocaleId = `locale_${LocaleLang}`;\n```\n\n### TS Config の設定\n\n画面上部の`TS Config`のタブをクリックすることで TS Config の設定をすることができます。\n\n次のサンプルコードをエディターに入力して、出力される JavaScript のコードを`.JS`で確認をするとデフォルトでは\n\n```ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n```\n\nPlayground の初期設定では`module: 'esnext'`が選択されているので、次の出力結果になります。\n\n```js\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n`TS Config`タブを開き`Module`の設定を`CommonJS`に変更をしてみます。TS Config の設定が変更されて`CommonJS`形式で出力される JavaScript のコードを確認することができます。\n\n```js\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.add = void 0;\nfunction add(a, b) {\n  return a + b;\n}\nexports.add = add;\n```\n",
      "url": "https://typescriptbook.jp/how-to-use-typescript-playground"
    },
    {
      "title": "コンパニオンオブジェクトパターン",
      "content": "# コンパニオンオブジェクトパターン\n\nTypeScriptでは値と型に同名を与えてその両方を区別なく使うことができるテクニックがあります。これをコンパニオンオブジェクトと呼びます。\nこれは、クラスを作るほどでもなけどそれっぽいファクトリーメソッドとオブジェクトが欲しいときに重宝します。\n\n## コンパニオンオブジェクト (Companion Object)\n\n次の例は長方形 (Rectangle) を作成するためのメソッド`from()`をもつオブジェクト`Rectangle`とその生成されるオブジェクトの型`Rectangle`です。これらの名称は衝突することなく定義ができ、外部から呼び出したときは同名で使用できます。\n\n次の型と値 (ファクトリーメソッドを持つオブジェクト) は同じファイル`rectangle.ts`に存在するとします。\n\n```ts twoslash\nexport type Rectangle = {\n  height: number;\n  width: number;\n};\n\nexport const Rectangle = {\n  from(height: number, width: number): Rectangle {\n    return {\n      height,\n      width,\n    };\n  },\n};\n```\n\n値も型も同名で定義します。これを外部から import してみます。\n\n```ts twoslash\n// @filename: rectangle.ts\nexport type Rectangle = {\n  height: number;\n  width: number;\n};\n\nexport const Rectangle = {\n  from(height: number, width: number): Rectangle {\n    return {\n      height,\n      width,\n    };\n  },\n};\n// @filename: index.ts\n// ---cut---\nimport { Rectangle } from \"./rectangle\";\n\nconst rec: Rectangle = Rectangle.from(1, 3);\n\nconsole.log(rec.height);\n// @log: 1\nconsole.log(rec.width);\n// @log: 3\n```\n\nこのように import の部分は`Rectangle`のみとなり見通しもつきやすいという特徴があります。ちなみに`Rectangle.from()`のRectangleが値であり`const rec: Rectangle`のRectangleが型です。このようにTypeScriptでは同名の値と型を同時に使うことができます。\n",
      "url": "https://typescriptbook.jp/tips/companion-object"
    },
    {
      "title": "オブジェクトのサブセットを得る",
      "content": "---\ndescription: オブジェクトから任意のプロパティのみを持ったオブジェクトを得る方法。\n---\n\n# オブジェクトのサブセットを得る\n\nオブジェクトのサブセットを得る方法です。サブセットとは、あるオブジェクトのいち部分を切り取ったもので、ここで紹介する方法は、プロパティ名を指定してオブジェクトの一部分を切り出すものです。たとえば、次のような数多くのプロパティを持つオブジェクトがあるとき、ここから数個のプロパティだけを持つオブジェクトを作る方法です。\n\n```ts twoslash\nconst profile = {\n  name: \"suin\",\n  twitter: \"suin\",\n  github: \"suin\",\n  country: \"JP\",\n  prefecture: \"東京都\",\n  city: \"千代田区\",\n  address: \"丸の内2-4-1\",\n  building: \"丸ビル\",\n  zipcode: \"100-6390\",\n};\n\n// 上の9つプロパティを持つオブジェクトから、下の6つのプロパティだけを抽出したオブジェクトを得たい\n\nconst address = {\n  country: \"JP\",\n  prefecture: \"東京都\",\n  city: \"千代田区\",\n  address: \"丸の内2-4-1\",\n  building: \"丸ビル\",\n  zipcode: \"100-6390\",\n};\n```\n\n## 方法1: 即時関数・分割代入・shorthand property nameの合わせ技\n\nオブジェクトのサブセットを得る1つ目の方法は、即時関数と分割代入、そして、shorthand property nameを組み合わせる方法です。\n\n```ts twoslash\nconst profile = {\n  name: \"suin\",\n  twitter: \"suin\",\n  github: \"suin\",\n  country: \"JP\",\n  prefecture: \"東京都\",\n  city: \"千代田区\",\n  address: \"丸の内2-4-1\",\n  building: \"丸ビル\",\n  zipcode: \"100-6390\",\n};\n// ---cut---\nconst sns = (({ twitter, github }) => ({ twitter, github }))(profile);\n//=> {\n//   \"twitter\": \"suin\",\n//   \"github\": \"suin\"\n// }\n```\n\nこの方法のメリットとデメリットは次のとおりです。\n\n- メリット\n  - 外部ライブラリを必要としない。\n- デメリット\n  - 初見の読み手には意外性のあるコードに見える場合がある。\n  - 即時関数の引数部分とshorthand property nameの2箇所に同じプロパティ名を書く必要があり冗長。\n\nこの書き方は、数個の少ないプロパティを抽出したいときは便利ですが、たくさんのプロパティを抽出しようとすると記述量が増え、徐々に大変さが出てきます。\n\n抽出したいプロパティよりも、除きたいプロパティのほうが少ない場合は、次のような書き方で除きたいプロパティを指定するほうが簡単です。\n\n```ts twoslash\nconst profile = {\n  name: \"suin\",\n  twitter: \"suin\",\n  github: \"suin\",\n  country: \"JP\",\n  prefecture: \"東京都\",\n  city: \"千代田区\",\n  address: \"丸の内2-4-1\",\n  building: \"丸ビル\",\n  zipcode: \"100-6390\",\n};\n// ---cut---\nconst address = (({ name, twitter, github, ...rest }) => rest)(profile);\n//    ^?\n//=> {\n//   \"country\": \"JP\",\n//   \"prefecture\": \"東京都\",\n//   \"city\": \"千代田区\",\n//   \"address\": \"丸の内2-4-1\",\n//   \"building\": \"丸ビル\",\n//   \"zipcode\": \"100-6390\"\n// }\n```\n\nJavaScriptでは、`delete`を使うとオブジェクトからプロパティを取り除けるので、上の書き方はまどろっこしいと思われるかもしれません。この書き方をするには理由があって、TypeScriptでは`delete`の使い勝手が良くないからです。あるオブジェクトから`delete`を使ってプロパティを取り除きたい場合、TypeScriptではそのプロパティがオプショナルでなければなりません。\n\n```ts twoslash\nconst profile = {\n  name: \"suin\",\n  twitter: \"suin\",\n  github: \"suin\",\n  country: \"JP\",\n  prefecture: \"東京都\",\n  city: \"千代田区\",\n  address: \"丸の内2-4-1\",\n  building: \"丸ビル\",\n  zipcode: \"100-6390\",\n};\n// ---cut---\n// @errors: 2790\nconst address = { ...profile };\ndelete address.name;\n```\n\n## 方法2: lodash.pick / lodash.omit\n\n2つ目の方法は[lodash](https://lodash.com/)を用いるものです。lodashはさまざまな便利関数を提供するライブラリで、その中のひとつに`pick`というオブジェクトのサブセットを得るための関数があります。\n\n```ts twoslash\n// @filename: lodash\n// ---cut---\nimport _ from \"lodash\";\n\nconst sns = _.pick(profile, [\"twitter\", \"github\"]);\n//=> {\n//   \"twitter\": \"suin\",\n//   \"github\": \"suin\"\n// }\n```\n\nlodash全体ではなく、`pick`関数だけが必要な場合は、パッケージ[lodash.pick](https://www.npmjs.com/package/lodash.pick)を使うこともできます。この場合、次のようにして`pick`関数を使います。\n\n```ts twoslash\n// @filename: lodash.pick\n// ---cut---\nimport pick from \"lodash.pick\";\n\nconst sns = pick(profile, [\"twitter\", \"github\"]);\n```\n\nlodash.pickのメリットとデメリットは次のとおりです。\n\n- メリット\n  - 宣言的で読みやすい。\n  - 記述量が少ない。\n- デメリット\n  - ライブラリを導入する必要がある。\n\nlodash.pickは抽出したいプロパティ名を指定する関数ですが、抽出したいプロパティより除外したいプロパティが少ない場合は、[lodash.omit](https://www.npmjs.com/package/lodash.omit)を使ったほうが便利です。\n\n```ts twoslash\n// @filename: lodash\n// ---cut---\nimport _ from \"lodash\";\n\nconst address = _.omit(profile, [\"name\", \"twitter\", \"github\"]);\n//=> {\n//   \"country\": \"JP\",\n//   \"prefecture\": \"東京都\",\n//   \"city\": \"千代田区\",\n//   \"address\": \"丸の内2-4-1\",\n//   \"building\": \"丸ビル\",\n//   \"zipcode\": \"100-6390\"\n// }\n```\n\nlodash、lodash.pickとlodash.omitのインストールは次のコマンドで行なえます。\n\n```bash\n# lodashのインストール\nnpm install lodash\nnpm install -D @types/lodash\n\n# lodash.pickとlodash.omitのインストール\nnpm install lodash.pick lodash.omit\nnpm install -D @types/lodash.pick @types/lodash.omit\n```\n",
      "url": "https://typescriptbook.jp/tips/get-a-subset-of-an-object"
    },
    {
      "title": "配列から全要素の型を生成する",
      "content": "# 配列から全要素の型を生成する\n\n前ページでは、配列から全要素の型を生成する方法が登場しました。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\n\ntype Currency = (typeof currencies)[number];\n//   ^?\n```\n\n`typeof currencies[number]`という書き方は、初めて見ると理解に苦しむコードかもしれません。そのためより詳しく説明します。\n\n## 前ページのコードを観察する\n\n配列からある要素の型を生成するコードについて、前ページに続き通貨の配列でもう一度確認します。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\ntype Currency = (typeof currencies)[2];\n//   ^?\n```\n\nここで、`typeof currencies[2]`の`2`は、前ページでリテラル型と説明していますが本当でしょうか？次のコードで確認してみます。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\nconst index = 2 as const;\n// @errors: 2749\ntype Currency = (typeof currencies)[index];\n```\n\n`2`が値として解釈されるコードではエラーになってしまいました。\n\nでは明確にリテラル型だとわかるコードも試してみましょう。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\ntype Index = 2;\ntype Currency = (typeof currencies)[Index];\n//   ^?\n```\n\nこれで`typeof currencies[2]`の`2`はリテラル型であることがはっきりしました。\n\n## 数値のリテラル型と`number`型\n\n`2`のリテラル型と`number`型の関係を集合で表現すると、`2`⊂`number`と書くことができます。他の表現をすると、`0`、`1`、`2`..など数値のリテラル型のいずれかの型として振る舞うのが`number`型です。\n\n「いずれかの型」といえばユニオン型の出番です。\n\n[ユニオン型 (union type)](../reference/values-types-variables/union.md)\n\n`number`型の代わりにリテラルのユニオン型を使ってみましょう。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\ntype Currency = (typeof currencies)[0 | 1 | 2 | 3 | 4 | 5];\n//   ^?\n```\n\n`0 | 1 | 2 | 3 | 4 | 5`型でも`currencies`配列から全要素の型を生成することができました。このように`number`型は数値のリテラル型のワイルドカードとして振る舞うことがわかります。\n\n## 一般化する\n\nこのページの締めくくりに一般化したコードを示します。\n\n```ts twoslash\ntype List = (string | number | boolean)[];\ntype Elem = List[number];\n//   ^?\n```\n\n`List`型から`List[number]`という書き方ですべての要素の型である`string | number | boolean`が生成できました。\n\n### アンチパターンの紹介\n\n次のように具体的なインデックスで同じ型を生成することは可能ですが、アンチパターンなので注意してください。\n\n```ts twoslash\ntype List = (string | number | boolean)[];\ntype Elem = List[0]; // 避けるべき書き方\n//   ^?\n```\n\nこの書き方がアンチパターンである理由は`List`型をタプル型だと混乱させてしまう可能性があるためです。`List[0]`は特定の要素から型を生成しているため、各要素の型が同じ型ではない、つまり`List`が配列型ではなくタプル型だからこの書き方をしていると誤解させる可能性があります。配列型はどの要素の型も同じものとして扱うので、`List[number]`の書き方が適切です。\n",
      "url": "https://typescriptbook.jp/tips/generates-type-of-element-from-array"
    },
    {
      "title": "オブジェクトからプロパティの型を生成する",
      "content": "# オブジェクトからプロパティの型を生成する\n\n## オブジェクトからプロパティだけ欲しい\n\n[オブジェクトからキーの型を生成する](generates-type-from-object-key.md)\n\n前ページとは対照的にオブジェクトからプロパティだけのユニオン型を得ることを目的とします。今回も前回と同様に次のメッセージが定義されているとします。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\n```\n\n最終的には次のようなユニオン型が今回の目的です。\n\n```ts twoslash\ntype ConfirmationMessage =\n  | \"Are you sure?\"\n  | \"Êtes-vous sûr?\"\n  | \"Está seguro?\"\n  | \"よろしいですか？\"\n  | \"您确定吗？\";\n```\n\n## 今回の問題を解くにあたって\n\n今回は今まで紹介してきたオブジェクトから型を作り出す方法と Mapped Types の合わせ技で再現することができます。\n\n[オブジェクトから型を生成する](generates-type-from-object.md)\n\n[オブジェクトからキーの型を生成する](generates-type-from-object-key.md)\n\nアプローチの方法としてはまずオブジェクトからキーの型を生成し Mapped Types を使いオブジェクトのプロパティの型を参照、それらをリテラル型で取得します。\n\n### キーの型を生成する\n\nキーの型の生成は前のページにあるものと同一です。次のようにすることでキーである言語のユニオン型を取得できます。詳細についてはオブジェクトからキーの値を生成するのページをご覧ください。\n\n[オブジェクトからキーの型を生成する](generates-type-from-object-key.md)\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\n// ---cut---\ntype Language = keyof typeof conf;\n//   ^?\n```\n\n### Mapped Types\n\nオブジェクトのプロパティの型を参照するために Mapped Types を使います。そのとき元のオブジェクトから型を生成するために`typeof`を使います。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\ntype Language = keyof typeof conf;\n// ---cut---\ntype ConfirmationMessage = (typeof conf)[Language];\n//   ^?\n```\n\n### リテラル型を取得するできるようにする\n\nこのままだとオブジェクトから型を生成すると同じように型はリテラル型ではありません。つまりただの`string`型のユニオン型つまり`string`型です。そこで、元のオブジェクト`conf`に`as const`をつけます。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n} as const;\n```\n\n## まとめ\n\nお好みで定義したキーの型`Language`を Mapped Types のキーの部分に代入します。最終的な形は次のようになります。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n} as const;\n\ntype ConfirmationMessage = (typeof conf)[keyof typeof conf];\n//   ^?\n```\n\n`as const`を忘れないようにしてください。\n",
      "url": "https://typescriptbook.jp/tips/generates-type-from-object-property"
    },
    {
      "title": "配列から型を生成する",
      "content": "# 配列から型を生成する\n\n単位のように振る舞うことを期待されて定義されたコレクションは少なくないでしょう。今回はコレクションでも主に配列に焦点を当てそれらから型を生成する方法の紹介です。\n\n## 通貨の配列から通貨の型を作りたい\n\n国際的な外貨を使うことができるサービスを開発していたとします。サポートしている通貨を配列で保持しているとし次のようになっているとします。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"];\n```\n\nこのようなとき、このJavaScriptの資産をできるだけ変更せずに貨幣の型 (ユニオン型) を作ることができれば今後便利そうです。つまり次のようなユニオン型です。\n\n```ts twoslash\ntype Currency = \"CNY\" | \"EUR\" | \"GBP\" | \"JPY\" | \"KRW\" | \"USD\";\n```\n\n### `typeof`\n\nこれはJavaScriptの`typeof`ではなくTypeScriptの`typeof`です。`typeof`はTypeScriptがその変数をどのような型であるかと認識しているかかを教えてくれます。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"];\n\ntype Currency = typeof currencies;\n//   ^?\n```\n\n予想されている方が多かったかもしれませんが`string[]`型と出てしまいました。ではこれをどうすれば`string`ではなく定数値で取得できるでしょうか。それは定数値で取得したいオブジェクトに`as const`をつけると取得できます。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\n\ntype Currency = typeof currencies;\n//   ^?\n```\n\n定数 (リテラル型) は取れましたが依然配列のままです。これをユニオン型で取るためには考え方を逆転させる必要があります。\n\n#### 何番目のリテラル型が欲しいか\n\nたとえば`'GBP'`が欲しいとします。`'GBP'`は2番目なので`currencies`の2番目の型を取れば希望のリテラル型が取れます。\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\n\ntype Currency = (typeof currencies)[2];\n//   ^?\n```\n\n`'GBP'`を取ることができました。\n\n### すべてのリテラル型が欲しい\n\n本題です。まさか次のようにするわけには行かないのでもっと賢い方法を考える必要があります。\n\n```ts\ntype Currency = typeof currencies[0] | typeof currencies[1] | typeof currencies[2] | ....\n```\n\nそこで思いつくのは`typeof`をしているときのインデックスです。実はこれもリテラル型であり`currencies`の`2`のリテラル型を取ることを意味しています。\n\n配列はnumber型のインデックスに要素を代入しているオブジェクトなのでこのリテラル型のインデックスの代わりに`number`を使うことによって\n\n```ts twoslash\nconst currencies = [\"CNY\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"USD\"] as const;\n\ntype Currency = (typeof currencies)[number];\n//   ^?\n```\n\nと希望のユニオン型を取得できます。\n",
      "url": "https://typescriptbook.jp/tips/generates-type-from-array"
    },
    {
      "title": "オブジェクトから型を生成する",
      "content": "# オブジェクトから型を生成する\n\n多くの言語では型による構造体、オブジェクトの定義をしてからコーディングが始まりますが、元がJavaScriptであるTypeScriptにはそのような決まりがないことも多々あります。\n\n## 一般的な型を先に決めるプログラミング\n\n多くの言語ではその型が何かを決めてから、その型に属するオブジェクトを決めます。次の例はTypeScriptの例ですが、他の言語に当てはめても問題なく受け入れられると思います。\n\n```ts twoslash\ntype Account = {\n  accountName: string;\n  password: string;\n  age: number;\n  plan: \"Free\" | \"Standard\" | \"Premium\";\n};\n\nconst account: Account = {\n  accountName: \"yyts\",\n  password: \"ccbyncsa30\",\n  age: 80,\n  plan: \"Standard\",\n};\n```\n\nすでにJavaScriptの資産があるプロジェクトにおいては表立って型などなく、そのため`Account`といった型は存在せず代入式の`const account`のみが存在していることでしょう。そんなときはこの`const account`をTypeScriptに変換してできるだけ近い形で型を作ることができます。\n\n### `typeof`\n\nこの`typeof`はJavaScriptのものではなく、TypeScriptの`typeof`です。これを実際に動作している変数に使ってみるとその変数をTypeScriptはどのような型と認識しているのかがわかります。\n\n```ts twoslash\nconst account = {\n  accountName: \"yyts\",\n  password: \"ccbyncsa30\",\n  age: 80,\n  plan: \"Standard\",\n};\n\ntype Account = typeof account;\n//   ^?\n```\n\n`plan`が意図するユニオン型にはなりませんが、それなりに近い型を得ることができました。\n\n### プロパティを定数値で取得したい場合\n\nプロパティを定数値で取得したい場合はオブジェクトに`as const`をつけます。\n\n```ts twoslash\nconst account = {\n  accountName: \"yyts\",\n  password: \"ccbyncsa30\",\n  age: 80,\n  plan: \"Standard\",\n} as const;\n\ntype Account = typeof account;\n//   ^?\n```\n\n### 特定のプロパティだけを定数値で取得したい場合\n\nこれでは型の制約が強力すぎて他の値が代入できないので、もう少し柔軟にします。たとえば`plan`だけがユニオン型になるようにしたければ`plan`の右に希望の型を書いてあげればそれでその型になります。\n\n```ts twoslash\nconst account = {\n  accountName: \"yyts\",\n  password: \"ccbyncsa30\",\n  age: 80,\n  plan: \"Standard\" as \"Free\" | \"Standard\" | \"Premium\",\n};\n\ntype Account = typeof account;\n//   ^?\n```\n",
      "url": "https://typescriptbook.jp/tips/generates-type-from-object"
    },
    {
      "title": "オブジェクトを浅くコピーする",
      "content": "# オブジェクトを浅くコピーする\n\nオブジェクトとは色々なキーとプロパティの組み合わせをひとつのモノとして扱うことができます。\n\nオブジェクトを扱っているとき、そのインスタンスに対する比較や代入は他の言語と同じように参照の比較、代入です。その参照をほかのどこかで持たれているとそこで書き換えられる可能性があります。\n\n## インスタンスを安易に上書きすると起こる弊害\n\nたとえば生活習慣病に関するサービスを作るとします。そのサービスでは一日の食事を入力するとその食事から熱量 (カロリー) が計算され、さらに将来的に生活習慣病 (少々異なりますがMetabolic Syndromeとします) になるかどうか判定できるとします。\n\nここで一日の食事を意味するオブジェクトの型として`MealsPerDay`を定義し、一日に摂取した食事の熱量からいずれ生活習慣病になるかどうか判定する関数`willBeMetabo()`を定義すれば次のようになります。\n\n```ts twoslash\n// @noErrors\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\n\nfunction willBeMetabo(meals: MealsPerDay): boolean {\n  // ...\n}\n```\n\n使い方としては次のようになります。\n\n```ts twoslash\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\n\ndeclare function willBeMetabo(meals: MealsPerDay): boolean;\n\n// ---cut---\n// 439.2 kcal\nconst meals: MealsPerDay = {\n  breakfast: \"a vegetable salad\",\n  lunch: \"a cod's meuniere\",\n  dinner: \"a half bottle of wine (white)\",\n};\n\nwillBeMetabo(meals);\n// @log: false\n```\n\nですが、これだけだと食べ物ではないもの、たとえばネジなどの不正な入力があったときにサービスが予想しない反応をしかねません。そこで入力されているものが本当に食事かどうかをバリデーションする関数として`isMeals()`を定義します。この関数は食事ではないものが与えられると例外を投げます。\n\n`isMeals()`の構造は単純です。朝食、昼食、夕食をそれぞれそれが食事であるかどうかを判定するだけです。ひとつの食事が食事であるかを判定する関数`isMeal()`があるとすれば内部でそれを呼ぶだけです。`isMeal()`の実装については今回は重要ではないため省略します。\n\n```ts twoslash\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\ndeclare function isMeal(something: string): boolean;\n// ---cut---\nfunction isMeals(meals: MealsPerDay): void {\n  if (!isMeal(meals.breakfast)) {\n    throw new Error(\"BREAKFAST IS NOT A MEAL!\");\n  }\n  if (!isMeal(meals.lunch)) {\n    throw new Error(\"LUNCH IS NOT A MEAL!!!\");\n  }\n  if (!isMeal(meals.dinner)) {\n    throw new Error(\"DINNER IS NOT A MEAL!!!\");\n  }\n}\n```\n\n今回のユースケースでは`isMeals()`でバリデーションを行ったあとその食事を`willBeMetabo()`で判定します。食べられないものが与られたときは例外を捕捉して対応できればよいので大まかにはこのような形になるでしょう。\n\n```ts twoslash\n// @noErrors\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\ndeclare function isMeals(meals: MealsPerDay): void;\ndeclare function willBeMetabo(meals: MealsPerDay): boolean;\n// ---cut---\nfunction shouldBeCareful(meals: MealsPerDay): boolean {\n  try {\n    // ...\n    isMeals(meals);\n\n    return willBeMetabo(meals);\n  } catch (err: unknown) {\n    // ...\n  }\n}\n```\n\nここで`isMeals()`の制作者あるいは維持者が何を思ってか`isMeals()`に自分の好きなコッテコテギトギトの食事を、もとのインスタンスを上書きするようにプログラムを書いたとします。この変更によって前述のとても健康的で500 kcalにも満たない食事をしているはずのユーザーが`isMeals()`を19,800 kcalものカロリー爆弾を摂取していることになります。\n\n```ts twoslash\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\n\nconst meals: MealsPerDay = {\n  breakfast: \"a vegetable salad\",\n  lunch: \"a cod's meuniere\",\n  dinner: \"a half bottle of wine (white)\",\n};\n\ndeclare function willBeMetabo(meals: MealsPerDay): boolean;\n\ndeclare function isMeal(meal: string): boolean;\n\n// ---cut---\nfunction isMeals(meals: MealsPerDay): void {\n  meals.breakfast = \"a beef steak\";\n  // beef steak will be 1200 kcal\n  meals.lunch = \"a bucket of ice cream\";\n  // a bucket of ice cream will be 7200 kcal\n  meals.dinner = \"3 pizzas\";\n  // 3 pizzas will be 11400 kcal\n\n  if (!isMeal(meals.breakfast)) {\n    throw new Error(\"BREAKFAST IS NOT MEAL!\");\n  }\n  if (!isMeal(meals.lunch)) {\n    throw new Error(\"LUNCH IS NOT MEAL!!!\");\n  }\n  if (!isMeal(meals.dinner)) {\n    throw new Error(\"DINNER IS NOT MEAL!!!\");\n  }\n}\n\nconsole.log(meals);\n// @log: 439.2 kcal\n\nisMeals(meals);\n\nconsole.log(meals);\n// @log: 19,800 kcal!!!\n\nwillBeMetabo(meals);\n// @log: true\n```\n\n`isMeals()`を呼んでしまったらもうどのような食事が与えられても`willBeMetabo()`は誰もが生活習慣病に一直線であると判別されることになります。変数`meals`の変更は`isMeals()`内に留まらず、外側にも影響を与えます。\n\n### 今回の問題\n\n今回の例は`isMeals()`が悪さをしました。この関数が自分たちで作ったものであればすぐに原因を見つけることができるでしょう。このような問題のある関数を書かないようにすることはもちろん大事なことですが、未熟なチームメイトがいればこのような関数を書くかもしれません。人類が過ちを犯さない前提よりも過ちを犯すことがないようにする設計の方が大事です。\n\n`isMeals()`が外部から持ってきたパッケージだとすると問題です。自分たちでこのパッケージに手を加えることは容易ではないため (できなくはありません) 。制作者にプルリクエストを出してバグフィックスが行われるまで開発を止めるというのも現実的ではありません。\n\n### どうすればよかったのか\n\nそもそもインスタンスを書き換えられないようにしてしまうか、元のインスタンスが破壊されないようにスケープゴートのインスタンスを用意するのが一般的です。前者はバリューオブジェクトと呼ばれるものが代表します。ここで紹介するのは後者のスケープゴート、つまりコピーを用意する方法です。\n\n## 浅いコピー (shallow copy) とは\n\n題名にもあるとおり**浅い**とは何を指しているのでしょうか？それはオブジェクトのコピーをするにあたりオブジェクトがいかに深い構造になっていても (ネストしていても) 第一階層のみをコピーすることに由来します。当然対義語は深いコピー (deep copy) です。\n\n### 浅いコピーをしたオブジェクトは等しくない\n\n浅いコピーをする関数を`shallowCopy()`とします。実装は難しくありませんが今回は挙動についてのみ触れたいため言及は後にします。浅いコピーをしたオブジェクトとそのオリジナルは`===`で比較すると`false`を返します。これはコピーの原義から当然の挙動であり、もし`true`を返すようであればそれはコピーに失敗していることになります。\n\n```ts twoslash\ndeclare function shallowCopy(obj: object): object;\n\n// ---cut---\nconst object1: object = {};\nconst object2: object = shallowCopy(object1);\n\nconsole.log(object1 === object2);\n// @log: false\n```\n\n次の例は先ほどのインスタンスの上書きを浅いコピーをすることにより防いでいる例です。`meals`のインスタンスは変化せず`isMeals()`に引数として与えた`scapegoat`だけが変更されます。\n\n```ts twoslash\ntype MealsPerDay = {\n  breakfast: string;\n  lunch: string;\n  dinner: string;\n};\n\nconst meals: MealsPerDay = {\n  breakfast: \"a vegetable salad\",\n  lunch: \"a cod's meuniere\",\n  dinner: \"a half bottle of wine (white)\",\n};\n\ndeclare function shallowCopy(meals: MealsPerDay): MealsPerDay;\n\ndeclare function isMeals(meals: MealsPerDay): void;\n\n// ---cut---\nconst scapegoat: MealsPerDay = shallowCopy(meals);\n\nconsole.log(meals);\n// @log: { breakfast: \"a vegetable salad\", lunch: \"a cod's meuniere\", dinner: \"a half bottle of wine (white)\" }\n\nconsole.log(scapegoat);\n// @log: { breakfast: \"a vegetable salad\", lunch: \"a cod's meuniere\", dinner: \"a half bottle of wine (white)\" }\n\nisMeals(scapegoat);\n\nconsole.log(meals);\n// @log: { breakfast: \"a vegetable salad\", lunch: \"a cod's meuniere\", dinner: \"a half bottle of wine (white)\" }\n\nconsole.log(scapegoat);\n// @log: { breakfast: \"a beef steak\", lunch: \"a bucket of ice cream\", dinner: \"3 pizzas\" }\n```\n\n### 浅いコピーで防ぎきれない場合\n\n先ほども述べたように浅いコピーはオブジェクトの第一階層のみをコピーします。そのためもしオブジェクトが深い、複雑な階層を持っている場合、それらをすべてコピーしているのではなく、第二階層以降は単なる参照になります。次の例は浅いコピーのプロパティにオブジェクトがある場合、それがコピーではなく参照になっていることを示しています。\n\n```ts twoslash\ndeclare function shallowCopy(meals: NestObject): NestObject;\n\n// ---cut---\ntype NestObject = {\n  nest: object;\n};\n\nconst object1: NestObject = {\n  nest: {},\n};\nconst object2: NestObject = shallowCopy(object1);\n\nconsole.log(object1 === object2);\n// @log: false\nconsole.log(object1.nest === object2.nest);\n// @log: true\n```\n\n完全なコピーを作りたい場合は浅いコピーと一緒に出てきた深いコピーを使います。\n深いコピーについて今回は深く触れません。浅いコピーに比べ深いコピーはコピーに時間がかかり、さらに参照ではなく実体をコピーするため、記憶領域を同じ量確保しなければなりません。何でもかんでも深いコピーをするとあっという間に時間的、空間的な領域を浪費します。浅いコピーでこと足りる場合は浅いコピーを使用する方がよいでしょう。\n\n### 浅いコピーを実装する\n\n浅いコピーの実装は昨今のJSでは大変楽になっており、次のコードで完成です。\n\n```ts twoslash\nconst sample: object = {\n  year: 1999,\n  month: 7,\n};\n// ---cut---\nconst shallowCopied: object = { ...sample };\n```\n\nもちろん変数`sample`はオブジェクトである必要があります。この`...`はスプレッド構文です。スプレッド構文については関数の章を参照ください。\n\nオブジェクトのコピーにスプレッド構文を使えるようになったのはES2018からです。たとえば次のような浅いコピーの例を\n\n```ts twoslash\nconst sample: object = {\n  year: 1999,\n  month: 7,\n};\n\nconst shallowCopied: object = { ...sample };\n```\n\nES2018でコンパイルすると次のようになります。\n\n```ts twoslash\nconst sample = {\n  year: 1999,\n  month: 7,\n};\nconst shallowCopied = { ...sample };\n```\n\nほぼ同じですがES2017でコンパイルすると次のようになります。\n\n```ts twoslash\nconst sample = {\n  year: 1999,\n  month: 7,\n};\nconst shallowCopied = Object.assign({}, sample);\n```\n\nとなります。スプレッド構文が実装される前はこの`Object.assign()`を使っていました。このふたつはまったく同じものではありませんが`Object.assign({}, obj)`を`{...obj}`のほぼ代替として使うことができます。\n\n## コピー用のAPIを使う\n\nJavaScriptではオブジェクトによって、浅いコピーを簡潔に書くためのAPIが提供されているものがあります。`Map`や`Set`はそれが利用できます。\n\n### `Map<K, V>`のコピー\n\n`Map`をコピーする場合は、`Map`コンストラクタにコピーしたい`Map`オブジェクトを渡します。\n\n```ts twoslash\nconst map1 = new Map([\n  [\".js\", \"JS\"],\n  [\".ts\", \"TS\"],\n]);\nconst map2 = new Map(map1);\n// 要素は同一だが、Mapインスタンスは異なる\nconsole.log(map2);\n// @log: Map (2) {\".js\" => \"JS\", \".ts\" => \"TS\"}\nconsole.log(map1 !== map2);\n// @log: true\n```\n\n[Map](../reference/builtin-api/map.md)\n\n### `Set<T>`のコピー\n\n`Set`をコピーする場合は、`Set`コンストラクタにコピーしたい`Set`オブジェクトを渡します。\n\n```ts twoslash\nconst set1 = new Set([1, 2, 3]);\nconst set2 = new Set(set1);\n// 要素は同一だが、Setのインスタンスは異なる\nconsole.log(set2);\n// @log: Set (3) {1, 2, 3}\nconsole.log(set1 !== set2);\n// @log: true\n```\n\n[Set](../reference/builtin-api/set.md)\n\n### `Array<T>`のコピー\n\n配列をコピーする方法はいくつかありますが、もっとも簡単なのは配列のスプレッド構文を用いたものです。\n\n```ts twoslash\nconst array1 = [1, 2, 3];\nconst array2 = [...array1];\n```\n\nこのときスプレッド構文`...`を書き忘れると配列の配列`T[][]`型ができあがるので気をつけてください。\n\n## 関連情報\n\n[スプレッド構文](../reference/values-types-variables/array/spread-syntax-for-array.md)\n",
      "url": "https://typescriptbook.jp/tips/shallow-copy-object"
    },
    {
      "title": "オブジェクトで受け、オブジェクトを返す (RORO)",
      "content": "---\nsidebar_label: オブジェクトで受け、オブジェクトを返す\n---\n\n# オブジェクトで受け、オブジェクトを返す (RORO)\n\n関数やメソッドでオブジェクトひとつを引数として受け、戻り値もオブジェクトひとつとする RORO という考え方があります。RORO は **Receive an Object, Return an Object** の略です。この考えは JavaScript ならびに TypeScript では大きな恩恵をもたらします。\n\n## いままでの関数\n\nJavaScript に限らず、駆け出しの頃の関数はこのような姿形をしています。\n\n```ts twoslash\n// @noErrors\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n  country: string;\n  password: string;\n  vip: boolean;\n};\n// ---cut---\nfunction findUser(\n  name?: string,\n  age?: number,\n  country?: string,\n  isVip?: boolean\n): User {\n  // ...\n}\n```\n\n好きなパラメータで検索できるようにか、引数自体を省略可能にして検索できるようにしています。とはいえ次の問題が立ちはだかります。\n\n### 引数が追加されたとき\n\n居住地と国籍は違う！とパラメータとして国籍(`nationality`)が追加されたとします。このとき国籍はどこに追加されるでしょうか?`isVip`の次が安全ですが人によってはその位置を嫌うかもしれません。\n\nまた、今回は`findUser()`という関数に限定しての話にしていますが、同じような引数をとる`~~~User()`のメソッドがあれば何箇所も同時に修正が必要になるでしょう。これは面倒です。\n\n### 省略可能でない引数がある他の関数の場合\n\n引数のうち、省略可能であるものは右側 (後ろ) に詰めて書かなければいけません。今回は検索ですべての引数を省略可能にしていますが、ものによっては国 (`country`) のみは必須入力とする関数を作るとなれば、それだけは関数の第 1 引数にせざるを得ません。このような問題が生じれば引数が追加されたときと同じように引数の並びで混乱を生むでしょう。\n\nこのような問題を解決するものとしてオブジェクトに必要な情報をひとつに詰めて引数に送るROROという考えがあります。\n\n## RORO (Receive an Object, Return an Object)\n\n上記ユーザーであればデータクラスのような (ただのデータだけ入った可視性 public のクラス) を作れば問題は回避できます。 TypeScript でその型を`UserInfo`とすれば`UserInfo`は次になります。\n\n```ts twoslash\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  isVip?: boolean;\n};\n```\n\n今回は律儀に`Optional`の`?`をつけましたが`Partial<T>`でも代用可です。\n\nこのようにしてこの型のオブジェクトを引数の型としてひとつ受けるようにします。\n\n```ts twoslash\n// @noErrors\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  isVip?: boolean;\n};\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n  country: string;\n  password: string;\n  vip: boolean;\n};\n// ---cut---\nfunction findUser(info: UserInfo): User {\n  if (info.age >= 20) {\n    // ...\n  }\n\n  // ...\n}\n```\n\nこれでは JavaScript ならびに TypeScript で使える便利な Tip というよりは、ただの Tip です。ではこれはなぜ JavaScript, TypeScript で重用されるのかというと、分割代入が関係しています。\n\n分割代入を使うと関数はオブジェクトのキーを引数に指定するだけでその値にアクセスできます。たとえば`findUserByName()`と名前 (`name`) しか必要のない関数で`UserInfo`をすべて受けるのではなく分割代入を使うとこのようになります。\n\n```ts twoslash\n// @noErrors\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  isVip?: boolean;\n};\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n  country: string;\n  password: string;\n  vip: boolean;\n};\n// ---cut---\nfunction findUserByName({ name }: UserInfo): User {\n  // ...\n}\n```\n\n分割代入について再度知識が必要な方は次のページをご参照ください。\n\n[オブジェクトの分割代入 (destructuring assignment)](../reference/values-types-variables/object/destructuring-assignment-from-objects.md)\n\n[分割代入引数 (destructuring assignment parameter)](../reference/functions/destructuring-assignment-parameters.md)\n\n分割代入はこの関数を使う側としても引数の順番を気にする必要がなくなるとともに、ありがたいことに今後の機能拡張によって`UserInfo`が成長したとしても毎回引数を追加する必要はなく`UserInfo`を書き換え使用したい関数でそのキーにアクセスをするだけですみます。上記例のように国籍 (`nationality`) が増えれば好きなところに加えるだけです。順番は呼び出しに影響を与えません。\n\n```ts twoslash\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  nationality?: string;\n  isVip?: boolean;\n};\n```\n\nこれだけで`nationality`を (`byName`で国籍を使っている問題は置いておくとして) 簡単に呼び出せます。\n\n```ts twoslash\n// @noErrors\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  nationality?: string;\n  isVip?: boolean;\n};\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n  country: string;\n  password: string;\n  vip: boolean;\n};\n// ---cut---\nfunction findUserByName({ name, nationality }: UserInfo): User {\n  // ...\n}\n```\n\n関数の説明でもあったとおりですが、分割代入にも初期値を使うことができます。たとえば`findUser()`では通常引退済みのユーザーを検索しないのであれば`UserInfo`と関数は次のように書き換えるだけです。\n\n```ts twoslash\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  nationality?: string;\n  isVip?: boolean;\n  isRetired?: boolean;\n};\n```\n\n```ts twoslash\n// @noErrors\ntype UserInfo = {\n  name?: string;\n  age?: number;\n  country?: string;\n  nationality?: string;\n  isVip?: boolean;\n  isRetired?: boolean;\n};\ntype User = {\n  id: string;\n  name: string;\n  age: number;\n  country: string;\n  password: string;\n  vip: boolean;\n};\n// ---cut---\nfunction findUser({ name, age, country, isRetired = false }: UserInfo): User {\n  // ...\n}\n```\n",
      "url": "https://typescriptbook.jp/tips/receive-an-object-return-an-object"
    },
    {
      "title": "オブジェクトからキーの型を生成する",
      "content": "# オブジェクトからキーの型を生成する\n\n## オブジェクトからキーだけ欲しい\n\nあるメッセージが言語ごとに定義されているとします。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\n```\n\n内容は確認を促す変哲もないシステムのメッセージです。このオブジェクトを使ってシステムがサポートしている言語の一覧を作ります。次のようなユニオン型が今回の目的です。\n\n```ts twoslash\ntype Language = \"en\" | \"fr\" | \"es\" | \"ja\" | \"zh\";\n```\n\n### `typeof`\n\n頻出するこの`typeof`はJavaScriptのものではなく、TypeScriptの`typeof`です。これをオブジェクトに対して使用している例は前のページにあるとおりです。\n\n[オブジェクトから型を生成する](generates-type-from-object.md)\n\nこの例で実行すれば次のような型`TypeOfLanguage`が生成されるでしょう (型名は便宜的なものです) 。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\n// ---cut---\ntype TypeOfLanguage = typeof conf;\n//   ^?\n```\n\nここまでくればあとは少しです。`TypeOfLanguage`型のキーだけを型にしてしまいます。\n\n### `keyof`\n\n`keyof`はオブジェクトの型に使うとそのオブジェクトのキーをユニオン型にして返します。上記の`TypeOfLanguage`型があれば\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\ntype TypeOfLanguage = typeof conf;\n// ---cut---\ntype Language = keyof TypeOfLanguage;\n//   ^?\n```\n\nとなります。\n\n[keyof型演算子](../reference/type-reuse/keyof-type-operator.md)\n\n## まとめ\n\n見た目が少々いびつですが、次でオブジェクトから希望するキーのユニオン型を生成できます。\n\n```ts twoslash\nconst conf = {\n  en: \"Are you sure?\",\n  fr: \"Êtes-vous sûr?\",\n  es: \"Está seguro?\",\n  ja: \"よろしいですか？\",\n  zh: \"您确定吗？\",\n};\ntype TypeOfLanguage = typeof conf;\n// ---cut---\ntype Language = keyof typeof conf;\n//   ^?\n```\n\n### 疑問: `keyof conf`じゃダメなんですか？\n\n動作しません。なぜなら`keyof`は値ではなく (オブジェクトの) 型に対して使用できるからです。一方`typeof`は値から型を生成するのでこの順番で使用する必要があります。\n",
      "url": "https://typescriptbook.jp/tips/generates-type-from-object-key"
    },
    {
      "title": "オブジェクトをマージ (結合) する",
      "content": "# オブジェクトをマージ (結合) する\n\n前ページではオブジェクトの浅いコピーについて語りました。\nそこでは以前出てきたスプレッド構文 (`...`) のおかげで簡単に浅いコピーができることがわかりました。\n\n今回はふたつ以上のオブジェクトをマージすることを考えます。なお、前ページのオブジェクトの浅いコピーで得た知識を活用するため、まだお読みでない方については改めてお読みいただき、その後こちらをご覧ください。\n\n[オブジェクトを浅くコピーする](shallow-copy-object.md)\n\n## 今回行うマージについて\n\nマージという言葉をよく聞くのは Git などに代表される VCS (Version Control System) でしょう。一般的にマージはする側とされる側が存在し、する側にされる側のすべて (時に選択できる) が移動ないしコピーされることを指すことが多いでしょう。\n\nJavaScript, TypeScript でコードベースで行われるマージは VCS のそれとは少々異なり、ふたつのオブジェクトから新しいマージ済みのオブジェクトを生成することが主流です。\n\n### マージをするには\n\nオブジェクトを浅くコピーする知識を使います。おさらいとして浅いコピーはスプレッド構文を使えば次のように書くだけです。\n\n```ts twoslash\nconst obj: object = {\n  why: \"reason\",\n};\n// ---cut---\nconst copied = { ...obj };\n```\n\nオブジェクトのマージはマージしたいオブジェクトを引数のようにスプレッド構文で並べるだけでコピーができます\n\n```ts twoslash\nconst obj1: object = {\n  why: \"reason\",\n};\nconst obj2: object = {\n  where: \"place\",\n};\n// ---cut---\nconst merged = { ...obj1, ...obj2 };\n```\n\n### うれしいこと\n\nオブジェクトのマージはふたつにとどまらず、何個でもオブジェクトをマージできます。\n\n```ts twoslash\nconst obj1: object = {\n  why: \"reason\",\n};\nconst obj2: object = {\n  where: \"place\",\n};\nconst obj3: object = {\n  how: \"way\",\n};\n// ---cut---\nconst merged = {\n  ...obj1,\n  ...obj2,\n  ...obj3,\n  // ...\n};\n```\n\n浅いコピーのときもES2017で出力しましたのでこちらも併せて出力すると\n\n<!--prettier-ignore-->\n```ts twoslash\nconst obj1: object = {\n  why: 'reason'\n};\nconst obj2: object = {\n  where: 'place'\n};\nconst obj3: object = {\n  how: 'way'\n};\n// ---cut---\nconst merged = Object.assign(Object.assign(Object.assign({}, obj1), obj2), obj3);\n```\n\nとコンパイルされます。ちなみにこれは少々冗長で\n\n```ts twoslash\nconst obj1: object = {\n  why: \"reason\",\n};\nconst obj2: object = {\n  where: \"place\",\n};\nconst obj3: object = {\n  how: \"way\",\n};\n// ---cut---\nconst merged = Object.assign({}, obj1, obj2, obj3);\n```\n\nと書いても同じ結果になります。\n\n### 注意すること\n\n同名のキーがある場合、必ず最後に書かれているものが優先されます。値を消し込まないように注意してください。\n\n```ts twoslash\nconst obj1: object = {\n  firstName: \"Otto\",\n  middleName: \"von\",\n  lastName: \"Bismarck\",\n};\nconst obj2: object = {\n  firstName: \"Yuko\",\n  lastName: \"Sato\",\n};\n\nconst merged: object = { ...obj1, ...obj2 };\n\nconsole.log(merged);\n// @log: { firstName: \"Yuko\", middleName: \"von\" lastName: \"Sato\" }\n```\n",
      "url": "https://typescriptbook.jp/tips/merge-objects"
    }
  ]
}
